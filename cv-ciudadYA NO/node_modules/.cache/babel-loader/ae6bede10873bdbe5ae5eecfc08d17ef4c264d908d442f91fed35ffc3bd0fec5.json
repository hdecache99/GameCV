{"ast":null,"code":"import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { Bounds } from './bounds/Bounds.mjs';\nimport { clearList } from './utils/clearList.mjs';\nimport { executeInstructions } from './utils/executeInstructions.mjs';\nimport { updateRenderGroupTransforms } from './utils/updateRenderGroupTransforms.mjs';\nimport { validateRenderables } from './utils/validateRenderables.mjs';\n\"use strict\";\nconst tempMatrix = new Matrix();\nclass RenderGroupSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  render({\n    container,\n    transform\n  }) {\n    const parent = container.parent;\n    const renderGroupParent = container.renderGroup.renderGroupParent;\n    container.parent = null;\n    container.renderGroup.renderGroupParent = null;\n    const renderer = this._renderer;\n    let originalLocalTransform = tempMatrix;\n    if (transform) {\n      originalLocalTransform = originalLocalTransform.copyFrom(container.renderGroup.localTransform);\n      container.renderGroup.localTransform.copyFrom(transform);\n    }\n    const renderPipes = renderer.renderPipes;\n    this._updateCachedRenderGroups(container.renderGroup, null);\n    this._updateRenderGroups(container.renderGroup);\n    renderer.globalUniforms.start({\n      worldTransformMatrix: transform ? container.renderGroup.localTransform : container.renderGroup.worldTransform,\n      worldColor: container.renderGroup.worldColorAlpha\n    });\n    executeInstructions(container.renderGroup, renderPipes);\n    if (renderPipes.uniformBatch) {\n      renderPipes.uniformBatch.renderEnd();\n    }\n    if (transform) {\n      container.renderGroup.localTransform.copyFrom(originalLocalTransform);\n    }\n    container.parent = parent;\n    container.renderGroup.renderGroupParent = renderGroupParent;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n  _updateCachedRenderGroups(renderGroup, closestCacheAsTexture) {\n    if (renderGroup.isCachedAsTexture) {\n      if (!renderGroup.updateCacheTexture) return;\n      closestCacheAsTexture = renderGroup;\n    }\n    renderGroup._parentCacheAsTextureRenderGroup = closestCacheAsTexture;\n    for (let i = renderGroup.renderGroupChildren.length - 1; i >= 0; i--) {\n      this._updateCachedRenderGroups(renderGroup.renderGroupChildren[i], closestCacheAsTexture);\n    }\n    renderGroup.invalidateMatrices();\n    if (renderGroup.isCachedAsTexture) {\n      if (renderGroup.textureNeedsUpdate) {\n        const bounds = renderGroup.root.getLocalBounds();\n        bounds.ceil();\n        const lastTexture = renderGroup.texture;\n        if (renderGroup.texture) {\n          TexturePool.returnTexture(renderGroup.texture);\n        }\n        const renderer = this._renderer;\n        const resolution = renderGroup.textureOptions.resolution || renderer.view.resolution;\n        const antialias = renderGroup.textureOptions.antialias ?? renderer.view.antialias;\n        renderGroup.texture = TexturePool.getOptimalTexture(bounds.width, bounds.height, resolution, antialias);\n        renderGroup._textureBounds || (renderGroup._textureBounds = new Bounds());\n        renderGroup._textureBounds.copyFrom(bounds);\n        if (lastTexture !== renderGroup.texture) {\n          if (renderGroup.renderGroupParent) {\n            renderGroup.renderGroupParent.structureDidChange = true;\n          }\n        }\n      }\n    } else if (renderGroup.texture) {\n      TexturePool.returnTexture(renderGroup.texture);\n      renderGroup.texture = null;\n    }\n  }\n  _updateRenderGroups(renderGroup) {\n    const renderer = this._renderer;\n    const renderPipes = renderer.renderPipes;\n    renderGroup.runOnRender(renderer);\n    renderGroup.instructionSet.renderPipes = renderPipes;\n    if (!renderGroup.structureDidChange) {\n      validateRenderables(renderGroup, renderPipes);\n    } else {\n      clearList(renderGroup.childrenRenderablesToUpdate.list, 0);\n    }\n    updateRenderGroupTransforms(renderGroup);\n    if (renderGroup.structureDidChange) {\n      renderGroup.structureDidChange = false;\n      this._buildInstructions(renderGroup, renderer);\n    } else {\n      this._updateRenderables(renderGroup);\n    }\n    renderGroup.childrenRenderablesToUpdate.index = 0;\n    renderer.renderPipes.batch.upload(renderGroup.instructionSet);\n    if (renderGroup.isCachedAsTexture && !renderGroup.textureNeedsUpdate) return;\n    for (let i = 0; i < renderGroup.renderGroupChildren.length; i++) {\n      this._updateRenderGroups(renderGroup.renderGroupChildren[i]);\n    }\n  }\n  _updateRenderables(renderGroup) {\n    const {\n      list,\n      index\n    } = renderGroup.childrenRenderablesToUpdate;\n    for (let i = 0; i < index; i++) {\n      const container = list[i];\n      if (container.didViewUpdate) {\n        renderGroup.updateRenderable(container);\n      }\n    }\n    clearList(list, index);\n  }\n  _buildInstructions(renderGroup, rendererOrPipes) {\n    const root = renderGroup.root;\n    const instructionSet = renderGroup.instructionSet;\n    instructionSet.reset();\n    const renderer = rendererOrPipes.renderPipes ? rendererOrPipes : rendererOrPipes.batch.renderer;\n    const renderPipes = renderer.renderPipes;\n    renderPipes.batch.buildStart(instructionSet);\n    renderPipes.blendMode.buildStart();\n    renderPipes.colorMask.buildStart();\n    if (root.sortableChildren) {\n      root.sortChildren();\n    }\n    root.collectRenderablesWithEffects(instructionSet, renderer, null);\n    renderPipes.batch.buildEnd(instructionSet);\n    renderPipes.blendMode.buildEnd(instructionSet);\n  }\n}\n/** @ignore */\nRenderGroupSystem.extension = {\n  type: [ExtensionType.WebGLSystem, ExtensionType.WebGPUSystem, ExtensionType.CanvasSystem],\n  name: \"renderGroup\"\n};\nexport { RenderGroupSystem };","map":{"version":3,"names":["tempMatrix","Matrix","RenderGroupSystem","constructor","renderer","_renderer","render","container","transform","parent","renderGroupParent","renderGroup","originalLocalTransform","copyFrom","localTransform","renderPipes","_updateCachedRenderGroups","_updateRenderGroups","globalUniforms","start","worldTransformMatrix","worldTransform","worldColor","worldColorAlpha","executeInstructions","uniformBatch","renderEnd","destroy","closestCacheAsTexture","isCachedAsTexture","updateCacheTexture","_parentCacheAsTextureRenderGroup","i","renderGroupChildren","length","invalidateMatrices","textureNeedsUpdate","bounds","root","getLocalBounds","ceil","lastTexture","texture","TexturePool","returnTexture","resolution","textureOptions","view","antialias","getOptimalTexture","width","height","_textureBounds","Bounds","structureDidChange","runOnRender","instructionSet","validateRenderables","clearList","childrenRenderablesToUpdate","list","updateRenderGroupTransforms","_buildInstructions","_updateRenderables","index","batch","upload","didViewUpdate","updateRenderable","rendererOrPipes","reset","buildStart","blendMode","colorMask","sortableChildren","sortChildren","collectRenderablesWithEffects","buildEnd","extension","type","ExtensionType","WebGLSystem","WebGPUSystem","CanvasSystem","name"],"sources":["C:\\Users\\emalv\\OneDrive\\Desktop\\Portafolio\\cv-ciudad\\node_modules\\pixi.js\\src\\scene\\container\\RenderGroupSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../extensions/Extensions';\nimport { Matrix } from '../../maths/matrix/Matrix';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { Bounds } from './bounds/Bounds';\nimport { clearList } from './utils/clearList';\nimport { executeInstructions } from './utils/executeInstructions';\nimport { updateRenderGroupTransforms } from './utils/updateRenderGroupTransforms';\nimport { validateRenderables } from './utils/validateRenderables';\n\nimport type { WebGPURenderer } from '../../rendering/renderers/gpu/WebGPURenderer';\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Renderer, RenderPipes } from '../../rendering/renderers/types';\nimport type { ViewContainer } from '../view/ViewContainer';\nimport type { Container } from './Container';\nimport type { RenderGroup } from './RenderGroup';\n\nconst tempMatrix = new Matrix();\n\n/**\n * The view system manages the main canvas that is attached to the DOM.\n * This main role is to deal with how the holding the view reference and dealing with how it is resized.\n * @memberof rendering\n */\nexport class RenderGroupSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'renderGroup',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected render({ container, transform }: {container: Container, transform: Matrix}): void\n    {\n        // we need to save the parent and renderGroupParent, so we can restore them later\n        const parent = container.parent;\n        const renderGroupParent = container.renderGroup.renderGroupParent;\n\n        // we set the transforms and parents to null, so we can render the container without any transforms\n        container.parent = null;\n        container.renderGroup.renderGroupParent = null;\n\n        const renderer = this._renderer;\n\n        // collect all the renderGroups in the scene and then render them one by one..\n        let originalLocalTransform: Matrix = tempMatrix;\n\n        if (transform)\n        {\n            originalLocalTransform = originalLocalTransform.copyFrom(container.renderGroup.localTransform);\n            container.renderGroup.localTransform.copyFrom(transform);\n        }\n\n        //  this._assignTop(container.renderGroup, null);\n        const renderPipes = (renderer as WebGPURenderer).renderPipes;\n\n        this._updateCachedRenderGroups(container.renderGroup, null);\n\n        this._updateRenderGroups(container.renderGroup);\n\n        renderer.globalUniforms.start({\n            worldTransformMatrix: transform ? container.renderGroup.localTransform : container.renderGroup.worldTransform,\n            worldColor: container.renderGroup.worldColorAlpha,\n        });\n\n        executeInstructions(container.renderGroup, renderPipes);\n\n        // TODO need to add some events / runners for things like this to hook up to\n        if (renderPipes.uniformBatch)\n        {\n            renderPipes.uniformBatch.renderEnd();\n        }\n\n        // now return the transforms back to normal..\n        if (transform)\n        {\n            container.renderGroup.localTransform.copyFrom(originalLocalTransform);\n        }\n\n        container.parent = parent;\n        container.renderGroup.renderGroupParent = renderGroupParent;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n    }\n\n    private _updateCachedRenderGroups(renderGroup: RenderGroup, closestCacheAsTexture: RenderGroup | null): void\n    {\n        if (renderGroup.isCachedAsTexture)\n        {\n            // early out as nothing further needs to be updated!\n            if (!renderGroup.updateCacheTexture) return;\n\n            closestCacheAsTexture = renderGroup;\n        }\n\n        renderGroup._parentCacheAsTextureRenderGroup = closestCacheAsTexture;\n\n        // now check the cacheAsTexture stuff...\n        for (let i = renderGroup.renderGroupChildren.length - 1; i >= 0; i--)\n        {\n            this._updateCachedRenderGroups(renderGroup.renderGroupChildren[i], closestCacheAsTexture);\n        }\n\n        renderGroup.invalidateMatrices();\n\n        if (renderGroup.isCachedAsTexture)\n        {\n            if (renderGroup.textureNeedsUpdate)\n            {\n                // lets get the texture ready for rendering\n                // but the rendering will not happen until the renderGroup is rendered!\n                // We also want to know now, what the bounds of the texture will be.\n                // as if the texture changes, we need to invalidate the parent render group!\n                const bounds = renderGroup.root.getLocalBounds();\n\n                bounds.ceil();\n\n                const lastTexture = renderGroup.texture;\n\n                if (renderGroup.texture)\n                {\n                    TexturePool.returnTexture(renderGroup.texture);\n                }\n\n                const renderer = this._renderer;\n                const resolution = renderGroup.textureOptions.resolution || renderer.view.resolution;\n                const antialias = renderGroup.textureOptions.antialias ?? renderer.view.antialias;\n\n                renderGroup.texture = TexturePool.getOptimalTexture(\n                    bounds.width,\n                    bounds.height,\n                    resolution,\n                    antialias\n                );\n\n                renderGroup._textureBounds ||= new Bounds();\n                renderGroup._textureBounds.copyFrom(bounds);\n\n                if (lastTexture !== renderGroup.texture)\n                {\n                    if (renderGroup.renderGroupParent)\n                    {\n                        renderGroup.renderGroupParent.structureDidChange = true;\n                    }\n                }\n            }\n        }\n        else if (renderGroup.texture)\n        {\n            TexturePool.returnTexture(renderGroup.texture);\n            renderGroup.texture = null;\n        }\n    }\n\n    private _updateRenderGroups(renderGroup: RenderGroup): void\n    {\n        const renderer = this._renderer;\n        const renderPipes = renderer.renderPipes;\n\n        renderGroup.runOnRender(renderer);\n\n        renderGroup.instructionSet.renderPipes = renderPipes;\n\n        if (!renderGroup.structureDidChange)\n        {\n            // phase 1 - validate all the renderables\n            validateRenderables(renderGroup, renderPipes);\n        }\n        else\n        {\n            clearList(renderGroup.childrenRenderablesToUpdate.list, 0);\n        }\n\n        // phase 2 - update all the transforms\n        // including updating the renderables..\n        updateRenderGroupTransforms(renderGroup);\n\n        if (renderGroup.structureDidChange)\n        {\n            renderGroup.structureDidChange = false;\n\n            // build the renderables\n            this._buildInstructions(renderGroup, renderer);\n        }\n        else\n        {\n            // update remaining renderables\n            this._updateRenderables(renderGroup);\n        }\n\n        // reset the renderables to update\n        renderGroup.childrenRenderablesToUpdate.index = 0;\n\n        // upload all the things!\n        renderer.renderPipes.batch.upload(renderGroup.instructionSet);\n\n        // early out if it's a texture and it hasn't changed!\n        if (renderGroup.isCachedAsTexture && !renderGroup.textureNeedsUpdate) return;\n\n        for (let i = 0; i < renderGroup.renderGroupChildren.length; i++)\n        {\n            this._updateRenderGroups(renderGroup.renderGroupChildren[i]);\n        }\n    }\n\n    private _updateRenderables(renderGroup: RenderGroup)\n    {\n        const { list, index } = renderGroup.childrenRenderablesToUpdate;\n\n        for (let i = 0; i < index; i++)\n        {\n            const container = list[i];\n\n            if (container.didViewUpdate)\n            {\n                renderGroup.updateRenderable(container as ViewContainer);\n            }\n        }\n\n        clearList(list, index);\n    }\n\n    /**\n     * @param renderGroup\n     * @param renderPipes\n     * @deprecated since 8.3.0\n     */\n    private _buildInstructions(renderGroup: RenderGroup, renderPipes: RenderPipes): void;\n    private _buildInstructions(renderGroup: RenderGroup, renderer: Renderer): void;\n    private _buildInstructions(renderGroup: RenderGroup, rendererOrPipes: RenderPipes | Renderer): void\n    {\n    // rebuild the scene graph based on layers...\n        const root = renderGroup.root;\n        const instructionSet = renderGroup.instructionSet;\n\n        instructionSet.reset();\n\n        // deprecate the use of renderPipes by finding the renderer attached to the batch pipe as this is always there\n        const renderer = (rendererOrPipes as Renderer).renderPipes\n            ? (rendererOrPipes as Renderer)\n            : (rendererOrPipes as RenderPipes).batch.renderer;\n        const renderPipes = renderer.renderPipes;\n\n        // TODO add some events / runners for build start\n        renderPipes.batch.buildStart(instructionSet);\n        renderPipes.blendMode.buildStart();\n        renderPipes.colorMask.buildStart();\n\n        if (root.sortableChildren)\n        {\n            root.sortChildren();\n        }\n\n        root.collectRenderablesWithEffects(instructionSet, renderer, null);\n\n        // TODO add some events / runners for build end\n        renderPipes.batch.buildEnd(instructionSet);\n        renderPipes.blendMode.buildEnd(instructionSet);\n    }\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}