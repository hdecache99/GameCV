{"ast":null,"code":"import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { getMaxTexturesPerBatch } from '../../../batcher/gl/utils/maxRecommendedTextures.mjs';\nimport { generateShaderSyncCode } from './GenerateShaderSyncCode.mjs';\nimport { generateProgram } from './program/generateProgram.mjs';\n\"use strict\";\nconst defaultSyncData = {\n  textureCount: 0,\n  blockIndex: 0\n};\nclass GlShaderSystem {\n  constructor(renderer) {\n    /**\n     * @internal\n     * @private\n     */\n    this._activeProgram = null;\n    this._programDataHash = /* @__PURE__ */Object.create(null);\n    this._shaderSyncFunctions = /* @__PURE__ */Object.create(null);\n    this._renderer = renderer;\n    this._renderer.renderableGC.addManagedHash(this, \"_programDataHash\");\n  }\n  contextChange(gl) {\n    this._gl = gl;\n    this._programDataHash = /* @__PURE__ */Object.create(null);\n    this._shaderSyncFunctions = /* @__PURE__ */Object.create(null);\n    this._activeProgram = null;\n    this.maxTextures = getMaxTexturesPerBatch();\n  }\n  /**\n   * Changes the current shader to the one given in parameter.\n   * @param shader - the new shader\n   * @param skipSync - false if the shader should automatically sync its uniforms.\n   * @returns the glProgram that belongs to the shader.\n   */\n  bind(shader, skipSync) {\n    this._setProgram(shader.glProgram);\n    if (skipSync) return;\n    defaultSyncData.textureCount = 0;\n    defaultSyncData.blockIndex = 0;\n    let syncFunction = this._shaderSyncFunctions[shader.glProgram._key];\n    if (!syncFunction) {\n      syncFunction = this._shaderSyncFunctions[shader.glProgram._key] = this._generateShaderSync(shader, this);\n    }\n    this._renderer.buffer.nextBindBase(!!shader.glProgram.transformFeedbackVaryings);\n    syncFunction(this._renderer, shader, defaultSyncData);\n  }\n  /**\n   * Updates the uniform group.\n   * @param uniformGroup - the uniform group to update\n   */\n  updateUniformGroup(uniformGroup) {\n    this._renderer.uniformGroup.updateUniformGroup(uniformGroup, this._activeProgram, defaultSyncData);\n  }\n  /**\n   * Binds a uniform block to the shader.\n   * @param uniformGroup - the uniform group to bind\n   * @param name - the name of the uniform block\n   * @param index - the index of the uniform block\n   */\n  bindUniformBlock(uniformGroup, name, index = 0) {\n    const bufferSystem = this._renderer.buffer;\n    const programData = this._getProgramData(this._activeProgram);\n    const isBufferResource = uniformGroup._bufferResource;\n    if (!isBufferResource) {\n      this._renderer.ubo.updateUniformGroup(uniformGroup);\n    }\n    const buffer = uniformGroup.buffer;\n    const glBuffer = bufferSystem.updateBuffer(buffer);\n    const boundLocation = bufferSystem.freeLocationForBufferBase(glBuffer);\n    if (isBufferResource) {\n      const {\n        offset,\n        size\n      } = uniformGroup;\n      if (offset === 0 && size === buffer.data.byteLength) {\n        bufferSystem.bindBufferBase(glBuffer, boundLocation);\n      } else {\n        bufferSystem.bindBufferRange(glBuffer, boundLocation, offset);\n      }\n    } else if (bufferSystem.getLastBindBaseLocation(glBuffer) !== boundLocation) {\n      bufferSystem.bindBufferBase(glBuffer, boundLocation);\n    }\n    const uniformBlockIndex = this._activeProgram._uniformBlockData[name].index;\n    if (programData.uniformBlockBindings[index] === boundLocation) return;\n    programData.uniformBlockBindings[index] = boundLocation;\n    this._renderer.gl.uniformBlockBinding(programData.program, uniformBlockIndex, boundLocation);\n  }\n  _setProgram(program) {\n    if (this._activeProgram === program) return;\n    this._activeProgram = program;\n    const programData = this._getProgramData(program);\n    this._gl.useProgram(programData.program);\n  }\n  /**\n   * @param program - the program to get the data for\n   * @internal\n   * @private\n   */\n  _getProgramData(program) {\n    return this._programDataHash[program._key] || this._createProgramData(program);\n  }\n  _createProgramData(program) {\n    const key = program._key;\n    this._programDataHash[key] = generateProgram(this._gl, program);\n    return this._programDataHash[key];\n  }\n  destroy() {\n    for (const key of Object.keys(this._programDataHash)) {\n      const programData = this._programDataHash[key];\n      programData.destroy();\n      this._programDataHash[key] = null;\n    }\n    this._programDataHash = null;\n  }\n  /**\n   * Creates a function that can be executed that will sync the shader as efficiently as possible.\n   * Overridden by the unsafe eval package if you don't want eval used in your project.\n   * @param shader - the shader to generate the sync function for\n   * @param shaderSystem - the shader system to use\n   * @returns - the generated sync function\n   * @ignore\n   */\n  _generateShaderSync(shader, shaderSystem) {\n    return generateShaderSyncCode(shader, shaderSystem);\n  }\n  resetState() {\n    this._activeProgram = null;\n  }\n}\n/** @ignore */\nGlShaderSystem.extension = {\n  type: [ExtensionType.WebGLSystem],\n  name: \"shader\"\n};\nexport { GlShaderSystem };","map":{"version":3,"names":["defaultSyncData","textureCount","blockIndex","GlShaderSystem","constructor","renderer","_activeProgram","_programDataHash","Object","create","_shaderSyncFunctions","_renderer","renderableGC","addManagedHash","contextChange","gl","_gl","maxTextures","getMaxTexturesPerBatch","bind","shader","skipSync","_setProgram","glProgram","syncFunction","_key","_generateShaderSync","buffer","nextBindBase","transformFeedbackVaryings","updateUniformGroup","uniformGroup","bindUniformBlock","name","index","bufferSystem","programData","_getProgramData","isBufferResource","_bufferResource","ubo","glBuffer","updateBuffer","boundLocation","freeLocationForBufferBase","offset","size","data","byteLength","bindBufferBase","bindBufferRange","getLastBindBaseLocation","uniformBlockIndex","_uniformBlockData","uniformBlockBindings","uniformBlockBinding","program","useProgram","_createProgramData","key","generateProgram","destroy","keys","shaderSystem","generateShaderSyncCode","resetState","extension","type","ExtensionType","WebGLSystem"],"sources":["C:\\Users\\emalv\\OneDrive\\Desktop\\Portafolio\\cv-ciudad\\node_modules\\pixi.js\\src\\rendering\\renderers\\gl\\shader\\GlShaderSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions';\nimport { getMaxTexturesPerBatch } from '../../../batcher/gl/utils/maxRecommendedTextures';\nimport { generateShaderSyncCode } from './GenerateShaderSyncCode';\nimport { generateProgram } from './program/generateProgram';\n\nimport type { BufferResource } from '../../shared/buffer/BufferResource';\nimport type { Shader } from '../../shared/shader/Shader';\nimport type { ShaderSystem } from '../../shared/shader/ShaderSystem';\nimport type { UniformGroup } from '../../shared/shader/UniformGroup';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { WebGLRenderer } from '../WebGLRenderer';\nimport type { GlProgram } from './GlProgram';\nimport type { GlProgramData } from './GlProgramData';\n\nexport interface ShaderSyncData\n{\n    textureCount: number;\n    blockIndex: number;\n}\n\nexport type ShaderSyncFunction = (renderer: WebGLRenderer, shader: Shader, syncData: ShaderSyncData) => void;\n\n// default sync data so we don't create a new one each time!\nconst defaultSyncData: ShaderSyncData = {\n    textureCount: 0,\n    blockIndex: 0,\n};\n\n/**\n * System plugin to the renderer to manage the shaders for WebGL.\n * @memberof rendering\n */\nexport class GlShaderSystem implements ShaderSystem\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'shader',\n    } as const;\n\n    public maxTextures: number;\n\n    /**\n     * @internal\n     * @private\n     */\n    public _activeProgram: GlProgram = null;\n\n    private _programDataHash: Record<string, GlProgramData> = Object.create(null);\n    private readonly _renderer: WebGLRenderer;\n    public _gl: WebGL2RenderingContext;\n    private _shaderSyncFunctions: Record<string, ShaderSyncFunction> = Object.create(null);\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, '_programDataHash');\n    }\n\n    protected contextChange(gl: GlRenderingContext): void\n    {\n        this._gl = gl;\n\n        this._programDataHash = Object.create(null);\n        /**\n         * these need to also be cleared as internally some uniforms are set as an optimisation as the sync\n         * function is generated. Specifically the texture ints.\n         */\n        this._shaderSyncFunctions = Object.create(null);\n        this._activeProgram = null;\n        this.maxTextures = getMaxTexturesPerBatch();\n    }\n\n    /**\n     * Changes the current shader to the one given in parameter.\n     * @param shader - the new shader\n     * @param skipSync - false if the shader should automatically sync its uniforms.\n     * @returns the glProgram that belongs to the shader.\n     */\n    public bind(shader: Shader, skipSync?: boolean): void\n    {\n        this._setProgram(shader.glProgram);\n\n        if (skipSync) return;\n\n        defaultSyncData.textureCount = 0;\n        defaultSyncData.blockIndex = 0;\n\n        let syncFunction = this._shaderSyncFunctions[shader.glProgram._key];\n\n        if (!syncFunction)\n        {\n            syncFunction = this._shaderSyncFunctions[shader.glProgram._key] = this._generateShaderSync(shader, this);\n        }\n\n        // TODO: take into account number of TF buffers. Currently works only with interleaved\n        this._renderer.buffer.nextBindBase(!!shader.glProgram.transformFeedbackVaryings);\n        syncFunction(this._renderer, shader, defaultSyncData);\n    }\n\n    /**\n     * Updates the uniform group.\n     * @param uniformGroup - the uniform group to update\n     */\n    public updateUniformGroup(uniformGroup: UniformGroup): void\n    {\n        this._renderer.uniformGroup.updateUniformGroup(uniformGroup, this._activeProgram, defaultSyncData);\n    }\n\n    /**\n     * Binds a uniform block to the shader.\n     * @param uniformGroup - the uniform group to bind\n     * @param name - the name of the uniform block\n     * @param index - the index of the uniform block\n     */\n    public bindUniformBlock(uniformGroup: UniformGroup | BufferResource, name: string, index = 0): void\n    {\n        const bufferSystem = this._renderer.buffer;\n        const programData = this._getProgramData(this._activeProgram);\n\n        const isBufferResource = (uniformGroup as BufferResource)._bufferResource;\n\n        if (!isBufferResource)\n        {\n            this._renderer.ubo.updateUniformGroup(uniformGroup as UniformGroup);\n        }\n\n        const buffer = uniformGroup.buffer;\n\n        const glBuffer = bufferSystem.updateBuffer(buffer);\n\n        const boundLocation = bufferSystem.freeLocationForBufferBase(glBuffer);\n\n        if (isBufferResource)\n        {\n            const { offset, size } = (uniformGroup as BufferResource);\n\n            // trivial case of buffer resource, can be cached\n            if (offset === 0 && size === buffer.data.byteLength)\n            {\n                bufferSystem.bindBufferBase(glBuffer, boundLocation);\n            }\n            else\n            {\n                bufferSystem.bindBufferRange(glBuffer, boundLocation, offset);\n            }\n        }\n        else if (bufferSystem.getLastBindBaseLocation(glBuffer) !== boundLocation)\n        {\n            // confirmation that buffer isn't there yet\n            bufferSystem.bindBufferBase(glBuffer, boundLocation);\n        }\n\n        const uniformBlockIndex = this._activeProgram._uniformBlockData[name].index;\n\n        if (programData.uniformBlockBindings[index] === boundLocation) return;\n        programData.uniformBlockBindings[index] = boundLocation;\n\n        this._renderer.gl.uniformBlockBinding(programData.program, uniformBlockIndex, boundLocation);\n    }\n\n    private _setProgram(program: GlProgram)\n    {\n        if (this._activeProgram === program) return;\n\n        this._activeProgram = program;\n\n        const programData = this._getProgramData(program);\n\n        this._gl.useProgram(programData.program);\n    }\n\n    /**\n     * @param program - the program to get the data for\n     * @internal\n     * @private\n     */\n    public _getProgramData(program: GlProgram): GlProgramData\n    {\n        return this._programDataHash[program._key] || this._createProgramData(program);\n    }\n\n    private _createProgramData(program: GlProgram): GlProgramData\n    {\n        const key = program._key;\n\n        this._programDataHash[key] = generateProgram(this._gl, program);\n\n        return this._programDataHash[key];\n    }\n\n    public destroy(): void\n    {\n        for (const key of Object.keys(this._programDataHash))\n        {\n            const programData = this._programDataHash[key];\n\n            programData.destroy();\n            this._programDataHash[key] = null;\n        }\n\n        this._programDataHash = null;\n    }\n\n    /**\n     * Creates a function that can be executed that will sync the shader as efficiently as possible.\n     * Overridden by the unsafe eval package if you don't want eval used in your project.\n     * @param shader - the shader to generate the sync function for\n     * @param shaderSystem - the shader system to use\n     * @returns - the generated sync function\n     * @ignore\n     */\n    public _generateShaderSync(shader: Shader, shaderSystem: GlShaderSystem): ShaderSyncFunction\n    {\n        return generateShaderSyncCode(shader, shaderSystem);\n    }\n\n    public resetState(): void\n    {\n        this._activeProgram = null;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}