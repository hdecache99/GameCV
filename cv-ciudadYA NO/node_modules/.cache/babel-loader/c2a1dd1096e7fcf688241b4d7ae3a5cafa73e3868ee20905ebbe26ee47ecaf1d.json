{"ast":null,"code":"\"use strict\";\n\nclass BatchableMesh {\n  constructor() {\n    this.batcherName = \"default\";\n    this.packAsQuad = false;\n    this.indexOffset = 0;\n    this.attributeOffset = 0;\n    this.roundPixels = 0;\n    this._batcher = null;\n    this._batch = null;\n    this._textureMatrixUpdateId = -1;\n    this._uvUpdateId = -1;\n  }\n  get blendMode() {\n    return this.renderable.groupBlendMode;\n  }\n  get topology() {\n    return this._topology || this.geometry.topology;\n  }\n  set topology(value) {\n    this._topology = value;\n  }\n  reset() {\n    this.renderable = null;\n    this.texture = null;\n    this._batcher = null;\n    this._batch = null;\n    this.geometry = null;\n    this._uvUpdateId = -1;\n    this._textureMatrixUpdateId = -1;\n  }\n  /**\n   * Sets the texture for the batchable mesh.\n   * As it does so, it resets the texture matrix update ID.\n   * this is to ensure that the texture matrix is recalculated when the uvs are referenced\n   * @param value - The texture to set.\n   */\n  setTexture(value) {\n    if (this.texture === value) return;\n    this.texture = value;\n    this._textureMatrixUpdateId = -1;\n  }\n  get uvs() {\n    const geometry = this.geometry;\n    const uvBuffer = geometry.getBuffer(\"aUV\");\n    const uvs = uvBuffer.data;\n    let transformedUvs = uvs;\n    const textureMatrix = this.texture.textureMatrix;\n    if (!textureMatrix.isSimple) {\n      transformedUvs = this._transformedUvs;\n      if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID) {\n        if (!transformedUvs || transformedUvs.length < uvs.length) {\n          transformedUvs = this._transformedUvs = new Float32Array(uvs.length);\n        }\n        this._textureMatrixUpdateId = textureMatrix._updateID;\n        this._uvUpdateId = uvBuffer._updateID;\n        textureMatrix.multiplyUvs(uvs, transformedUvs);\n      }\n    }\n    return transformedUvs;\n  }\n  get positions() {\n    return this.geometry.positions;\n  }\n  get indices() {\n    return this.geometry.indices;\n  }\n  get color() {\n    return this.renderable.groupColorAlpha;\n  }\n  get groupTransform() {\n    return this.renderable.groupTransform;\n  }\n  get attributeSize() {\n    return this.geometry.positions.length / 2;\n  }\n  get indexSize() {\n    return this.geometry.indices.length;\n  }\n}\nexport { BatchableMesh };","map":{"version":3,"names":["BatchableMesh","constructor","batcherName","packAsQuad","indexOffset","attributeOffset","roundPixels","_batcher","_batch","_textureMatrixUpdateId","_uvUpdateId","blendMode","renderable","groupBlendMode","topology","_topology","geometry","value","reset","texture","setTexture","uvs","uvBuffer","getBuffer","data","transformedUvs","textureMatrix","isSimple","_transformedUvs","_updateID","length","Float32Array","multiplyUvs","positions","indices","color","groupColorAlpha","groupTransform","attributeSize","indexSize"],"sources":["C:\\Users\\emalv\\OneDrive\\Desktop\\Portafolio\\cv-ciudad\\node_modules\\pixi.js\\src\\scene\\mesh\\shared\\BatchableMesh.ts"],"sourcesContent":["import type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { Batch, Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableMeshElement } from '../../../rendering/batcher/shared/DefaultBatcher';\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { ViewContainer } from '../../view/ViewContainer';\nimport type { MeshGeometry } from './MeshGeometry';\n\n/**\n * A batchable mesh object.\n * @ignore\n */\nexport class BatchableMesh implements DefaultBatchableMeshElement\n{\n    public batcherName = 'default';\n\n    public _topology: Topology;\n\n    public readonly packAsQuad = false;\n    public location: number;\n\n    public renderable: ViewContainer;\n\n    public indexOffset = 0;\n    public attributeOffset = 0;\n\n    public texture: Texture;\n    public geometry: MeshGeometry;\n    public transform: Matrix;\n    public roundPixels: 0 | 1 = 0;\n\n    public _attributeStart: number;\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n    public _indexStart: number;\n    public _textureId: number;\n    public _textureMatrixUpdateId: number = -1;\n\n    private _transformedUvs: Float32Array;\n    private _uvUpdateId: number = -1;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n\n    get topology() { return this._topology || this.geometry.topology; }\n    set topology(value: Topology) { this._topology = value; }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this._batcher = null;\n        this._batch = null;\n        this.geometry = null;\n        this._uvUpdateId = -1;\n        this._textureMatrixUpdateId = -1;\n    }\n\n    /**\n     * Sets the texture for the batchable mesh.\n     * As it does so, it resets the texture matrix update ID.\n     * this is to ensure that the texture matrix is recalculated when the uvs are referenced\n     * @param value - The texture to set.\n     */\n    public setTexture(value: Texture)\n    {\n        if (this.texture === value) return;\n\n        this.texture = value;\n        this._textureMatrixUpdateId = -1;\n    }\n\n    get uvs()\n    {\n        const geometry = this.geometry;\n\n        const uvBuffer = geometry.getBuffer('aUV');\n\n        const uvs = uvBuffer.data;\n\n        let transformedUvs = uvs;\n        const textureMatrix = this.texture.textureMatrix;\n\n        if (!textureMatrix.isSimple)\n        {\n            transformedUvs = this._transformedUvs;\n\n            if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID)\n            {\n                if (!transformedUvs || transformedUvs.length < uvs.length)\n                {\n                    transformedUvs = this._transformedUvs = new Float32Array(uvs.length);\n                }\n\n                this._textureMatrixUpdateId = textureMatrix._updateID;\n                this._uvUpdateId = uvBuffer._updateID;\n\n                textureMatrix.multiplyUvs(uvs as Float32Array, transformedUvs);\n            }\n        }\n\n        return transformedUvs as Float32Array;\n    }\n\n    get positions()\n    {\n        return this.geometry.positions;\n    }\n\n    get indices()\n    {\n        return this.geometry.indices;\n    }\n\n    get color()\n    {\n        return this.renderable.groupColorAlpha;\n    }\n\n    get groupTransform()\n    {\n        return this.renderable.groupTransform;\n    }\n\n    get attributeSize()\n    {\n        return this.geometry.positions.length / 2;\n    }\n\n    get indexSize()\n    {\n        return this.geometry.indices.length;\n    }\n}\n"],"mappings":";;AAYO,MAAMA,aACb;EADOC,YAAA;IAEH,KAAOC,WAAc;IAIrB,KAAgBC,UAAa;IAK7B,KAAOC,WAAc;IACrB,KAAOC,eAAkB;IAKzB,KAAOC,WAAqB;IAG5B,KAAOC,QAAoB;IAC3B,KAAOC,MAAgB;IAGvB,KAAOC,sBAAiC;IAGxC,KAAQC,WAAsB;EAAA;EAE9B,IAAIC,SAAYA,CAAA;IAAE,OAAO,KAAKC,UAAW,CAAAC,cAAA;EAAA;EAEzC,IAAIC,QAAWA,CAAA;IAAS,YAAKC,SAAa,SAAKC,QAAS,CAAAF,QAAA;EAAA;EACxD,IAAIA,SAASG,KAAiB;IAAE,KAAKF,SAAY,GAAAE,KAAA;EAAA;EAE1CC,KACPA,CAAA;IACI,KAAKN,UAAa;IAClB,KAAKO,OAAU;IACf,KAAKZ,QAAW;IAChB,KAAKC,MAAS;IACd,KAAKQ,QAAW;IAChB,KAAKN,WAAc;IACnB,KAAKD,sBAAyB;EAAA;EAClC;AAAA;AAAA;AAAA;AAAA;AAAA;EAQOW,WAAWH,KAClB;IACI,IAAI,KAAKE,OAAY,KAAAF,KAAA,EAAO;IAE5B,KAAKE,OAAU,GAAAF,KAAA;IACf,KAAKR,sBAAyB;EAAA;EAGlC,IAAIY,GACJA,CAAA;IACI,MAAML,QAAA,GAAW,IAAK,CAAAA,QAAA;IAEhB,MAAAM,QAAA,GAAWN,QAAS,CAAAO,SAAA,CAAU,KAAK;IAEzC,MAAMF,GAAA,GAAMC,QAAS,CAAAE,IAAA;IAErB,IAAIC,cAAiB,GAAAJ,GAAA;IACf,MAAAK,aAAA,GAAgB,KAAKP,OAAQ,CAAAO,aAAA;IAE/B,KAACA,aAAA,CAAcC,QACnB;MACIF,cAAA,GAAiB,IAAK,CAAAG,eAAA;MAEtB,IAAI,KAAKnB,sBAA2B,KAAAiB,aAAA,CAAcG,SAAA,IAAa,IAAK,CAAAnB,WAAA,KAAgBY,QAAA,CAASO,SAC7F;QACI,IAAI,CAACJ,cAAA,IAAkBA,cAAe,CAAAK,MAAA,GAAST,GAAA,CAAIS,MACnD;UACIL,cAAA,GAAiB,IAAK,CAAAG,eAAA,GAAkB,IAAIG,YAAA,CAAaV,GAAA,CAAIS,MAAM;QAAA;QAGvE,KAAKrB,sBAAA,GAAyBiB,aAAc,CAAAG,SAAA;QAC5C,KAAKnB,WAAA,GAAcY,QAAS,CAAAO,SAAA;QAEdH,aAAA,CAAAM,WAAA,CAAYX,GAAA,EAAqBI,cAAc;MAAA;IACjE;IAGG,OAAAA,cAAA;EAAA;EAGX,IAAIQ,SACJA,CAAA;IACI,OAAO,KAAKjB,QAAS,CAAAiB,SAAA;EAAA;EAGzB,IAAIC,OACJA,CAAA;IACI,OAAO,KAAKlB,QAAS,CAAAkB,OAAA;EAAA;EAGzB,IAAIC,KACJA,CAAA;IACI,OAAO,KAAKvB,UAAW,CAAAwB,eAAA;EAAA;EAG3B,IAAIC,cACJA,CAAA;IACI,OAAO,KAAKzB,UAAW,CAAAyB,cAAA;EAAA;EAG3B,IAAIC,aACJA,CAAA;IACW,YAAKtB,QAAS,CAAAiB,SAAA,CAAUH,MAAS;EAAA;EAG5C,IAAIS,SACJA,CAAA;IACW,YAAKvB,QAAA,CAASkB,OAAQ,CAAAJ,MAAA;EAAA;AAErC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}