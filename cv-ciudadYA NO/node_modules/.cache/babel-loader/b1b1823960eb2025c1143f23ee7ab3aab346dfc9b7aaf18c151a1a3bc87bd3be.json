{"ast":null,"code":"import { Rectangle } from './Rectangle.mjs';\n\"use strict\";\nclass Ellipse {\n  /**\n   * @param x - The X coordinate of the center of this ellipse\n   * @param y - The Y coordinate of the center of this ellipse\n   * @param halfWidth - The half width of this ellipse\n   * @param halfHeight - The half height of this ellipse\n   */\n  constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'ellipse'\n     */\n    this.type = \"ellipse\";\n    this.x = x;\n    this.y = y;\n    this.halfWidth = halfWidth;\n    this.halfHeight = halfHeight;\n  }\n  /**\n   * Creates a clone of this Ellipse instance\n   * @returns {Ellipse} A copy of the ellipse\n   */\n  clone() {\n    return new Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this ellipse\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coords are within this ellipse\n   */\n  contains(x, y) {\n    if (this.halfWidth <= 0 || this.halfHeight <= 0) {\n      return false;\n    }\n    let normx = (x - this.x) / this.halfWidth;\n    let normy = (y - this.y) / this.halfHeight;\n    normx *= normx;\n    normy *= normy;\n    return normx + normy <= 1;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this ellipse including stroke\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @param alignment - The alignment of the stroke\n   * @returns Whether the x/y coords are within this ellipse\n   */\n  strokeContains(x, y, strokeWidth, alignment = 0.5) {\n    const {\n      halfWidth,\n      halfHeight\n    } = this;\n    if (halfWidth <= 0 || halfHeight <= 0) {\n      return false;\n    }\n    const strokeOuterWidth = strokeWidth * (1 - alignment);\n    const strokeInnerWidth = strokeWidth - strokeOuterWidth;\n    const innerHorizontal = halfWidth - strokeInnerWidth;\n    const innerVertical = halfHeight - strokeInnerWidth;\n    const outerHorizontal = halfWidth + strokeOuterWidth;\n    const outerVertical = halfHeight + strokeOuterWidth;\n    const normalizedX = x - this.x;\n    const normalizedY = y - this.y;\n    const innerEllipse = normalizedX * normalizedX / (innerHorizontal * innerHorizontal) + normalizedY * normalizedY / (innerVertical * innerVertical);\n    const outerEllipse = normalizedX * normalizedX / (outerHorizontal * outerHorizontal) + normalizedY * normalizedY / (outerVertical * outerVertical);\n    return innerEllipse > 1 && outerEllipse <= 1;\n  }\n  /**\n   * Returns the framing rectangle of the ellipse as a Rectangle object\n   * @param out\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out || (out = new Rectangle());\n    out.x = this.x - this.halfWidth;\n    out.y = this.y - this.halfHeight;\n    out.width = this.halfWidth * 2;\n    out.height = this.halfHeight * 2;\n    return out;\n  }\n  /**\n   * Copies another ellipse to this one.\n   * @param ellipse - The ellipse to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(ellipse) {\n    this.x = ellipse.x;\n    this.y = ellipse.y;\n    this.halfWidth = ellipse.halfWidth;\n    this.halfHeight = ellipse.halfHeight;\n    return this;\n  }\n  /**\n   * Copies this ellipse to another one.\n   * @param ellipse - The ellipse to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(ellipse) {\n    ellipse.copyFrom(this);\n    return ellipse;\n  }\n  toString() {\n    return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;\n  }\n}\nexport { Ellipse };","map":{"version":3,"names":["Ellipse","constructor","x","y","halfWidth","halfHeight","type","clone","contains","normx","normy","strokeContains","strokeWidth","alignment","strokeOuterWidth","strokeInnerWidth","innerHorizontal","innerVertical","outerHorizontal","outerVertical","normalizedX","normalizedY","innerEllipse","outerEllipse","getBounds","out","Rectangle","width","height","copyFrom","ellipse","copyTo","toString"],"sources":["C:\\Users\\emalv\\OneDrive\\Desktop\\Portafolio\\cv-ciudad\\node_modules\\pixi.js\\src\\maths\\shapes\\Ellipse.ts"],"sourcesContent":["import { Rectangle } from './Rectangle';\n\nimport type { ShapePrimitive } from './ShapePrimitive';\n\n/**\n * The Ellipse object is used to help draw graphics and can also be used to specify a hit area for containers.\n * ```js\n * import { Ellipse } from 'pixi.js';\n *\n * const ellipse = new Ellipse(0, 0, 20, 10); // 40x20 rectangle\n * const isPointInEllipse = ellipse.contains(0, 0); // true\n * ```\n * @memberof maths\n */\nexport class Ellipse implements ShapePrimitive\n{\n    /**\n     * The X coordinate of the center of this ellipse\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the center of this ellipse\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The half width of this ellipse\n     * @default 0\n     */\n    public halfWidth: number;\n\n    /**\n     * The half height of this ellipse\n     * @default 0\n     */\n    public halfHeight: number;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'ellipse'\n     */\n    public readonly type = 'ellipse';\n\n    /**\n     * @param x - The X coordinate of the center of this ellipse\n     * @param y - The Y coordinate of the center of this ellipse\n     * @param halfWidth - The half width of this ellipse\n     * @param halfHeight - The half height of this ellipse\n     */\n    constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0)\n    {\n        this.x = x;\n        this.y = y;\n        this.halfWidth = halfWidth;\n        this.halfHeight = halfHeight;\n    }\n\n    /**\n     * Creates a clone of this Ellipse instance\n     * @returns {Ellipse} A copy of the ellipse\n     */\n    public clone(): Ellipse\n    {\n        return new Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this ellipse\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coords are within this ellipse\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.halfWidth <= 0 || this.halfHeight <= 0)\n        {\n            return false;\n        }\n\n        // normalize the coords to an ellipse with center 0,0\n        let normx = ((x - this.x) / this.halfWidth);\n        let normy = ((y - this.y) / this.halfHeight);\n\n        normx *= normx;\n        normy *= normy;\n\n        return (normx + normy <= 1);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this ellipse including stroke\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @param alignment - The alignment of the stroke\n     * @returns Whether the x/y coords are within this ellipse\n     */\n    public strokeContains(x: number, y: number, strokeWidth: number, alignment: number = 0.5): boolean\n    {\n        const { halfWidth, halfHeight } = this;\n\n        if (halfWidth <= 0 || halfHeight <= 0)\n        {\n            return false;\n        }\n\n        const strokeOuterWidth = strokeWidth * (1 - alignment);\n        const strokeInnerWidth = strokeWidth - strokeOuterWidth;\n\n        const innerHorizontal = halfWidth - strokeInnerWidth;\n        const innerVertical = halfHeight - strokeInnerWidth;\n\n        const outerHorizontal = halfWidth + strokeOuterWidth;\n        const outerVertical = halfHeight + strokeOuterWidth;\n\n        const normalizedX = x - this.x;\n        const normalizedY = y - this.y;\n\n        const innerEllipse = ((normalizedX * normalizedX) / (innerHorizontal * innerHorizontal))\n            + ((normalizedY * normalizedY) / (innerVertical * innerVertical));\n\n        const outerEllipse = ((normalizedX * normalizedX) / (outerHorizontal * outerHorizontal))\n            + ((normalizedY * normalizedY) / (outerVertical * outerVertical));\n\n        return innerEllipse > 1 && outerEllipse <= 1;\n    }\n\n    /**\n     * Returns the framing rectangle of the ellipse as a Rectangle object\n     * @param out\n     * @returns The framing rectangle\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out ||= new Rectangle();\n\n        out.x = this.x - this.halfWidth;\n        out.y = this.y - this.halfHeight;\n        out.width = this.halfWidth * 2;\n        out.height = this.halfHeight * 2;\n\n        return out;\n    }\n\n    /**\n     * Copies another ellipse to this one.\n     * @param ellipse - The ellipse to copy from.\n     * @returns Returns itself.\n     */\n    public copyFrom(ellipse: Ellipse): this\n    {\n        this.x = ellipse.x;\n        this.y = ellipse.y;\n        this.halfWidth = ellipse.halfWidth;\n        this.halfHeight = ellipse.halfHeight;\n\n        return this;\n    }\n\n    /**\n     * Copies this ellipse to another one.\n     * @param ellipse - The ellipse to copy to.\n     * @returns Returns given parameter.\n     */\n    public copyTo(ellipse: Ellipse): Ellipse\n    {\n        ellipse.copyFrom(this);\n\n        return ellipse;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;\n    }\n    // #endif\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}