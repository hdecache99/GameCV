{"ast":null,"code":"import { Point } from '../../../maths/point/Point.mjs';\nimport { matrixPool } from '../bounds/utils/matrixAndBoundsPool.mjs';\n\"use strict\";\nconst toLocalGlobalMixin = {\n  /**\n   * Returns the global position of the container.\n   * @param point - The optional point to write the global value to.\n   * @param skipUpdate - Should we skip the update transform.\n   * @returns - The updated point.\n   * @memberof scene.Container#\n   */\n  getGlobalPosition(point = new Point(), skipUpdate = false) {\n    if (this.parent) {\n      this.parent.toGlobal(this._position, point, skipUpdate);\n    } else {\n      point.x = this._position.x;\n      point.y = this._position.y;\n    }\n    return point;\n  },\n  /**\n   * Calculates the global position of the container.\n   * @param position - The world origin to calculate from.\n   * @param point - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param skipUpdate - Should we skip the update transform.\n   * @returns - A point object representing the position of this object.\n   * @memberof scene.Container#\n   */\n  toGlobal(position, point, skipUpdate = false) {\n    const globalMatrix = this.getGlobalTransform(matrixPool.get(), skipUpdate);\n    point = globalMatrix.apply(position, point);\n    matrixPool.return(globalMatrix);\n    return point;\n  },\n  /**\n   * Calculates the local position of the container relative to another point.\n   * @param position - The world origin to calculate from.\n   * @param from - The Container to calculate the global position from.\n   * @param point - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param skipUpdate - Should we skip the update transform\n   * @returns - A point object representing the position of this object\n   * @memberof scene.Container#\n   */\n  toLocal(position, from, point, skipUpdate) {\n    if (from) {\n      position = from.toGlobal(position, point, skipUpdate);\n    }\n    const globalMatrix = this.getGlobalTransform(matrixPool.get(), skipUpdate);\n    point = globalMatrix.applyInverse(position, point);\n    matrixPool.return(globalMatrix);\n    return point;\n  }\n};\nexport { toLocalGlobalMixin };","map":{"version":3,"names":["toLocalGlobalMixin","getGlobalPosition","point","Point","skipUpdate","parent","toGlobal","_position","x","y","position","globalMatrix","getGlobalTransform","matrixPool","get","apply","return","toLocal","from","applyInverse"],"sources":["C:\\Users\\emalv\\OneDrive\\Desktop\\Portafolio\\cv-ciudad\\node_modules\\pixi.js\\src\\scene\\container\\container-mixins\\toLocalGlobalMixin.ts"],"sourcesContent":["import { Point } from '../../../maths/point/Point';\nimport { matrixPool } from '../bounds/utils/matrixAndBoundsPool';\n\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Container } from '../Container';\n\nexport interface ToLocalGlobalMixin\n{\n    getGlobalPosition(point?: Point, skipUpdate?: boolean): Point;\n    toGlobal<P extends PointData = Point>(position: PointData, point?: P, skipUpdate?: boolean): P;\n    toLocal<P extends PointData = Point>(position: PointData, from?: Container, point?: P, skipUpdate?: boolean): P;\n}\n\nexport const toLocalGlobalMixin: Partial<Container> = {\n    /**\n     * Returns the global position of the container.\n     * @param point - The optional point to write the global value to.\n     * @param skipUpdate - Should we skip the update transform.\n     * @returns - The updated point.\n     * @memberof scene.Container#\n     */\n    getGlobalPosition(point: Point = new Point(), skipUpdate = false): Point\n    {\n        if (this.parent)\n        {\n            this.parent.toGlobal(this._position, point, skipUpdate);\n        }\n        else\n        {\n            point.x = this._position.x;\n            point.y = this._position.y;\n        }\n\n        return point;\n    },\n\n    /**\n     * Calculates the global position of the container.\n     * @param position - The world origin to calculate from.\n     * @param point - A Point object in which to store the value, optional\n     *  (otherwise will create a new Point).\n     * @param skipUpdate - Should we skip the update transform.\n     * @returns - A point object representing the position of this object.\n     * @memberof scene.Container#\n     */\n    toGlobal<P extends PointData = Point>(position: PointData, point?: P, skipUpdate = false): P\n    {\n        const globalMatrix = this.getGlobalTransform(matrixPool.get(), skipUpdate);\n\n        // simply apply the matrix..\n        point = globalMatrix.apply(position, point);\n\n        matrixPool.return(globalMatrix);\n\n        return point;\n    },\n\n    /**\n     * Calculates the local position of the container relative to another point.\n     * @param position - The world origin to calculate from.\n     * @param from - The Container to calculate the global position from.\n     * @param point - A Point object in which to store the value, optional\n     *  (otherwise will create a new Point).\n     * @param skipUpdate - Should we skip the update transform\n     * @returns - A point object representing the position of this object\n     * @memberof scene.Container#\n     */\n    toLocal<P extends PointData = Point>(position: PointData, from?: Container, point?: P, skipUpdate?: boolean): P\n    {\n        if (from)\n        {\n            position = from.toGlobal(position, point, skipUpdate);\n        }\n\n        const globalMatrix = this.getGlobalTransform(matrixPool.get(), skipUpdate);\n\n        // simply apply the matrix..\n        point = globalMatrix.applyInverse(position, point);\n\n        matrixPool.return(globalMatrix);\n\n        return point;\n    }\n} as Container;\n"],"mappings":";;;AAaO,MAAMA,kBAAyC;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAQlDC,kBAAkBC,KAAe,OAAIC,KAAM,IAAGC,UAAA,GAAa,KAC3D;IACI,IAAI,KAAKC,MACT;MACI,KAAKA,MAAO,CAAAC,QAAA,CAAS,IAAK,CAAAC,SAAA,EAAWL,KAAA,EAAOE,UAAU;IAAA,CAG1D;MACUF,KAAA,CAAAM,CAAA,GAAI,KAAKD,SAAU,CAAAC,CAAA;MACnBN,KAAA,CAAAO,CAAA,GAAI,KAAKF,SAAU,CAAAE,CAAA;IAAA;IAGtB,OAAAP,KAAA;EAAA,CACX;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAWAI,QAAsCA,CAAAI,QAAA,EAAqBR,KAAW,EAAAE,UAAA,GAAa,KACnF;IACI,MAAMO,YAAA,GAAe,IAAK,CAAAC,kBAAA,CAAmBC,UAAW,CAAAC,GAAA,IAAOV,UAAU;IAGjEF,KAAA,GAAAS,YAAA,CAAaI,KAAM,CAAAL,QAAA,EAAUR,KAAK;IAE1CW,UAAA,CAAWG,MAAA,CAAOL,YAAY;IAEvB,OAAAT,KAAA;EAAA,CACX;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAYAe,OAAqCA,CAAAP,QAAA,EAAqBQ,IAAkB,EAAAhB,KAAA,EAAWE,UACvF;IACI,IAAIc,IACJ;MACIR,QAAA,GAAWQ,IAAK,CAAAZ,QAAA,CAASI,QAAU,EAAAR,KAAA,EAAOE,UAAU;IAAA;IAGxD,MAAMO,YAAA,GAAe,IAAK,CAAAC,kBAAA,CAAmBC,UAAW,CAAAC,GAAA,IAAOV,UAAU;IAGjEF,KAAA,GAAAS,YAAA,CAAaQ,YAAa,CAAAT,QAAA,EAAUR,KAAK;IAEjDW,UAAA,CAAWG,MAAA,CAAOL,YAAY;IAEvB,OAAAT,KAAA;EAAA;AAEf","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}