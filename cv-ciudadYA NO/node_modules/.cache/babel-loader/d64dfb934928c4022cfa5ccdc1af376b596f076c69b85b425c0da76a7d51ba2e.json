{"ast":null,"code":"import { warn } from '../../../../utils/logging/warn.mjs';\nimport { GraphicsPath } from '../path/GraphicsPath.mjs';\nimport { parseSVGDefinitions } from './parseSVGDefinitions.mjs';\nimport { parseSVGFloatAttribute } from './parseSVGFloatAttribute.mjs';\nimport { parseSVGStyle } from './parseSVGStyle.mjs';\n\"use strict\";\nfunction SVGParser(svg, graphicsContext) {\n  if (typeof svg === \"string\") {\n    const div = document.createElement(\"div\");\n    div.innerHTML = svg.trim();\n    svg = div.querySelector(\"svg\");\n  }\n  const session = {\n    context: graphicsContext,\n    defs: {},\n    path: new GraphicsPath()\n  };\n  parseSVGDefinitions(svg, session);\n  const children = svg.children;\n  const {\n    fillStyle,\n    strokeStyle\n  } = parseSVGStyle(svg, session);\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    if (child.nodeName.toLowerCase() === \"defs\") continue;\n    renderChildren(child, session, fillStyle, strokeStyle);\n  }\n  return graphicsContext;\n}\nfunction renderChildren(svg, session, fillStyle, strokeStyle) {\n  const children = svg.children;\n  const {\n    fillStyle: f1,\n    strokeStyle: s1\n  } = parseSVGStyle(svg, session);\n  if (f1 && fillStyle) {\n    fillStyle = {\n      ...fillStyle,\n      ...f1\n    };\n  } else if (f1) {\n    fillStyle = f1;\n  }\n  if (s1 && strokeStyle) {\n    strokeStyle = {\n      ...strokeStyle,\n      ...s1\n    };\n  } else if (s1) {\n    strokeStyle = s1;\n  }\n  const noStyle = !fillStyle && !strokeStyle;\n  if (noStyle) {\n    fillStyle = {\n      color: 0\n    };\n  }\n  let x;\n  let y;\n  let x1;\n  let y1;\n  let x2;\n  let y2;\n  let cx;\n  let cy;\n  let r;\n  let rx;\n  let ry;\n  let points;\n  let pointsString;\n  let d;\n  let graphicsPath;\n  let width;\n  let height;\n  switch (svg.nodeName.toLowerCase()) {\n    case \"path\":\n      d = svg.getAttribute(\"d\");\n      if (svg.getAttribute(\"fill-rule\") === \"evenodd\") {\n        warn(\"SVG Evenodd fill rule not supported, your svg may render incorrectly\");\n      }\n      graphicsPath = new GraphicsPath(d, true);\n      session.context.path(graphicsPath);\n      if (fillStyle) session.context.fill(fillStyle);\n      if (strokeStyle) session.context.stroke(strokeStyle);\n      break;\n    case \"circle\":\n      cx = parseSVGFloatAttribute(svg, \"cx\", 0);\n      cy = parseSVGFloatAttribute(svg, \"cy\", 0);\n      r = parseSVGFloatAttribute(svg, \"r\", 0);\n      session.context.ellipse(cx, cy, r, r);\n      if (fillStyle) session.context.fill(fillStyle);\n      if (strokeStyle) session.context.stroke(strokeStyle);\n      break;\n    case \"rect\":\n      x = parseSVGFloatAttribute(svg, \"x\", 0);\n      y = parseSVGFloatAttribute(svg, \"y\", 0);\n      width = parseSVGFloatAttribute(svg, \"width\", 0);\n      height = parseSVGFloatAttribute(svg, \"height\", 0);\n      rx = parseSVGFloatAttribute(svg, \"rx\", 0);\n      ry = parseSVGFloatAttribute(svg, \"ry\", 0);\n      if (rx || ry) {\n        session.context.roundRect(x, y, width, height, rx || ry);\n      } else {\n        session.context.rect(x, y, width, height);\n      }\n      if (fillStyle) session.context.fill(fillStyle);\n      if (strokeStyle) session.context.stroke(strokeStyle);\n      break;\n    case \"ellipse\":\n      cx = parseSVGFloatAttribute(svg, \"cx\", 0);\n      cy = parseSVGFloatAttribute(svg, \"cy\", 0);\n      rx = parseSVGFloatAttribute(svg, \"rx\", 0);\n      ry = parseSVGFloatAttribute(svg, \"ry\", 0);\n      session.context.beginPath();\n      session.context.ellipse(cx, cy, rx, ry);\n      if (fillStyle) session.context.fill(fillStyle);\n      if (strokeStyle) session.context.stroke(strokeStyle);\n      break;\n    case \"line\":\n      x1 = parseSVGFloatAttribute(svg, \"x1\", 0);\n      y1 = parseSVGFloatAttribute(svg, \"y1\", 0);\n      x2 = parseSVGFloatAttribute(svg, \"x2\", 0);\n      y2 = parseSVGFloatAttribute(svg, \"y2\", 0);\n      session.context.beginPath();\n      session.context.moveTo(x1, y1);\n      session.context.lineTo(x2, y2);\n      if (strokeStyle) session.context.stroke(strokeStyle);\n      break;\n    case \"polygon\":\n      pointsString = svg.getAttribute(\"points\");\n      points = pointsString.match(/\\d+/g).map(n => parseInt(n, 10));\n      session.context.poly(points, true);\n      if (fillStyle) session.context.fill(fillStyle);\n      if (strokeStyle) session.context.stroke(strokeStyle);\n      break;\n    case \"polyline\":\n      pointsString = svg.getAttribute(\"points\");\n      points = pointsString.match(/\\d+/g).map(n => parseInt(n, 10));\n      session.context.poly(points, false);\n      if (strokeStyle) session.context.stroke(strokeStyle);\n      break;\n    case \"g\":\n    case \"svg\":\n      break;\n    default:\n      {\n        warn(`[SVG parser] <${svg.nodeName}> elements unsupported`);\n        break;\n      }\n  }\n  if (noStyle) {\n    fillStyle = null;\n  }\n  for (let i = 0; i < children.length; i++) {\n    renderChildren(children[i], session, fillStyle, strokeStyle);\n  }\n}\nexport { SVGParser };","map":{"version":3,"names":["SVGParser","svg","graphicsContext","div","document","createElement","innerHTML","trim","querySelector","session","context","defs","path","GraphicsPath","parseSVGDefinitions","children","fillStyle","strokeStyle","parseSVGStyle","i","length","child","nodeName","toLowerCase","renderChildren","f1","s1","noStyle","color","x","y","x1","y1","x2","y2","cx","cy","r","rx","ry","points","pointsString","d","graphicsPath","width","height","getAttribute","warn","fill","stroke","parseSVGFloatAttribute","ellipse","roundRect","rect","beginPath","moveTo","lineTo","match","map","n","parseInt","poly"],"sources":["C:\\Users\\emalv\\OneDrive\\Desktop\\Portafolio\\cv-ciudad\\node_modules\\pixi.js\\src\\scene\\graphics\\shared\\svg\\SVGParser.ts"],"sourcesContent":["import { warn } from '../../../../utils/logging/warn';\nimport { GraphicsPath } from '../path/GraphicsPath';\nimport { parseSVGDefinitions } from './parseSVGDefinitions';\nimport { parseSVGFloatAttribute } from './parseSVGFloatAttribute';\nimport { parseSVGStyle } from './parseSVGStyle';\n\nimport type { FillGradient } from '../fill/FillGradient';\nimport type { FillStyle, StrokeStyle } from '../FillTypes';\nimport type {\n    GraphicsContext,\n} from '../GraphicsContext';\n\n/** Represents a session for SVG parsing. Contains the current state and resources needed during parsing. */\nexport interface Session\n{\n    /** The graphics context to render to */\n    context: GraphicsContext;\n    /** The current path being constructed */\n    path: GraphicsPath;\n    /** Map of definitions by id */\n    defs: Record<string, FillGradient>;\n}\n\n/**\n * Parses an SVG element or string and renders it to a graphics context.\n * Handles both SVG strings and SVG DOM elements as input.\n * @param svg - The SVG content to parse, either as a string or element\n * @param graphicsContext - Optional graphics context to render to\n * @returns The graphics context with the SVG rendered into it\n */\nexport function SVGParser(\n    svg: string | SVGElement | SVGSVGElement,\n    graphicsContext?: GraphicsContext\n): GraphicsContext\n{\n    // Convert string input to SVG element\n    if (typeof svg === 'string')\n    {\n        const div = document.createElement('div');\n\n        div.innerHTML = svg.trim();\n        svg = div.querySelector('svg') as SVGElement;\n    }\n\n    // Initialize parsing session\n    const session = {\n        context: graphicsContext,\n        defs: {},\n        path: new GraphicsPath(),\n    };\n\n    // Parse definitions (gradients, etc) first\n    parseSVGDefinitions(svg, session);\n\n    // Process all child elements except defs\n    const children = svg.children;\n\n    const { fillStyle, strokeStyle } = parseSVGStyle(svg, session);\n\n    for (let i = 0; i < children.length; i++)\n    {\n        const child = children[i] as SVGElement;\n\n        if (child.nodeName.toLowerCase() === 'defs') continue;\n        renderChildren(child, session, fillStyle, strokeStyle);\n    }\n\n    return graphicsContext;\n}\n\n/**\n * Recursively renders SVG elements and their children.\n * Handles styling inheritance and different SVG shape types.\n * @param svg - The SVG element to render\n * @param session - The current parsing session\n * @param fillStyle - The inherited fill style\n * @param strokeStyle - The inherited stroke style\n */\nfunction renderChildren(svg: SVGElement, session: Session, fillStyle: FillStyle, strokeStyle: StrokeStyle): void\n{\n    const children = svg.children;\n\n    // Parse element's style and merge with inherited styles\n    const { fillStyle: f1, strokeStyle: s1 } = parseSVGStyle(svg, session);\n\n    if (f1 && fillStyle)\n    {\n        fillStyle = { ...fillStyle, ...f1 };\n    }\n    else if (f1)\n    {\n        fillStyle = f1;\n    }\n\n    if (s1 && strokeStyle)\n    {\n        strokeStyle = { ...strokeStyle, ...s1 };\n    }\n    else if (s1)\n    {\n        strokeStyle = s1;\n    }\n\n    const noStyle = !fillStyle && !strokeStyle;\n\n    // Default to black fill if no styles specified\n    if (noStyle)\n    {\n        fillStyle = { color: 0 };\n    }\n\n    // Variables for shape attributes\n    let x;\n    let y;\n    let x1;\n    let y1;\n    let x2;\n    let y2;\n    let cx;\n    let cy;\n    let r;\n    let rx;\n    let ry;\n    let points;\n    let pointsString;\n    let d;\n    let graphicsPath;\n    let width;\n    let height;\n\n    // Handle different SVG element types\n    switch (svg.nodeName.toLowerCase())\n    {\n        case 'path':\n            d = svg.getAttribute('d') as string;\n\n            if (svg.getAttribute('fill-rule') as string === 'evenodd')\n            {\n                // #if _DEBUG\n                warn('SVG Evenodd fill rule not supported, your svg may render incorrectly');\n                // #endif\n            }\n\n            graphicsPath = new GraphicsPath(d, true);\n            session.context.path(graphicsPath);\n            if (fillStyle) session.context.fill(fillStyle);\n            if (strokeStyle) session.context.stroke(strokeStyle);\n            break;\n\n        case 'circle':\n            cx = parseSVGFloatAttribute(svg, 'cx', 0);\n            cy = parseSVGFloatAttribute(svg, 'cy', 0);\n            r = parseSVGFloatAttribute(svg, 'r', 0);\n            session.context.ellipse(cx, cy, r, r);\n            if (fillStyle) session.context.fill(fillStyle);\n            if (strokeStyle) session.context.stroke(strokeStyle);\n            break;\n\n        case 'rect':\n            x = parseSVGFloatAttribute(svg, 'x', 0);\n            y = parseSVGFloatAttribute(svg, 'y', 0);\n            width = parseSVGFloatAttribute(svg, 'width', 0);\n            height = parseSVGFloatAttribute(svg, 'height', 0);\n            rx = parseSVGFloatAttribute(svg, 'rx', 0);\n            ry = parseSVGFloatAttribute(svg, 'ry', 0);\n\n            if (rx || ry)\n            {\n                session.context.roundRect(x, y, width, height, rx || ry);\n            }\n            else\n            {\n                session.context.rect(x, y, width, height);\n            }\n\n            if (fillStyle) session.context.fill(fillStyle);\n            if (strokeStyle) session.context.stroke(strokeStyle);\n            break;\n\n        case 'ellipse':\n            cx = parseSVGFloatAttribute(svg, 'cx', 0);\n            cy = parseSVGFloatAttribute(svg, 'cy', 0);\n            rx = parseSVGFloatAttribute(svg, 'rx', 0);\n            ry = parseSVGFloatAttribute(svg, 'ry', 0);\n\n            session.context.beginPath();\n            session.context.ellipse(cx, cy, rx, ry);\n\n            if (fillStyle) session.context.fill(fillStyle);\n            if (strokeStyle) session.context.stroke(strokeStyle);\n            break;\n\n        case 'line':\n            x1 = parseSVGFloatAttribute(svg, 'x1', 0);\n            y1 = parseSVGFloatAttribute(svg, 'y1', 0);\n            x2 = parseSVGFloatAttribute(svg, 'x2', 0);\n            y2 = parseSVGFloatAttribute(svg, 'y2', 0);\n\n            session.context.beginPath();\n            session.context.moveTo(x1, y1);\n            session.context.lineTo(x2, y2);\n\n            if (strokeStyle) session.context.stroke(strokeStyle);\n            break;\n\n        case 'polygon':\n            pointsString = svg.getAttribute('points') as string;\n            points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n            session.context.poly(points, true);\n            if (fillStyle) session.context.fill(fillStyle);\n            if (strokeStyle) session.context.stroke(strokeStyle);\n            break;\n\n        case 'polyline':\n            pointsString = svg.getAttribute('points') as string;\n            points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n            session.context.poly(points, false);\n            if (strokeStyle) session.context.stroke(strokeStyle);\n            break;\n\n        // Group elements - just process children\n        case 'g':\n        case 'svg':\n            break;\n\n        default: {\n            // Log unsupported elements\n            warn(`[SVG parser] <${svg.nodeName}> elements unsupported`);\n            break;\n        }\n    }\n\n    if (noStyle)\n    {\n        fillStyle = null;\n    }\n\n    // Recursively process child elements\n    for (let i = 0; i < children.length; i++)\n    {\n        renderChildren(children[i] as SVGElement, session, fillStyle, strokeStyle);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}