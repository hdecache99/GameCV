{"ast":null,"code":"import { Bounds } from '../container/bounds/Bounds.mjs';\nimport { Container } from '../container/Container.mjs';\n\"use strict\";\nclass ViewContainer extends Container {\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(options) {\n    super(options);\n    /** @private */\n    this.canBundle = true;\n    /** @private */\n    this.allowChildren = false;\n    /** @private */\n    this._roundPixels = 0;\n    /** @private */\n    this._lastUsed = -1;\n    this._bounds = new Bounds(0, 1, 0, 0);\n    this._boundsDirty = true;\n  }\n  /**\n   * The local bounds of the view.\n   * @type {rendering.Bounds}\n   */\n  get bounds() {\n    if (!this._boundsDirty) return this._bounds;\n    this.updateBounds();\n    this._boundsDirty = false;\n    return this._bounds;\n  }\n  /**\n   * Whether or not to round the x/y position of the sprite.\n   * @type {boolean}\n   */\n  get roundPixels() {\n    return !!this._roundPixels;\n  }\n  set roundPixels(value) {\n    this._roundPixels = value ? 1 : 0;\n  }\n  /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */\n  containsPoint(point) {\n    const bounds = this.bounds;\n    const {\n      x,\n      y\n    } = point;\n    return x >= bounds.minX && x <= bounds.maxX && y >= bounds.minY && y <= bounds.maxY;\n  }\n  /** @private */\n  onViewUpdate() {\n    this._didViewChangeTick++;\n    this._boundsDirty = true;\n    if (this.didViewUpdate) return;\n    this.didViewUpdate = true;\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.onChildViewUpdate(this);\n    }\n  }\n  destroy(options) {\n    super.destroy(options);\n    this._bounds = null;\n  }\n  collectRenderablesSimple(instructionSet, renderer, currentLayer) {\n    const {\n      renderPipes,\n      renderableGC\n    } = renderer;\n    renderPipes.blendMode.setBlendMode(this, this.groupBlendMode, instructionSet);\n    const rp = renderPipes;\n    rp[this.renderPipeId].addRenderable(this, instructionSet);\n    renderableGC.addRenderable(this);\n    this.didViewUpdate = false;\n    const children = this.children;\n    const length = children.length;\n    for (let i = 0; i < length; i++) {\n      children[i].collectRenderables(instructionSet, renderer, currentLayer);\n    }\n  }\n}\nexport { ViewContainer };","map":{"version":3,"names":["ViewContainer","Container","constructor","options","canBundle","allowChildren","_roundPixels","_lastUsed","_bounds","Bounds","_boundsDirty","bounds","updateBounds","roundPixels","value","containsPoint","point","x","y","minX","maxX","minY","maxY","onViewUpdate","_didViewChangeTick","didViewUpdate","renderGroup","parentRenderGroup","onChildViewUpdate","destroy","collectRenderablesSimple","instructionSet","renderer","currentLayer","renderPipes","renderableGC","blendMode","setBlendMode","groupBlendMode","rp","renderPipeId","addRenderable","children","length","i","collectRenderables"],"sources":["C:\\Users\\emalv\\OneDrive\\Desktop\\Portafolio\\cv-ciudad\\node_modules\\pixi.js\\src\\scene\\view\\ViewContainer.ts"],"sourcesContent":["import { type InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport { type RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport { type Renderer } from '../../rendering/renderers/types';\nimport { Bounds } from '../container/bounds/Bounds';\nimport { Container, type ContainerOptions } from '../container/Container';\nimport { type IRenderLayer } from '../layers/RenderLayer';\n\nimport type { PointData } from '../../maths/point/PointData';\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { DestroyOptions } from '../container/destroyTypes';\n\nexport interface ViewContainerOptions extends ContainerOptions, PixiMixins.ViewContainerOptions {}\nexport interface ViewContainer extends PixiMixins.ViewContainer, Container {}\n\n/**\n * A ViewContainer is a type of container that represents a view.\n * This view can be a Sprite, a Graphics object, or any other object that can be rendered.\n * This class is abstract and should not be used directly.\n * @memberof scene\n */\nexport abstract class ViewContainer extends Container implements View\n{\n    /** @private */\n    public override readonly renderPipeId: string;\n    /** @private */\n    public readonly canBundle = true;\n    /** @private */\n    public override allowChildren = false;\n\n    /** @private */\n    public _roundPixels: 0 | 1 = 0;\n    /** @private */\n    public _lastUsed = -1;\n\n    protected _bounds: Bounds = new Bounds(0, 1, 0, 0);\n    protected _boundsDirty = true;\n\n    /**\n     * The local bounds of the view.\n     * @type {rendering.Bounds}\n     */\n    public get bounds()\n    {\n        if (!this._boundsDirty) return this._bounds;\n\n        this.updateBounds();\n\n        this._boundsDirty = false;\n\n        return this._bounds;\n    }\n\n    /** @private */\n    protected abstract updateBounds(): void;\n\n    /**\n     * Whether or not to round the x/y position of the sprite.\n     * @type {boolean}\n     */\n    get roundPixels()\n    {\n        return !!this._roundPixels;\n    }\n\n    set roundPixels(value: boolean)\n    {\n        this._roundPixels = value ? 1 : 0;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n    constructor(options: ViewContainerOptions)\n    {\n        super(options);\n    }\n\n    /**\n     * Checks if the object contains the given point.\n     * @param point - The point to check\n     */\n    public containsPoint(point: PointData)\n    {\n        const bounds = this.bounds;\n        const { x, y } = point;\n\n        return (x >= bounds.minX\n            && x <= bounds.maxX\n            && y >= bounds.minY\n            && y <= bounds.maxY);\n    }\n\n    /** @private */\n    public abstract batched: boolean;\n\n    /** @private */\n    protected onViewUpdate()\n    {\n        this._didViewChangeTick++;\n\n        this._boundsDirty = true;\n\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.onChildViewUpdate(this);\n        }\n    }\n\n    public override destroy(options?: DestroyOptions): void\n    {\n        super.destroy(options);\n\n        this._bounds = null;\n    }\n\n    public override collectRenderablesSimple(\n        instructionSet: InstructionSet,\n        renderer: Renderer,\n        currentLayer: IRenderLayer,\n    ): void\n    {\n        const { renderPipes, renderableGC } = renderer;\n\n        // TODO add blends in\n        renderPipes.blendMode.setBlendMode(this, this.groupBlendMode, instructionSet);\n\n        const rp = renderPipes as unknown as Record<string, RenderPipe>;\n\n        rp[this.renderPipeId].addRenderable(this, instructionSet);\n\n        renderableGC.addRenderable(this);\n\n        this.didViewUpdate = false;\n\n        const children = this.children;\n        const length = children.length;\n\n        for (let i = 0; i < length; i++)\n        {\n            children[i].collectRenderables(instructionSet, renderer, currentLayer);\n        }\n    }\n}\n"],"mappings":";;;AAoBO,MAAeA,aAAA,SAAsBC,SAC5C;EAAA;EAiDIC,YAAYC,OACZ;IACI,MAAMA,OAAO;IA/CjB;IAAA,KAAgBC,SAAY;IAE5B;IAAA,KAAgBC,aAAgB;IAGhC;IAAA,KAAOC,YAAsB;IAE7B;IAAA,KAAOC,SAAY;IAEnB,KAAUC,OAAA,GAAkB,IAAIC,MAAA,CAAO,CAAG,KAAG,GAAG,CAAC;IACjD,KAAUC,YAAe;EAAA;EAsCzB;AAAA;AAAA;AAAA;EAhCA,IAAWC,MACXA,CAAA;IACI,IAAI,CAAC,IAAK,CAAAD,YAAA,EAAc,OAAO,IAAK,CAAAF,OAAA;IAEpC,KAAKI,YAAa;IAElB,KAAKF,YAAe;IAEpB,OAAO,IAAK,CAAAF,OAAA;EAAA;EAChB;AAAA;AAAA;AAAA;EASA,IAAIK,WACJA,CAAA;IACW,QAAC,CAAC,IAAK,CAAAP,YAAA;EAAA;EAGlB,IAAIO,YAAYC,KAChB;IACS,KAAAR,YAAA,GAAeQ,KAAA,GAAQ,CAAI;EAAA;EACpC;AAAA;AAAA;AAAA;EAYOC,cAAcC,KACrB;IACI,MAAML,MAAA,GAAS,IAAK,CAAAA,MAAA;IACd;MAAEM,CAAG;MAAAC;IAAA,CAAM,GAAAF,KAAA;IAET,OAAAC,CAAA,IAAKN,MAAO,CAAAQ,IAAA,IACbF,CAAK,IAAAN,MAAA,CAAOS,IAAA,IACZF,CAAK,IAAAP,MAAA,CAAOU,IACZ,IAAAH,CAAA,IAAKP,MAAO,CAAAW,IAAA;EAAA;EACvB;EAMUC,YACVA,CAAA;IACS,KAAAC,kBAAA;IAEL,KAAKd,YAAe;IAEpB,IAAI,IAAK,CAAAe,aAAA,EAAe;IACxB,KAAKA,aAAgB;IAEf,MAAAC,WAAA,GAAc,IAAK,CAAAA,WAAA,IAAe,IAAK,CAAAC,iBAAA;IAE7C,IAAID,WACJ;MACIA,WAAA,CAAYE,iBAAA,CAAkB,IAAI;IAAA;EACtC;EAGYC,QAAQ1B,OACxB;IACI,MAAM0B,OAAA,CAAQ1B,OAAO;IAErB,KAAKK,OAAU;EAAA;EAGHsB,yBACZC,cACA,EAAAC,QAAA,EACAC,YAEJ;IACU;MAAEC,WAAa;MAAAC;IAAA,CAAiB,GAAAH,QAAA;IAGtCE,WAAA,CAAYE,SAAU,CAAAC,YAAA,CAAa,IAAM,OAAKC,cAAA,EAAgBP,cAAc;IAE5E,MAAMQ,EAAK,GAAAL,WAAA;IAEXK,EAAA,CAAG,IAAK,CAAAC,YAAY,CAAE,CAAAC,aAAA,CAAc,MAAMV,cAAc;IAExDI,YAAA,CAAaM,aAAA,CAAc,IAAI;IAE/B,KAAKhB,aAAgB;IAErB,MAAMiB,QAAA,GAAW,IAAK,CAAAA,QAAA;IACtB,MAAMC,MAAA,GAASD,QAAS,CAAAC,MAAA;IAExB,SAASC,CAAI,MAAGA,CAAI,GAAAD,MAAA,EAAQC,CAC5B;MACIF,QAAA,CAASE,CAAC,EAAEC,kBAAmB,CAAAd,cAAA,EAAgBC,QAAA,EAAUC,YAAY;IAAA;EACzE;AAER","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}