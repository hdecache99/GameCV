{"ast":null,"code":"import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { BindGroup } from '../../../rendering/renderers/gpu/shader/BindGroup.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { getAdjustedBlendModeBlend } from '../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs';\nimport { BigPool } from '../../../utils/pool/PoolGroup.mjs';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform.mjs';\nimport { BatchableMesh } from './BatchableMesh.mjs';\n\"use strict\";\nclass MeshPipe {\n  constructor(renderer, adaptor) {\n    this.localUniforms = new UniformGroup({\n      uTransformMatrix: {\n        value: new Matrix(),\n        type: \"mat3x3<f32>\"\n      },\n      uColor: {\n        value: new Float32Array([1, 1, 1, 1]),\n        type: \"vec4<f32>\"\n      },\n      uRound: {\n        value: 0,\n        type: \"f32\"\n      }\n    });\n    this.localUniformsBindGroup = new BindGroup({\n      0: this.localUniforms\n    });\n    this._meshDataHash = /* @__PURE__ */Object.create(null);\n    this._gpuBatchableMeshHash = /* @__PURE__ */Object.create(null);\n    this._destroyRenderableBound = this.destroyRenderable.bind(this);\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this._adaptor.init();\n    renderer.renderableGC.addManagedHash(this, \"_gpuBatchableMeshHash\");\n    renderer.renderableGC.addManagedHash(this, \"_meshDataHash\");\n  }\n  validateRenderable(mesh) {\n    const meshData = this._getMeshData(mesh);\n    const wasBatched = meshData.batched;\n    const isBatched = mesh.batched;\n    meshData.batched = isBatched;\n    if (wasBatched !== isBatched) {\n      return true;\n    } else if (isBatched) {\n      const geometry = mesh._geometry;\n      if (geometry.indices.length !== meshData.indexSize || geometry.positions.length !== meshData.vertexSize) {\n        meshData.indexSize = geometry.indices.length;\n        meshData.vertexSize = geometry.positions.length;\n        return true;\n      }\n      const batchableMesh = this._getBatchableMesh(mesh);\n      if (batchableMesh.texture.uid !== mesh._texture.uid) {\n        batchableMesh._textureMatrixUpdateId = -1;\n      }\n      return !batchableMesh._batcher.checkAndUpdateTexture(batchableMesh, mesh._texture);\n    }\n    return false;\n  }\n  addRenderable(mesh, instructionSet) {\n    const batcher = this.renderer.renderPipes.batch;\n    const {\n      batched\n    } = this._getMeshData(mesh);\n    if (batched) {\n      const gpuBatchableMesh = this._getBatchableMesh(mesh);\n      gpuBatchableMesh.setTexture(mesh._texture);\n      gpuBatchableMesh.geometry = mesh._geometry;\n      batcher.addToBatch(gpuBatchableMesh, instructionSet);\n    } else {\n      batcher.break(instructionSet);\n      instructionSet.add(mesh);\n    }\n  }\n  updateRenderable(mesh) {\n    if (mesh.batched) {\n      const gpuBatchableMesh = this._gpuBatchableMeshHash[mesh.uid];\n      gpuBatchableMesh.setTexture(mesh._texture);\n      gpuBatchableMesh.geometry = mesh._geometry;\n      gpuBatchableMesh._batcher.updateElement(gpuBatchableMesh);\n    }\n  }\n  destroyRenderable(mesh) {\n    this._meshDataHash[mesh.uid] = null;\n    const gpuMesh = this._gpuBatchableMeshHash[mesh.uid];\n    if (gpuMesh) {\n      BigPool.return(gpuMesh);\n      this._gpuBatchableMeshHash[mesh.uid] = null;\n    }\n    mesh.off(\"destroyed\", this._destroyRenderableBound);\n  }\n  execute(mesh) {\n    if (!mesh.isRenderable) return;\n    mesh.state.blendMode = getAdjustedBlendModeBlend(mesh.groupBlendMode, mesh.texture._source);\n    const localUniforms = this.localUniforms;\n    localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n    localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n    localUniforms.update();\n    color32BitToUniform(mesh.groupColorAlpha, localUniforms.uniforms.uColor, 0);\n    this._adaptor.execute(this, mesh);\n  }\n  _getMeshData(mesh) {\n    return this._meshDataHash[mesh.uid] || this._initMeshData(mesh);\n  }\n  _initMeshData(mesh) {\n    this._meshDataHash[mesh.uid] = {\n      batched: mesh.batched,\n      indexSize: mesh._geometry.indices?.length,\n      vertexSize: mesh._geometry.positions?.length\n    };\n    mesh.on(\"destroyed\", this._destroyRenderableBound);\n    return this._meshDataHash[mesh.uid];\n  }\n  _getBatchableMesh(mesh) {\n    return this._gpuBatchableMeshHash[mesh.uid] || this._initBatchableMesh(mesh);\n  }\n  _initBatchableMesh(mesh) {\n    const gpuMesh = BigPool.get(BatchableMesh);\n    gpuMesh.renderable = mesh;\n    gpuMesh.setTexture(mesh._texture);\n    gpuMesh.transform = mesh.groupTransform;\n    gpuMesh.roundPixels = this.renderer._roundPixels | mesh._roundPixels;\n    this._gpuBatchableMeshHash[mesh.uid] = gpuMesh;\n    return gpuMesh;\n  }\n  destroy() {\n    for (const i in this._gpuBatchableMeshHash) {\n      if (this._gpuBatchableMeshHash[i]) {\n        BigPool.return(this._gpuBatchableMeshHash[i]);\n      }\n    }\n    this._gpuBatchableMeshHash = null;\n    this._meshDataHash = null;\n    this.localUniforms = null;\n    this.localUniformsBindGroup = null;\n    this._adaptor.destroy();\n    this._adaptor = null;\n    this.renderer = null;\n  }\n}\n/** @ignore */\nMeshPipe.extension = {\n  type: [ExtensionType.WebGLPipes, ExtensionType.WebGPUPipes, ExtensionType.CanvasPipes],\n  name: \"mesh\"\n};\nexport { MeshPipe };","map":{"version":3,"names":["MeshPipe","constructor","renderer","adaptor","localUniforms","UniformGroup","uTransformMatrix","value","Matrix","type","uColor","Float32Array","uRound","localUniformsBindGroup","BindGroup","_meshDataHash","Object","create","_gpuBatchableMeshHash","_destroyRenderableBound","destroyRenderable","bind","_adaptor","init","renderableGC","addManagedHash","validateRenderable","mesh","meshData","_getMeshData","wasBatched","batched","isBatched","geometry","_geometry","indices","length","indexSize","positions","vertexSize","batchableMesh","_getBatchableMesh","texture","uid","_texture","_textureMatrixUpdateId","_batcher","checkAndUpdateTexture","addRenderable","instructionSet","batcher","renderPipes","batch","gpuBatchableMesh","setTexture","addToBatch","break","add","updateRenderable","updateElement","gpuMesh","BigPool","return","off","execute","isRenderable","state","blendMode","getAdjustedBlendModeBlend","groupBlendMode","_source","uniforms","groupTransform","_roundPixels","update","color32BitToUniform","groupColorAlpha","_initMeshData","on","_initBatchableMesh","get","BatchableMesh","renderable","transform","roundPixels","destroy","i","extension","ExtensionType","WebGLPipes","WebGPUPipes","CanvasPipes","name"],"sources":["C:\\Users\\emalv\\OneDrive\\Desktop\\Portafolio\\cv-ciudad\\node_modules\\pixi.js\\src\\scene\\mesh\\shared\\MeshPipe.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { BindGroup } from '../../../rendering/renderers/gpu/shader/BindGroup';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { getAdjustedBlendModeBlend } from '../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform';\nimport { BatchableMesh } from './BatchableMesh';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type {\n    InstructionPipe,\n    RenderPipe\n} from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Container } from '../../container/Container';\nimport type { Mesh } from './Mesh';\n\n// TODO Record mode is a P2, will get back to this as it's not a priority\n// const recordMode = true;\n\ninterface MeshData\n{\n    batched: boolean;\n    indexSize: number;\n    vertexSize: number;\n}\n\nexport interface MeshAdaptor\n{\n    init(): void;\n    execute(meshPipe: MeshPipe, mesh: Mesh): void;\n    destroy(): void;\n}\n\nexport class MeshPipe implements RenderPipe<Mesh>, InstructionPipe<Mesh>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'mesh',\n    } as const;\n\n    public localUniforms = new UniformGroup({\n        uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n        uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n        uRound: { value: 0, type: 'f32' },\n    });\n\n    public localUniformsBindGroup = new BindGroup({\n        0: this.localUniforms,\n    });\n\n    public renderer: Renderer;\n\n    private _meshDataHash: Record<number, MeshData> = Object.create(null);\n    private _gpuBatchableMeshHash: Record<number, BatchableMesh> = Object.create(null);\n    private _adaptor: MeshAdaptor;\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: Renderer, adaptor: MeshAdaptor)\n    {\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n\n        this._adaptor.init();\n\n        renderer.renderableGC.addManagedHash(this, '_gpuBatchableMeshHash');\n        renderer.renderableGC.addManagedHash(this, '_meshDataHash');\n    }\n\n    public validateRenderable(mesh: Mesh): boolean\n    {\n        const meshData = this._getMeshData(mesh);\n\n        const wasBatched = meshData.batched;\n\n        const isBatched = mesh.batched;\n\n        meshData.batched = isBatched;\n\n        if (wasBatched !== isBatched)\n        {\n            return true;\n        }\n        else if (isBatched)\n        {\n            const geometry = mesh._geometry;\n\n            // no need to break the batch if it's the same size\n            if (geometry.indices.length !== meshData.indexSize\n                    || geometry.positions.length !== meshData.vertexSize)\n            {\n                meshData.indexSize = geometry.indices.length;\n                meshData.vertexSize = geometry.positions.length;\n\n                return true;\n            }\n\n            const batchableMesh = this._getBatchableMesh(mesh);\n\n            if (batchableMesh.texture.uid !== mesh._texture.uid)\n            {\n                batchableMesh._textureMatrixUpdateId = -1;\n            }\n\n            return !batchableMesh._batcher.checkAndUpdateTexture(\n                batchableMesh,\n                mesh._texture\n            );\n        }\n\n        return false;\n    }\n\n    public addRenderable(mesh: Mesh, instructionSet: InstructionSet)\n    {\n        const batcher = this.renderer.renderPipes.batch;\n\n        const { batched } = this._getMeshData(mesh);\n\n        if (batched)\n        {\n            const gpuBatchableMesh = this._getBatchableMesh(mesh);\n\n            gpuBatchableMesh.setTexture(mesh._texture);\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            batcher.addToBatch(gpuBatchableMesh, instructionSet);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            instructionSet.add(mesh);\n        }\n    }\n\n    public updateRenderable(mesh: Mesh)\n    {\n        if (mesh.batched)\n        {\n            const gpuBatchableMesh = this._gpuBatchableMeshHash[mesh.uid];\n\n            gpuBatchableMesh.setTexture(mesh._texture);\n\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            gpuBatchableMesh._batcher.updateElement(gpuBatchableMesh);\n        }\n    }\n\n    public destroyRenderable(mesh: Mesh)\n    {\n        this._meshDataHash[mesh.uid] = null;\n\n        const gpuMesh = this._gpuBatchableMeshHash[mesh.uid];\n\n        if (gpuMesh)\n        {\n            BigPool.return(gpuMesh as PoolItem);\n            this._gpuBatchableMeshHash[mesh.uid] = null;\n        }\n\n        mesh.off('destroyed', this._destroyRenderableBound);\n    }\n\n    public execute(mesh: Mesh)\n    {\n        if (!mesh.isRenderable) return;\n\n        mesh.state.blendMode = getAdjustedBlendModeBlend(mesh.groupBlendMode, mesh.texture._source);\n\n        const localUniforms = this.localUniforms;\n\n        localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n        localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n        localUniforms.update();\n\n        color32BitToUniform(\n            mesh.groupColorAlpha,\n            localUniforms.uniforms.uColor,\n            0\n        );\n\n        this._adaptor.execute(this, mesh);\n    }\n\n    private _getMeshData(mesh: Mesh): MeshData\n    {\n        return this._meshDataHash[mesh.uid] || this._initMeshData(mesh);\n    }\n\n    private _initMeshData(mesh: Mesh): MeshData\n    {\n        this._meshDataHash[mesh.uid] = {\n            batched: mesh.batched,\n            indexSize: mesh._geometry.indices?.length,\n            vertexSize: mesh._geometry.positions?.length,\n        };\n\n        mesh.on('destroyed', this._destroyRenderableBound);\n\n        return this._meshDataHash[mesh.uid];\n    }\n\n    private _getBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        return this._gpuBatchableMeshHash[mesh.uid] || this._initBatchableMesh(mesh);\n    }\n\n    private _initBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        // TODO - make this batchable graphics??\n        const gpuMesh: BatchableMesh = BigPool.get(BatchableMesh);\n\n        gpuMesh.renderable = mesh;\n        gpuMesh.setTexture(mesh._texture);\n        gpuMesh.transform = mesh.groupTransform;\n        gpuMesh.roundPixels = (this.renderer._roundPixels | mesh._roundPixels) as 0 | 1;\n\n        this._gpuBatchableMeshHash[mesh.uid] = gpuMesh;\n\n        return gpuMesh;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuBatchableMeshHash)\n        {\n            if (this._gpuBatchableMeshHash[i])\n            {\n                BigPool.return(this._gpuBatchableMeshHash[i] as PoolItem);\n            }\n        }\n\n        this._gpuBatchableMeshHash = null;\n        this._meshDataHash = null;\n\n        this.localUniforms = null;\n        this.localUniformsBindGroup = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n\n        this.renderer = null;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}