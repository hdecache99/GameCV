{"ast":null,"code":"import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { State } from '../../renderers/shared/state/State.mjs';\n\"use strict\";\nclass GlBatchAdaptor {\n  constructor() {\n    this._tempState = State.for2d();\n    /**\n     * We only want to sync the a batched shaders uniforms once on first use\n     * this is a hash of shader uids to a boolean value.  When the shader is first bound\n     * we set the value to true.  When the shader is bound again we check the value and\n     * if it is true we know that the uniforms have already been synced and we skip it.\n     */\n    this._didUploadHash = {};\n  }\n  init(batcherPipe) {\n    batcherPipe.renderer.runners.contextChange.add(this);\n  }\n  contextChange() {\n    this._didUploadHash = {};\n  }\n  start(batchPipe, geometry, shader) {\n    const renderer = batchPipe.renderer;\n    const didUpload = this._didUploadHash[shader.uid];\n    renderer.shader.bind(shader, didUpload);\n    if (!didUpload) {\n      this._didUploadHash[shader.uid] = true;\n    }\n    renderer.shader.updateUniformGroup(renderer.globalUniforms.uniformGroup);\n    renderer.geometry.bind(geometry, shader.glProgram);\n  }\n  execute(batchPipe, batch) {\n    const renderer = batchPipe.renderer;\n    this._tempState.blendMode = batch.blendMode;\n    renderer.state.set(this._tempState);\n    const textures = batch.textures.textures;\n    for (let i = 0; i < batch.textures.count; i++) {\n      renderer.texture.bind(textures[i], i);\n    }\n    renderer.geometry.draw(batch.topology, batch.size, batch.start);\n  }\n}\n/** @ignore */\nGlBatchAdaptor.extension = {\n  type: [ExtensionType.WebGLPipesAdaptor],\n  name: \"batch\"\n};\nexport { GlBatchAdaptor };","map":{"version":3,"names":["GlBatchAdaptor","constructor","_tempState","State","for2d","_didUploadHash","init","batcherPipe","renderer","runners","contextChange","add","start","batchPipe","geometry","shader","didUpload","uid","bind","updateUniformGroup","globalUniforms","uniformGroup","glProgram","execute","batch","blendMode","state","set","textures","i","count","texture","draw","topology","size","extension","type","ExtensionType","WebGLPipesAdaptor","name"],"sources":["C:\\Users\\emalv\\OneDrive\\Desktop\\Portafolio\\cv-ciudad\\node_modules\\pixi.js\\src\\rendering\\batcher\\gl\\GlBatchAdaptor.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../renderers/shared/state/State';\n\nimport type { WebGLRenderer } from '../../renderers/gl/WebGLRenderer';\nimport type { Geometry } from '../../renderers/shared/geometry/Geometry';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { Batch } from '../shared/Batcher';\nimport type { BatcherAdaptor, BatcherPipe } from '../shared/BatcherPipe';\n\n/**\n * A BatcherAdaptor that uses WebGL to render batches.\n * @memberof rendering\n * @ignore\n */\nexport class GlBatchAdaptor implements BatcherAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipesAdaptor,\n        ],\n        name: 'batch',\n    } as const;\n\n    private readonly _tempState = State.for2d();\n\n    /**\n     * We only want to sync the a batched shaders uniforms once on first use\n     * this is a hash of shader uids to a boolean value.  When the shader is first bound\n     * we set the value to true.  When the shader is bound again we check the value and\n     * if it is true we know that the uniforms have already been synced and we skip it.\n     */\n    private _didUploadHash: Record<string, boolean> = {};\n    public init(batcherPipe: BatcherPipe): void\n    {\n        batcherPipe.renderer.runners.contextChange.add(this);\n    }\n\n    public contextChange(): void\n    {\n        this._didUploadHash = {};\n    }\n\n    public start(batchPipe: BatcherPipe, geometry: Geometry, shader: Shader): void\n    {\n        const renderer = batchPipe.renderer as WebGLRenderer;\n\n        const didUpload = this._didUploadHash[shader.uid];\n\n        // only want to sync the shade ron its first bind!\n        renderer.shader.bind(shader, didUpload);\n\n        if (!didUpload)\n        {\n            this._didUploadHash[shader.uid] = true;\n        }\n\n        renderer.shader.updateUniformGroup(renderer.globalUniforms.uniformGroup);\n\n        renderer.geometry.bind(geometry, shader.glProgram);\n    }\n\n    public execute(batchPipe: BatcherPipe, batch: Batch): void\n    {\n        const renderer = batchPipe.renderer as WebGLRenderer;\n\n        this._tempState.blendMode = batch.blendMode;\n\n        renderer.state.set(this._tempState);\n\n        const textures = batch.textures.textures;\n\n        for (let i = 0; i < batch.textures.count; i++)\n        {\n            renderer.texture.bind(textures[i], i);\n        }\n\n        renderer.geometry.draw(batch.topology, batch.size, batch.start);\n    }\n}\n"],"mappings":";;;AAcO,MAAMA,cACb;EADOC,YAAA;IAUc,KAAAC,UAAA,GAAaC,KAAA,CAAMC,KAAM;IAQ1C;AAAA;AAAA;AAAA;AAAA;AAAA;IAAA,KAAQC,cAAA,GAA0C,EAAC;EAAA;EAC5CC,KAAKC,WACZ;IACIA,WAAA,CAAYC,QAAS,CAAAC,OAAA,CAAQC,aAAc,CAAAC,GAAA,CAAI,IAAI;EAAA;EAGhDD,aACPA,CAAA;IACI,KAAKL,cAAA,GAAiB,EAAC;EAAA;EAGpBO,MAAMC,SAAwB,EAAAC,QAAA,EAAoBC,MACzD;IACI,MAAMP,QAAA,GAAWK,SAAU,CAAAL,QAAA;IAE3B,MAAMQ,SAAY,QAAKX,cAAe,CAAAU,MAAA,CAAOE,GAAG;IAGvCT,QAAA,CAAAO,MAAA,CAAOG,IAAK,CAAAH,MAAA,EAAQC,SAAS;IAEtC,IAAI,CAACA,SACL;MACS,KAAAX,cAAA,CAAeU,MAAO,CAAAE,GAAG,CAAI;IAAA;IAGtCT,QAAA,CAASO,MAAO,CAAAI,kBAAA,CAAmBX,QAAS,CAAAY,cAAA,CAAeC,YAAY;IAEvEb,QAAA,CAASM,QAAS,CAAAI,IAAA,CAAKJ,QAAU,EAAAC,MAAA,CAAOO,SAAS;EAAA;EAG9CC,QAAQV,SAAA,EAAwBW,KACvC;IACI,MAAMhB,QAAA,GAAWK,SAAU,CAAAL,QAAA;IAEtB,KAAAN,UAAA,CAAWuB,SAAA,GAAYD,KAAM,CAAAC,SAAA;IAEzBjB,QAAA,CAAAkB,KAAA,CAAMC,GAAI,MAAKzB,UAAU;IAE5B,MAAA0B,QAAA,GAAWJ,KAAA,CAAMI,QAAS,CAAAA,QAAA;IAEhC,SAASC,CAAA,GAAI,CAAG,EAAAA,CAAA,GAAIL,KAAM,CAAAI,QAAA,CAASE,KAAA,EAAOD,CAC1C;MACIrB,QAAA,CAASuB,OAAQ,CAAAb,IAAA,CAAKU,QAAS,CAAAC,CAAC,GAAGA,CAAC;IAAA;IAGxCrB,QAAA,CAASM,QAAA,CAASkB,IAAK,CAAAR,KAAA,CAAMS,QAAA,EAAUT,KAAM,CAAAU,IAAA,EAAMV,KAAA,CAAMZ,KAAK;EAAA;AAEtE;AAAA;AAjEaZ,cAAA,CAGKmC,SAAY;EACtBC,IAAM,GACFC,aAAc,CAAAC,iBAAA,CAClB;EACAC,IAAM;AACV","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}