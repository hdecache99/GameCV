{"ast":null,"code":"import { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { FillGradient } from '../fill/FillGradient.mjs';\n\"use strict\";\nconst tempTextureMatrix = new Matrix();\nconst tempRect = new Rectangle();\nfunction generateTextureMatrix(out, style, shape, matrix) {\n  const textureMatrix = style.matrix ? out.copyFrom(style.matrix).invert() : out.identity();\n  if (style.textureSpace === \"local\") {\n    const bounds = shape.getBounds(tempRect);\n    if (style.width) {\n      bounds.pad(style.width);\n    }\n    const {\n      x: tx,\n      y: ty\n    } = bounds;\n    const sx = 1 / bounds.width;\n    const sy = 1 / bounds.height;\n    const mTx = -tx * sx;\n    const mTy = -ty * sy;\n    const a1 = textureMatrix.a;\n    const b1 = textureMatrix.b;\n    const c1 = textureMatrix.c;\n    const d1 = textureMatrix.d;\n    textureMatrix.a *= sx;\n    textureMatrix.b *= sx;\n    textureMatrix.c *= sy;\n    textureMatrix.d *= sy;\n    textureMatrix.tx = mTx * a1 + mTy * c1 + textureMatrix.tx;\n    textureMatrix.ty = mTx * b1 + mTy * d1 + textureMatrix.ty;\n  } else {\n    textureMatrix.translate(style.texture.frame.x, style.texture.frame.y);\n    textureMatrix.scale(1 / style.texture.source.width, 1 / style.texture.source.height);\n  }\n  const sourceStyle = style.texture.source.style;\n  if (!(style.fill instanceof FillGradient) && sourceStyle.addressMode === \"clamp-to-edge\") {\n    sourceStyle.addressMode = \"repeat\";\n    sourceStyle.update();\n  }\n  if (matrix) {\n    textureMatrix.append(tempTextureMatrix.copyFrom(matrix).invert());\n  }\n  return textureMatrix;\n}\nexport { generateTextureMatrix };","map":{"version":3,"names":["tempTextureMatrix","Matrix","tempRect","Rectangle","generateTextureMatrix","out","style","shape","matrix","textureMatrix","copyFrom","invert","identity","textureSpace","bounds","getBounds","width","pad","x","tx","y","ty","sx","sy","height","mTx","mTy","a1","a","b1","b","c1","c","d1","d","translate","texture","frame","scale","source","sourceStyle","fill","FillGradient","addressMode","update","append"],"sources":["C:\\Users\\emalv\\OneDrive\\Desktop\\Portafolio\\cv-ciudad\\node_modules\\pixi.js\\src\\scene\\graphics\\shared\\utils\\generateTextureFillMatrix.ts"],"sourcesContent":["import { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { FillGradient } from '../fill/FillGradient';\n\nimport type { ShapePrimitive } from '../../../../maths/shapes/ShapePrimitive';\nimport type { FillStyle, StrokeStyle } from '../FillTypes';\n\n/**\n * Temporary matrix used for matrix calculations\n * @internal\n */\nconst tempTextureMatrix = new Matrix();\n\n/**\n * Temporary rectangle used for bounds calculations\n * @internal\n */\nconst tempRect = new Rectangle();\n\n/**\n * Generates a texture matrix for mapping textures onto shapes.\n * This function handles both local and global texture space mapping.\n *\n * In local space, the texture is mapped to fit exactly within the bounds of the shape.\n * In global space, the texture is mapped using its own dimensions and position.\n * @param out - The matrix to store the result in\n * @param style - The fill style containing texture and mapping properties\n * @param shape - The shape to map the texture onto\n * @param matrix - Optional transform matrix to apply\n * @returns The generated texture matrix for UV mapping\n * @example\n * ```ts\n * const matrix = new Matrix();\n * const textureMatrix = generateTextureMatrix(matrix, fillStyle, shape);\n * // textureMatrix now contains the proper UV mapping for the texture\n * ```\n */\nexport function generateTextureMatrix(out: Matrix, style: FillStyle | StrokeStyle, shape: ShapePrimitive, matrix?: Matrix)\n{\n    // Start with either the style's matrix inverted, or identity matrix\n    const textureMatrix = style.matrix\n        ? out.copyFrom(style.matrix).invert()\n        : out.identity();\n\n    if (style.textureSpace === 'local')\n    {\n        // For local space, map texture to shape's bounds\n        const bounds = shape.getBounds(tempRect);\n\n        if ((style as StrokeStyle).width)\n        {\n            bounds.pad((style as StrokeStyle).width);\n        }\n\n        const { x: tx, y: ty } = bounds;\n        const sx = 1 / bounds.width;\n        const sy = 1 / bounds.height;\n\n        const mTx = -tx * sx;\n        const mTy = -ty * sy;\n\n        const a1 = textureMatrix.a;\n        const b1 = textureMatrix.b;\n        const c1 = textureMatrix.c;\n        const d1 = textureMatrix.d;\n\n        textureMatrix.a *= sx;\n        textureMatrix.b *= sx;\n        textureMatrix.c *= sy;\n        textureMatrix.d *= sy;\n\n        textureMatrix.tx = (mTx * a1) + (mTy * c1) + textureMatrix.tx;\n        textureMatrix.ty = (mTx * b1) + (mTy * d1) + textureMatrix.ty;\n    }\n    else\n    {\n        // For global space, use texture's own dimensions\n        textureMatrix.translate(style.texture.frame.x, style.texture.frame.y);\n        textureMatrix.scale(1 / (style.texture.source.width), 1 / (style.texture.source.height));\n    }\n\n    const sourceStyle = style.texture.source.style;\n\n    // we don't want to set the address mode if the fill is a gradient as this handles its own address mode\n    if (!(style.fill instanceof FillGradient) && sourceStyle.addressMode === 'clamp-to-edge')\n    {\n        sourceStyle.addressMode = 'repeat';\n        sourceStyle.update();\n    }\n\n    // Apply any additional transform matrix\n    if (matrix)\n    {\n        textureMatrix.append(tempTextureMatrix.copyFrom(matrix).invert());\n    }\n\n    return textureMatrix;\n}\n"],"mappings":";;;;AAWA,MAAMA,iBAAA,GAAoB,IAAIC,MAAO;AAMrC,MAAMC,QAAA,GAAW,IAAIC,SAAU;AAoBxB,SAASC,qBAAsBA,CAAAC,GAAA,EAAaC,KAAgC,EAAAC,KAAA,EAAuBC,MAC1G;EAEU,MAAAC,aAAA,GAAgBH,KAAM,CAAAE,MAAA,GACtBH,GAAI,CAAAK,QAAA,CAASJ,KAAM,CAAAE,MAAM,CAAE,CAAAG,MAAA,EAC3B,GAAAN,GAAA,CAAIO,QAAS;EAEf,IAAAN,KAAA,CAAMO,YAAA,KAAiB,OAC3B;IAEU,MAAAC,MAAA,GAASP,KAAM,CAAAQ,SAAA,CAAUb,QAAQ;IAEvC,IAAKI,KAAA,CAAsBU,KAC3B;MACWF,MAAA,CAAAG,GAAA,CAAKX,KAAA,CAAsBU,KAAK;IAAA;IAG3C,MAAM;MAAEE,CAAA,EAAGC,EAAI;MAAAC,CAAA,EAAGC;IAAA,CAAO,GAAAP,MAAA;IACnB,MAAAQ,EAAA,GAAK,IAAIR,MAAO,CAAAE,KAAA;IAChB,MAAAO,EAAA,GAAK,IAAIT,MAAO,CAAAU,MAAA;IAEhB,MAAAC,GAAA,GAAM,CAACN,EAAK,GAAAG,EAAA;IACZ,MAAAI,GAAA,GAAM,CAACL,EAAK,GAAAE,EAAA;IAElB,MAAMI,EAAA,GAAKlB,aAAc,CAAAmB,CAAA;IACzB,MAAMC,EAAA,GAAKpB,aAAc,CAAAqB,CAAA;IACzB,MAAMC,EAAA,GAAKtB,aAAc,CAAAuB,CAAA;IACzB,MAAMC,EAAA,GAAKxB,aAAc,CAAAyB,CAAA;IAEzBzB,aAAA,CAAcmB,CAAK,IAAAN,EAAA;IACnBb,aAAA,CAAcqB,CAAK,IAAAR,EAAA;IACnBb,aAAA,CAAcuB,CAAK,IAAAT,EAAA;IACnBd,aAAA,CAAcyB,CAAK,IAAAX,EAAA;IAEnBd,aAAA,CAAcU,EAAM,GAAAM,GAAA,GAAME,EAAO,GAAAD,GAAA,GAAMK,EAAA,GAAMtB,aAAc,CAAAU,EAAA;IAC3DV,aAAA,CAAcY,EAAM,GAAAI,GAAA,GAAMI,EAAO,GAAAH,GAAA,GAAMO,EAAA,GAAMxB,aAAc,CAAAY,EAAA;EAAA,CAG/D;IAEkBZ,aAAA,CAAA0B,SAAA,CAAU7B,KAAA,CAAM8B,OAAQ,CAAAC,KAAA,CAAMnB,CAAA,EAAGZ,KAAM,CAAA8B,OAAA,CAAQC,KAAA,CAAMjB,CAAC;IACtDX,aAAA,CAAA6B,KAAA,CAAM,CAAK,GAAAhC,KAAA,CAAM8B,OAAQ,CAAAG,MAAA,CAAOvB,KAAA,EAAQ,CAAK,GAAAV,KAAA,CAAM8B,OAAQ,CAAAG,MAAA,CAAOf,MAAO;EAAA;EAGrF,MAAAgB,WAAA,GAAclC,KAAM,CAAA8B,OAAA,CAAQG,MAAO,CAAAjC,KAAA;EAGzC,IAAI,EAAEA,KAAM,CAAAmC,IAAA,YAAgBC,YAAiB,KAAAF,WAAA,CAAYG,WAAA,KAAgB,eACzE;IACIH,WAAA,CAAYG,WAAc;IAC1BH,WAAA,CAAYI,MAAO;EAAA;EAIvB,IAAIpC,MACJ;IACIC,aAAA,CAAcoC,MAAA,CAAO7C,iBAAkB,CAAAU,QAAA,CAASF,MAAM,EAAEG,MAAA,EAAQ;EAAA;EAG7D,OAAAF,aAAA;AACX","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}