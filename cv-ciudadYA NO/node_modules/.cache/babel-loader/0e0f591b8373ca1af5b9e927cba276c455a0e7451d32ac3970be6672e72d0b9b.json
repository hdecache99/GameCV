{"ast":null,"code":"import { Texture } from '../../rendering/renderers/shared/texture/Texture.mjs';\nimport { UPDATE_PRIORITY } from '../../ticker/const.mjs';\nimport { Ticker } from '../../ticker/Ticker.mjs';\nimport { Sprite } from '../sprite/Sprite.mjs';\n\"use strict\";\nclass AnimatedSprite extends Sprite {\n  /** @ignore */\n  constructor(...args) {\n    let options = args[0];\n    if (Array.isArray(args[0])) {\n      options = {\n        textures: args[0],\n        autoUpdate: args[1]\n      };\n    }\n    const {\n      animationSpeed = 1,\n      autoPlay = false,\n      autoUpdate = true,\n      loop = true,\n      onComplete = null,\n      onFrameChange = null,\n      onLoop = null,\n      textures,\n      updateAnchor = false,\n      ...rest\n    } = options;\n    const [firstFrame] = textures;\n    super({\n      ...rest,\n      texture: firstFrame instanceof Texture ? firstFrame : firstFrame.texture\n    });\n    this._textures = null;\n    this._durations = null;\n    this._autoUpdate = autoUpdate;\n    this._isConnectedToTicker = false;\n    this.animationSpeed = animationSpeed;\n    this.loop = loop;\n    this.updateAnchor = updateAnchor;\n    this.onComplete = onComplete;\n    this.onFrameChange = onFrameChange;\n    this.onLoop = onLoop;\n    this._currentTime = 0;\n    this._playing = false;\n    this._previousFrame = null;\n    this.textures = textures;\n    if (autoPlay) {\n      this.play();\n    }\n  }\n  /** Stops the AnimatedSprite. */\n  stop() {\n    if (!this._playing) {\n      return;\n    }\n    this._playing = false;\n    if (this._autoUpdate && this._isConnectedToTicker) {\n      Ticker.shared.remove(this.update, this);\n      this._isConnectedToTicker = false;\n    }\n  }\n  /** Plays the AnimatedSprite. */\n  play() {\n    if (this._playing) {\n      return;\n    }\n    this._playing = true;\n    if (this._autoUpdate && !this._isConnectedToTicker) {\n      Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH);\n      this._isConnectedToTicker = true;\n    }\n  }\n  /**\n   * Stops the AnimatedSprite and goes to a specific frame.\n   * @param frameNumber - Frame index to stop at.\n   */\n  gotoAndStop(frameNumber) {\n    this.stop();\n    this.currentFrame = frameNumber;\n  }\n  /**\n   * Goes to a specific frame and begins playing the AnimatedSprite.\n   * @param frameNumber - Frame index to start at.\n   */\n  gotoAndPlay(frameNumber) {\n    this.currentFrame = frameNumber;\n    this.play();\n  }\n  /**\n   * Updates the object transform for rendering.\n   * @param ticker - the ticker to use to update the object.\n   */\n  update(ticker) {\n    if (!this._playing) {\n      return;\n    }\n    const deltaTime = ticker.deltaTime;\n    const elapsed = this.animationSpeed * deltaTime;\n    const previousFrame = this.currentFrame;\n    if (this._durations !== null) {\n      let lag = this._currentTime % 1 * this._durations[this.currentFrame];\n      lag += elapsed / 60 * 1e3;\n      while (lag < 0) {\n        this._currentTime--;\n        lag += this._durations[this.currentFrame];\n      }\n      const sign = Math.sign(this.animationSpeed * deltaTime);\n      this._currentTime = Math.floor(this._currentTime);\n      while (lag >= this._durations[this.currentFrame]) {\n        lag -= this._durations[this.currentFrame] * sign;\n        this._currentTime += sign;\n      }\n      this._currentTime += lag / this._durations[this.currentFrame];\n    } else {\n      this._currentTime += elapsed;\n    }\n    if (this._currentTime < 0 && !this.loop) {\n      this.gotoAndStop(0);\n      if (this.onComplete) {\n        this.onComplete();\n      }\n    } else if (this._currentTime >= this._textures.length && !this.loop) {\n      this.gotoAndStop(this._textures.length - 1);\n      if (this.onComplete) {\n        this.onComplete();\n      }\n    } else if (previousFrame !== this.currentFrame) {\n      if (this.loop && this.onLoop) {\n        if (this.animationSpeed > 0 && this.currentFrame < previousFrame || this.animationSpeed < 0 && this.currentFrame > previousFrame) {\n          this.onLoop();\n        }\n      }\n      this._updateTexture();\n    }\n  }\n  /** Updates the displayed texture to match the current frame index. */\n  _updateTexture() {\n    const currentFrame = this.currentFrame;\n    if (this._previousFrame === currentFrame) {\n      return;\n    }\n    this._previousFrame = currentFrame;\n    this.texture = this._textures[currentFrame];\n    if (this.updateAnchor && this.texture.defaultAnchor) {\n      this.anchor.copyFrom(this.texture.defaultAnchor);\n    }\n    if (this.onFrameChange) {\n      this.onFrameChange(this.currentFrame);\n    }\n  }\n  /** Stops the AnimatedSprite and destroys it. */\n  destroy() {\n    this.stop();\n    super.destroy();\n    this.onComplete = null;\n    this.onFrameChange = null;\n    this.onLoop = null;\n  }\n  /**\n   * A short hand way of creating an AnimatedSprite from an array of frame ids.\n   * @param frames - The array of frames ids the AnimatedSprite will use as its texture frames.\n   * @returns - The new animated sprite with the specified frames.\n   */\n  static fromFrames(frames) {\n    const textures = [];\n    for (let i = 0; i < frames.length; ++i) {\n      textures.push(Texture.from(frames[i]));\n    }\n    return new AnimatedSprite(textures);\n  }\n  /**\n   * A short hand way of creating an AnimatedSprite from an array of image ids.\n   * @param images - The array of image urls the AnimatedSprite will use as its texture frames.\n   * @returns The new animate sprite with the specified images as frames.\n   */\n  static fromImages(images) {\n    const textures = [];\n    for (let i = 0; i < images.length; ++i) {\n      textures.push(Texture.from(images[i]));\n    }\n    return new AnimatedSprite(textures);\n  }\n  /**\n   * The total number of frames in the AnimatedSprite. This is the same as number of textures\n   * assigned to the AnimatedSprite.\n   * @readonly\n   * @default 0\n   */\n  get totalFrames() {\n    return this._textures.length;\n  }\n  /** The array of textures used for this AnimatedSprite. */\n  get textures() {\n    return this._textures;\n  }\n  set textures(value) {\n    if (value[0] instanceof Texture) {\n      this._textures = value;\n      this._durations = null;\n    } else {\n      this._textures = [];\n      this._durations = [];\n      for (let i = 0; i < value.length; i++) {\n        this._textures.push(value[i].texture);\n        this._durations.push(value[i].time);\n      }\n    }\n    this._previousFrame = null;\n    this.gotoAndStop(0);\n    this._updateTexture();\n  }\n  /** The AnimatedSprite's current frame index. */\n  get currentFrame() {\n    let currentFrame = Math.floor(this._currentTime) % this._textures.length;\n    if (currentFrame < 0) {\n      currentFrame += this._textures.length;\n    }\n    return currentFrame;\n  }\n  set currentFrame(value) {\n    if (value < 0 || value > this.totalFrames - 1) {\n      throw new Error(`[AnimatedSprite]: Invalid frame index value ${value}, expected to be between 0 and totalFrames ${this.totalFrames}.`);\n    }\n    const previousFrame = this.currentFrame;\n    this._currentTime = value;\n    if (previousFrame !== this.currentFrame) {\n      this._updateTexture();\n    }\n  }\n  /**\n   * Indicates if the AnimatedSprite is currently playing.\n   * @readonly\n   */\n  get playing() {\n    return this._playing;\n  }\n  /** Whether to use Ticker.shared to auto update animation time. */\n  get autoUpdate() {\n    return this._autoUpdate;\n  }\n  set autoUpdate(value) {\n    if (value !== this._autoUpdate) {\n      this._autoUpdate = value;\n      if (!this._autoUpdate && this._isConnectedToTicker) {\n        Ticker.shared.remove(this.update, this);\n        this._isConnectedToTicker = false;\n      } else if (this._autoUpdate && !this._isConnectedToTicker && this._playing) {\n        Ticker.shared.add(this.update, this);\n        this._isConnectedToTicker = true;\n      }\n    }\n  }\n}\nexport { AnimatedSprite };","map":{"version":3,"names":["AnimatedSprite","Sprite","constructor","args","options","Array","isArray","textures","autoUpdate","animationSpeed","autoPlay","loop","onComplete","onFrameChange","onLoop","updateAnchor","rest","firstFrame","texture","Texture","_textures","_durations","_autoUpdate","_isConnectedToTicker","_currentTime","_playing","_previousFrame","play","stop","Ticker","shared","remove","update","add","UPDATE_PRIORITY","HIGH","gotoAndStop","frameNumber","currentFrame","gotoAndPlay","ticker","deltaTime","elapsed","previousFrame","lag","sign","Math","floor","length","_updateTexture","defaultAnchor","anchor","copyFrom","destroy","fromFrames","frames","i","push","from","fromImages","images","totalFrames","value","time","Error","playing"],"sources":["C:\\Users\\emalv\\OneDrive\\Desktop\\Portafolio\\cv-ciudad\\node_modules\\pixi.js\\src\\scene\\sprite-animated\\AnimatedSprite.ts"],"sourcesContent":["import { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { UPDATE_PRIORITY } from '../../ticker/const';\nimport { Ticker } from '../../ticker/Ticker';\nimport { Sprite } from '../sprite/Sprite';\n\nimport type { SpriteOptions } from '../sprite/Sprite';\n\nexport type AnimatedSpriteFrames = Texture[] | FrameObject[];\n\n/**\n * Constructor options used for `AnimatedSprite` instances.\n * @see {@link scene.AnimatedSprite}\n * @memberof scene\n */\nexport interface AnimatedSpriteOptions extends PixiMixins.AnimatedSpriteOptions, Omit<SpriteOptions, 'texture'>\n{\n    /** The speed that the AnimatedSprite will play at. Higher is faster, lower is slower. */\n    animationSpeed?: number;\n    /** Whether to start the animation immediately on creation. */\n    autoPlay?: boolean;\n    /** Whether to use Ticker.shared to auto update animation time. */\n    autoUpdate?: boolean;\n    /** Whether or not the animate sprite repeats after playing. */\n    loop?: boolean;\n    /** User-assigned function to call when an AnimatedSprite finishes playing. */\n    onComplete?: () => void;\n    /** User-assigned function to call when an AnimatedSprite changes which texture is being rendered. */\n    onFrameChange?: (currentFrame: number) => void;\n    /**\n     * User-assigned function to call when `loop` is true, and an AnimatedSprite is played and loops around to start again.\n     */\n    onLoop?: () => void;\n    /** An array of {@link Texture} or frame objects that make up the animation. */\n    textures: AnimatedSpriteFrames;\n    /** Update anchor to [Texture's defaultAnchor]{@link Texture#defaultAnchor} when frame changes. */\n    updateAnchor?: boolean;\n}\nexport interface AnimatedSprite extends PixiMixins.AnimatedSprite, Sprite {}\n\n/**\n * An AnimatedSprite is a simple way to display an animation depicted by a list of textures.\n *\n * ```js\n * import { AnimatedSprite, Texture } from 'pixi.js';\n *\n * const alienImages = [\n *     'image_sequence_01.png',\n *     'image_sequence_02.png',\n *     'image_sequence_03.png',\n *     'image_sequence_04.png',\n * ];\n * const textureArray = [];\n *\n * for (let i = 0; i < 4; i++)\n * {\n *     const texture = Texture.from(alienImages[i]);\n *     textureArray.push(texture);\n * }\n *\n * const animatedSprite = new AnimatedSprite(textureArray);\n * ```\n *\n * The more efficient and simpler way to create an animated sprite is using a {@link Spritesheet}\n * containing the animation definitions:\n * @example\n * import { AnimatedSprite, Assets } from 'pixi.js';\n *\n * const sheet = await Assets.load('assets/spritesheet.json');\n * animatedSprite = new AnimatedSprite(sheet.animations['image_sequence']);\n * @memberof scene\n */\nexport class AnimatedSprite extends Sprite\n{\n    /**\n     * The speed that the AnimatedSprite will play at. Higher is faster, lower is slower.\n     * @default 1\n     */\n    public animationSpeed: number;\n\n    /**\n     * Whether or not the animate sprite repeats after playing.\n     * @default true\n     */\n    public loop: boolean;\n\n    /**\n     * Update anchor to [Texture's defaultAnchor]{@link Texture#defaultAnchor} when frame changes.\n     *\n     * Useful with [sprite sheet animations]{@link Spritesheet#animations} created with tools.\n     * Changing anchor for each frame allows to pin sprite origin to certain moving feature\n     * of the frame (e.g. left foot).\n     *\n     * Note: Enabling this will override any previously set `anchor` on each frame change.\n     * @default false\n     */\n    public updateAnchor: boolean;\n\n    /**\n     * User-assigned function to call when an AnimatedSprite finishes playing.\n     * @example\n     * animation.onComplete = () => {\n     *     // Finished!\n     * };\n     */\n    public onComplete?: () => void;\n\n    /**\n     * User-assigned function to call when an AnimatedSprite changes which texture is being rendered.\n     * @example\n     * animation.onFrameChange = () => {\n     *     // Updated!\n     * };\n     */\n    public onFrameChange?: (currentFrame: number) => void;\n\n    /**\n     * User-assigned function to call when `loop` is true, and an AnimatedSprite is played and\n     * loops around to start again.\n     * @example\n     * animation.onLoop = () => {\n     *     // Looped!\n     * };\n     */\n    public onLoop?: () => void;\n\n    private _playing: boolean;\n    private _textures: Texture[];\n    private _durations: number[];\n\n    /**\n     * `true` uses Ticker.shared to auto update animation time.\n     * @default true\n     */\n    private _autoUpdate: boolean;\n\n    /**\n     * `true` if the instance is currently connected to Ticker.shared to auto update animation time.\n     * @default false\n     */\n    private _isConnectedToTicker: boolean;\n\n    /** Elapsed time since animation has been started, used internally to display current texture. */\n    private _currentTime: number;\n\n    /** The texture index that was displayed last time. */\n    private _previousFrame: number;\n\n    /**\n     * @param frames - Collection of textures or frames to use.\n     * @param autoUpdate - Whether to use Ticker.shared to auto update animation time.\n     */\n    constructor(frames: AnimatedSpriteFrames, autoUpdate?: boolean);\n    /**\n     * @param options - The options for the AnimatedSprite.\n     */\n    constructor(options: AnimatedSpriteOptions);\n    /** @ignore */\n    constructor(...args: [AnimatedSpriteOptions?] | [AnimatedSpriteFrames?] | [AnimatedSpriteFrames?, boolean?])\n    {\n        let options = args[0] as AnimatedSpriteOptions;\n\n        if (Array.isArray(args[0]))\n        {\n            options = {\n                textures: args[0] as AnimatedSpriteFrames,\n                autoUpdate: args[1] as boolean,\n            };\n        }\n\n        const {\n            animationSpeed = 1,\n            autoPlay = false,\n            autoUpdate = true,\n            loop = true,\n            onComplete = null,\n            onFrameChange = null,\n            onLoop = null,\n            textures,\n            updateAnchor = false,\n            ...rest\n        } = options;\n        const [firstFrame] = textures;\n\n        super({\n            ...rest,\n            texture: firstFrame instanceof Texture ? firstFrame : firstFrame.texture,\n        });\n\n        this._textures = null;\n        this._durations = null;\n        this._autoUpdate = autoUpdate;\n        this._isConnectedToTicker = false;\n\n        this.animationSpeed = animationSpeed;\n        this.loop = loop;\n        this.updateAnchor = updateAnchor;\n        this.onComplete = onComplete;\n        this.onFrameChange = onFrameChange;\n        this.onLoop = onLoop;\n\n        this._currentTime = 0;\n\n        this._playing = false;\n        this._previousFrame = null;\n\n        this.textures = textures;\n\n        if (autoPlay)\n        {\n            this.play();\n        }\n    }\n\n    /** Stops the AnimatedSprite. */\n    public stop(): void\n    {\n        if (!this._playing)\n        {\n            return;\n        }\n\n        this._playing = false;\n        if (this._autoUpdate && this._isConnectedToTicker)\n        {\n            Ticker.shared.remove(this.update, this);\n            this._isConnectedToTicker = false;\n        }\n    }\n\n    /** Plays the AnimatedSprite. */\n    public play(): void\n    {\n        if (this._playing)\n        {\n            return;\n        }\n\n        this._playing = true;\n        if (this._autoUpdate && !this._isConnectedToTicker)\n        {\n            Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH);\n            this._isConnectedToTicker = true;\n        }\n    }\n\n    /**\n     * Stops the AnimatedSprite and goes to a specific frame.\n     * @param frameNumber - Frame index to stop at.\n     */\n    public gotoAndStop(frameNumber: number): void\n    {\n        this.stop();\n        this.currentFrame = frameNumber;\n    }\n\n    /**\n     * Goes to a specific frame and begins playing the AnimatedSprite.\n     * @param frameNumber - Frame index to start at.\n     */\n    public gotoAndPlay(frameNumber: number): void\n    {\n        this.currentFrame = frameNumber;\n        this.play();\n    }\n\n    /**\n     * Updates the object transform for rendering.\n     * @param ticker - the ticker to use to update the object.\n     */\n    public update(ticker: Ticker): void\n    {\n        // If the animation isn't playing, no update is needed.\n        if (!this._playing)\n        {\n            return;\n        }\n\n        // Calculate elapsed time based on ticker's deltaTime and animation speed.\n        const deltaTime = ticker.deltaTime;\n        const elapsed = this.animationSpeed * deltaTime;\n        const previousFrame = this.currentFrame;\n\n        // If there are specific durations set for each frame:\n        if (this._durations !== null)\n        {\n            // Calculate the lag for the current frame based on the current time.\n            let lag = this._currentTime % 1 * this._durations[this.currentFrame];\n\n            // Adjust the lag based on elapsed time.\n            lag += elapsed / 60 * 1000;\n\n            // If the lag is negative, adjust the current time and the lag.\n            while (lag < 0)\n            {\n                this._currentTime--;\n                lag += this._durations[this.currentFrame];\n            }\n\n            const sign = Math.sign(this.animationSpeed * deltaTime);\n\n            // Floor the current time to get a whole number frame.\n            this._currentTime = Math.floor(this._currentTime);\n\n            // Adjust the current time and the lag until the lag is less than the current frame's duration.\n            while (lag >= this._durations[this.currentFrame])\n            {\n                lag -= this._durations[this.currentFrame] * sign;\n                this._currentTime += sign;\n            }\n\n            // Adjust the current time based on the lag and current frame's duration.\n            this._currentTime += lag / this._durations[this.currentFrame];\n        }\n        else\n        {\n            // If no specific durations set, simply adjust the current time by elapsed time.\n            this._currentTime += elapsed;\n        }\n\n        // Handle scenarios when animation reaches the start or the end.\n        if (this._currentTime < 0 && !this.loop)\n        {\n            // If the animation shouldn't loop and it reaches the start, go to the first frame.\n            this.gotoAndStop(0);\n\n            // If there's an onComplete callback, call it.\n            if (this.onComplete)\n            {\n                this.onComplete();\n            }\n        }\n        else if (this._currentTime >= this._textures.length && !this.loop)\n        {\n            // If the animation shouldn't loop and it reaches the end, go to the last frame.\n            this.gotoAndStop(this._textures.length - 1);\n\n            // If there's an onComplete callback, call it.\n            if (this.onComplete)\n            {\n                this.onComplete();\n            }\n        }\n        else if (previousFrame !== this.currentFrame)\n        {\n            // If the current frame is different from the last update, handle loop scenarios.\n            if (this.loop && this.onLoop)\n            {\n                if ((this.animationSpeed > 0 && this.currentFrame < previousFrame)\n                    || (this.animationSpeed < 0 && this.currentFrame > previousFrame))\n                {\n                    // If the animation loops, and there's an onLoop callback, call it.\n                    this.onLoop();\n                }\n            }\n\n            // Update the texture for the current frame.\n            this._updateTexture();\n        }\n    }\n\n    /** Updates the displayed texture to match the current frame index. */\n    private _updateTexture(): void\n    {\n        const currentFrame = this.currentFrame;\n\n        if (this._previousFrame === currentFrame)\n        {\n            return;\n        }\n\n        this._previousFrame = currentFrame;\n\n        this.texture = this._textures[currentFrame];\n\n        if (this.updateAnchor && this.texture.defaultAnchor)\n        {\n            this.anchor.copyFrom(this.texture.defaultAnchor);\n        }\n\n        if (this.onFrameChange)\n        {\n            this.onFrameChange(this.currentFrame);\n        }\n    }\n\n    /** Stops the AnimatedSprite and destroys it. */\n    public destroy(): void\n    {\n        this.stop();\n        super.destroy();\n\n        this.onComplete = null;\n        this.onFrameChange = null;\n        this.onLoop = null;\n    }\n\n    /**\n     * A short hand way of creating an AnimatedSprite from an array of frame ids.\n     * @param frames - The array of frames ids the AnimatedSprite will use as its texture frames.\n     * @returns - The new animated sprite with the specified frames.\n     */\n    public static fromFrames(frames: string[]): AnimatedSprite\n    {\n        const textures = [];\n\n        for (let i = 0; i < frames.length; ++i)\n        {\n            textures.push(Texture.from(frames[i]));\n        }\n\n        return new AnimatedSprite(textures);\n    }\n\n    /**\n     * A short hand way of creating an AnimatedSprite from an array of image ids.\n     * @param images - The array of image urls the AnimatedSprite will use as its texture frames.\n     * @returns The new animate sprite with the specified images as frames.\n     */\n    public static fromImages(images: string[]): AnimatedSprite\n    {\n        const textures = [];\n\n        for (let i = 0; i < images.length; ++i)\n        {\n            textures.push(Texture.from(images[i]));\n        }\n\n        return new AnimatedSprite(textures);\n    }\n\n    /**\n     * The total number of frames in the AnimatedSprite. This is the same as number of textures\n     * assigned to the AnimatedSprite.\n     * @readonly\n     * @default 0\n     */\n    get totalFrames(): number\n    {\n        return this._textures.length;\n    }\n\n    /** The array of textures used for this AnimatedSprite. */\n    get textures(): AnimatedSpriteFrames\n    {\n        return this._textures;\n    }\n\n    set textures(value: AnimatedSpriteFrames)\n    {\n        if (value[0] instanceof Texture)\n        {\n            this._textures = value as Texture[];\n            this._durations = null;\n        }\n        else\n        {\n            this._textures = [];\n            this._durations = [];\n\n            for (let i = 0; i < value.length; i++)\n            {\n                this._textures.push((value[i] as FrameObject).texture);\n                this._durations.push((value[i] as FrameObject).time);\n            }\n        }\n        this._previousFrame = null;\n        this.gotoAndStop(0);\n        this._updateTexture();\n    }\n\n    /** The AnimatedSprite's current frame index. */\n    get currentFrame(): number\n    {\n        let currentFrame = Math.floor(this._currentTime) % this._textures.length;\n\n        if (currentFrame < 0)\n        {\n            currentFrame += this._textures.length;\n        }\n\n        return currentFrame;\n    }\n\n    set currentFrame(value: number)\n    {\n        if (value < 0 || value > this.totalFrames - 1)\n        {\n            throw new Error(`[AnimatedSprite]: Invalid frame index value ${value}, `\n                + `expected to be between 0 and totalFrames ${this.totalFrames}.`);\n        }\n\n        const previousFrame = this.currentFrame;\n\n        this._currentTime = value;\n\n        if (previousFrame !== this.currentFrame)\n        {\n            this._updateTexture();\n        }\n    }\n\n    /**\n     * Indicates if the AnimatedSprite is currently playing.\n     * @readonly\n     */\n    get playing(): boolean\n    {\n        return this._playing;\n    }\n\n    /** Whether to use Ticker.shared to auto update animation time. */\n    get autoUpdate(): boolean\n    {\n        return this._autoUpdate;\n    }\n\n    set autoUpdate(value: boolean)\n    {\n        if (value !== this._autoUpdate)\n        {\n            this._autoUpdate = value;\n\n            if (!this._autoUpdate && this._isConnectedToTicker)\n            {\n                Ticker.shared.remove(this.update, this);\n                this._isConnectedToTicker = false;\n            }\n            else if (this._autoUpdate && !this._isConnectedToTicker && this._playing)\n            {\n                Ticker.shared.add(this.update, this);\n                this._isConnectedToTicker = true;\n            }\n        }\n    }\n}\n\n/**\n * A reference to a frame in an {@link scene.AnimatedSprite}\n * @memberof scene\n */\nexport interface FrameObject\n{\n    /** The {@link Texture} of the frame. */\n    texture: Texture;\n\n    /** The duration of the frame, in milliseconds. */\n    time: number;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}