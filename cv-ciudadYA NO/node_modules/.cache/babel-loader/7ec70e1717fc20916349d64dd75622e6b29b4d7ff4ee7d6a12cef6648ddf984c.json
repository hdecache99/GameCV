{"ast":null,"code":"import { extensions, ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { buildUvs, buildSimpleUvs } from '../../../../rendering/renderers/shared/geometry/utils/buildUvs.mjs';\nimport { transformVertices } from '../../../../rendering/renderers/shared/geometry/utils/transformVertices.mjs';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { BigPool } from '../../../../utils/pool/PoolGroup.mjs';\nimport { BatchableGraphics } from '../BatchableGraphics.mjs';\nimport { buildCircle, buildEllipse, buildRoundedRectangle } from '../buildCommands/buildCircle.mjs';\nimport { buildLine } from '../buildCommands/buildLine.mjs';\nimport { buildPixelLine } from '../buildCommands/buildPixelLine.mjs';\nimport { buildPolygon } from '../buildCommands/buildPolygon.mjs';\nimport { buildRectangle } from '../buildCommands/buildRectangle.mjs';\nimport { buildTriangle } from '../buildCommands/buildTriangle.mjs';\nimport { generateTextureMatrix } from './generateTextureFillMatrix.mjs';\nimport { triangulateWithHoles } from './triangulateWithHoles.mjs';\n\"use strict\";\nconst shapeBuilders = {};\nextensions.handleByMap(ExtensionType.ShapeBuilder, shapeBuilders);\nextensions.add(buildRectangle, buildPolygon, buildTriangle, buildCircle, buildEllipse, buildRoundedRectangle);\nconst tempRect = new Rectangle();\nconst tempTextureMatrix = new Matrix();\nfunction buildContextBatches(context, gpuContext) {\n  const {\n    geometryData,\n    batches\n  } = gpuContext;\n  batches.length = 0;\n  geometryData.indices.length = 0;\n  geometryData.vertices.length = 0;\n  geometryData.uvs.length = 0;\n  for (let i = 0; i < context.instructions.length; i++) {\n    const instruction = context.instructions[i];\n    if (instruction.action === \"texture\") {\n      addTextureToGeometryData(instruction.data, batches, geometryData);\n    } else if (instruction.action === \"fill\" || instruction.action === \"stroke\") {\n      const isStroke = instruction.action === \"stroke\";\n      const shapePath = instruction.data.path.shapePath;\n      const style = instruction.data.style;\n      const hole = instruction.data.hole;\n      if (isStroke && hole) {\n        addShapePathToGeometryData(hole.shapePath, style, true, batches, geometryData);\n      }\n      if (hole) {\n        shapePath.shapePrimitives[shapePath.shapePrimitives.length - 1].holes = hole.shapePath.shapePrimitives;\n      }\n      addShapePathToGeometryData(shapePath, style, isStroke, batches, geometryData);\n    }\n  }\n}\nfunction addTextureToGeometryData(data, batches, geometryData) {\n  const {\n    vertices,\n    uvs,\n    indices\n  } = geometryData;\n  const indexOffset = indices.length;\n  const vertOffset = vertices.length / 2;\n  const points = [];\n  const build = shapeBuilders.rectangle;\n  const rect = tempRect;\n  const texture = data.image;\n  rect.x = data.dx;\n  rect.y = data.dy;\n  rect.width = data.dw;\n  rect.height = data.dh;\n  const matrix = data.transform;\n  build.build(rect, points);\n  if (matrix) {\n    transformVertices(points, matrix);\n  }\n  build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n  const textureUvs = texture.uvs;\n  uvs.push(textureUvs.x0, textureUvs.y0, textureUvs.x1, textureUvs.y1, textureUvs.x3, textureUvs.y3, textureUvs.x2, textureUvs.y2);\n  const graphicsBatch = BigPool.get(BatchableGraphics);\n  graphicsBatch.indexOffset = indexOffset;\n  graphicsBatch.indexSize = indices.length - indexOffset;\n  graphicsBatch.attributeOffset = vertOffset;\n  graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;\n  graphicsBatch.baseColor = data.style;\n  graphicsBatch.alpha = data.alpha;\n  graphicsBatch.texture = texture;\n  graphicsBatch.geometryData = geometryData;\n  batches.push(graphicsBatch);\n}\nfunction addShapePathToGeometryData(shapePath, style, isStroke, batches, geometryData) {\n  const {\n    vertices,\n    uvs,\n    indices\n  } = geometryData;\n  shapePath.shapePrimitives.forEach(({\n    shape,\n    transform: matrix,\n    holes\n  }) => {\n    const indexOffset = indices.length;\n    const vertOffset = vertices.length / 2;\n    const points = [];\n    const build = shapeBuilders[shape.type];\n    let topology = \"triangle-list\";\n    build.build(shape, points);\n    if (matrix) {\n      transformVertices(points, matrix);\n    }\n    if (!isStroke) {\n      if (holes) {\n        const holeIndices = [];\n        const otherPoints = points.slice();\n        const holeArrays = getHoleArrays(holes);\n        holeArrays.forEach(holePoints => {\n          holeIndices.push(otherPoints.length / 2);\n          otherPoints.push(...holePoints);\n        });\n        triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);\n      } else {\n        build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n      }\n    } else {\n      const close = shape.closePath ?? true;\n      const lineStyle = style;\n      if (!lineStyle.pixelLine) {\n        buildLine(points, lineStyle, false, close, vertices, indices);\n      } else {\n        buildPixelLine(points, close, vertices, indices);\n        topology = \"line-list\";\n      }\n    }\n    const uvsOffset = uvs.length / 2;\n    const texture = style.texture;\n    if (texture !== Texture.WHITE) {\n      const textureMatrix = generateTextureMatrix(tempTextureMatrix, style, shape, matrix);\n      buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);\n    } else {\n      buildSimpleUvs(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);\n    }\n    const graphicsBatch = BigPool.get(BatchableGraphics);\n    graphicsBatch.indexOffset = indexOffset;\n    graphicsBatch.indexSize = indices.length - indexOffset;\n    graphicsBatch.attributeOffset = vertOffset;\n    graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;\n    graphicsBatch.baseColor = style.color;\n    graphicsBatch.alpha = style.alpha;\n    graphicsBatch.texture = texture;\n    graphicsBatch.geometryData = geometryData;\n    graphicsBatch.topology = topology;\n    batches.push(graphicsBatch);\n  });\n}\nfunction getHoleArrays(holePrimitives) {\n  const holeArrays = [];\n  for (let k = 0; k < holePrimitives.length; k++) {\n    const holePrimitive = holePrimitives[k].shape;\n    const holePoints = [];\n    const holeBuilder = shapeBuilders[holePrimitive.type];\n    holeBuilder.build(holePrimitive, holePoints);\n    holeArrays.push(holePoints);\n  }\n  return holeArrays;\n}\nexport { buildContextBatches, shapeBuilders };","map":{"version":3,"names":["shapeBuilders","extensions","handleByMap","ExtensionType","ShapeBuilder","add","buildRectangle","buildPolygon","buildTriangle","buildCircle","buildEllipse","buildRoundedRectangle","tempRect","Rectangle","tempTextureMatrix","Matrix","buildContextBatches","context","gpuContext","geometryData","batches","length","indices","vertices","uvs","i","instructions","instruction","action","addTextureToGeometryData","data","isStroke","shapePath","path","style","hole","addShapePathToGeometryData","shapePrimitives","holes","indexOffset","vertOffset","points","build","rectangle","rect","texture","image","x","dx","y","dy","width","dw","height","dh","matrix","transform","transformVertices","triangulate","textureUvs","push","x0","y0","x1","y1","x3","y3","x2","y2","graphicsBatch","BigPool","get","BatchableGraphics","indexSize","attributeOffset","attributeSize","baseColor","alpha","forEach","shape","type","topology","holeIndices","otherPoints","slice","holeArrays","getHoleArrays","holePoints","triangulateWithHoles","close","closePath","lineStyle","pixelLine","buildLine","buildPixelLine","uvsOffset","Texture","WHITE","textureMatrix","generateTextureMatrix","buildUvs","buildSimpleUvs","color","holePrimitives","k","holePrimitive","holeBuilder"],"sources":["C:\\Users\\emalv\\OneDrive\\Desktop\\Portafolio\\cv-ciudad\\node_modules\\pixi.js\\src\\scene\\graphics\\shared\\utils\\buildContextBatches.ts"],"sourcesContent":["import { extensions, ExtensionType } from '../../../../extensions/Extensions';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { buildSimpleUvs, buildUvs } from '../../../../rendering/renderers/shared/geometry/utils/buildUvs';\nimport { transformVertices } from '../../../../rendering/renderers/shared/geometry/utils/transformVertices';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { BigPool } from '../../../../utils/pool/PoolGroup';\nimport { BatchableGraphics } from '../BatchableGraphics';\nimport { buildCircle, buildEllipse, buildRoundedRectangle } from '../buildCommands/buildCircle';\nimport { buildLine } from '../buildCommands/buildLine';\nimport { buildPixelLine } from '../buildCommands/buildPixelLine';\nimport { buildPolygon } from '../buildCommands/buildPolygon';\nimport { buildRectangle } from '../buildCommands/buildRectangle';\nimport { buildTriangle } from '../buildCommands/buildTriangle';\nimport { generateTextureMatrix as generateTextureFillMatrix } from './generateTextureFillMatrix';\nimport { triangulateWithHoles } from './triangulateWithHoles';\n\nimport type { Polygon } from '../../../../maths/shapes/Polygon';\nimport type { Topology } from '../../../../rendering/renderers/shared/geometry/const';\nimport type { ShapeBuildCommand } from '../buildCommands/ShapeBuildCommand';\nimport type { ConvertedFillStyle, ConvertedStrokeStyle } from '../FillTypes';\nimport type { GraphicsContext, TextureInstruction } from '../GraphicsContext';\nimport type { GpuGraphicsContext } from '../GraphicsContextSystem';\nimport type { ShapePath, ShapePrimitiveWithHoles } from '../path/ShapePath';\n\nexport const shapeBuilders: Record<string, ShapeBuildCommand> = {};\n\nextensions.handleByMap(ExtensionType.ShapeBuilder, shapeBuilders);\nextensions.add(buildRectangle, buildPolygon, buildTriangle, buildCircle, buildEllipse, buildRoundedRectangle);\n\nconst tempRect = new Rectangle();\nconst tempTextureMatrix = new Matrix();\n\nexport function buildContextBatches(context: GraphicsContext, gpuContext: GpuGraphicsContext)\n{\n    const { geometryData, batches } = gpuContext;\n\n    // reset them..\n    batches.length = 0;\n    geometryData.indices.length = 0;\n    geometryData.vertices.length = 0;\n    geometryData.uvs.length = 0;\n\n    for (let i = 0; i < context.instructions.length; i++)\n    {\n        const instruction = context.instructions[i];\n\n        if (instruction.action === 'texture')\n        {\n            // add a quad!\n            addTextureToGeometryData(instruction.data, batches, geometryData);\n        }\n        else if (instruction.action === 'fill' || instruction.action === 'stroke')\n        {\n            const isStroke = instruction.action === 'stroke';\n\n            // build path collection of polys and shapes points..\n            const shapePath = instruction.data.path.shapePath;\n\n            const style = instruction.data.style;\n\n            const hole = instruction.data.hole;\n\n            if (isStroke && hole)\n            {\n                addShapePathToGeometryData(hole.shapePath, style, true, batches, geometryData);\n            }\n\n            if (hole)\n            {\n                // add the holes to the last shape primitive\n                shapePath.shapePrimitives[shapePath.shapePrimitives.length - 1].holes = hole.shapePath.shapePrimitives;\n            }\n\n            addShapePathToGeometryData(shapePath, style, isStroke, batches, geometryData);\n        }\n    }\n}\n\nfunction addTextureToGeometryData(\n    data: TextureInstruction['data'],\n    batches: BatchableGraphics[],\n    geometryData: {\n        vertices: number[];\n        uvs: number[];\n        indices: number[];\n    }\n)\n{\n    const { vertices, uvs, indices } = geometryData;\n\n    const indexOffset = indices.length;\n    const vertOffset = vertices.length / 2;\n\n    const points: number[] = [];\n\n    const build = shapeBuilders.rectangle;\n\n    const rect = tempRect;\n\n    const texture = data.image;\n\n    rect.x = data.dx;\n    rect.y = data.dy;\n    rect.width = data.dw;\n    rect.height = data.dh;\n\n    const matrix = data.transform;\n\n    // TODO - this can be cached...\n    build.build(rect, points);\n\n    if (matrix)\n    {\n        transformVertices(points, matrix);\n    }\n\n    build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n\n    const textureUvs = texture.uvs;\n\n    uvs.push(\n        textureUvs.x0, textureUvs.y0,\n        textureUvs.x1, textureUvs.y1,\n        textureUvs.x3, textureUvs.y3,\n        textureUvs.x2, textureUvs.y2,\n    );\n\n    const graphicsBatch = BigPool.get(BatchableGraphics);\n\n    graphicsBatch.indexOffset = indexOffset;\n    graphicsBatch.indexSize = indices.length - indexOffset;\n\n    graphicsBatch.attributeOffset = vertOffset;\n    graphicsBatch.attributeSize = (vertices.length / 2) - vertOffset;\n\n    graphicsBatch.baseColor = data.style;\n    graphicsBatch.alpha = data.alpha;\n\n    graphicsBatch.texture = texture;\n    graphicsBatch.geometryData = geometryData;\n\n    batches.push(graphicsBatch);\n}\n\nfunction addShapePathToGeometryData(\n    shapePath: ShapePath,\n    style: ConvertedFillStyle | ConvertedStrokeStyle,\n    isStroke: boolean,\n    batches: BatchableGraphics[],\n    geometryData: {\n        vertices: number[];\n        uvs: number[];\n        indices: number[];\n    }\n)\n{\n    const { vertices, uvs, indices } = geometryData;\n\n    shapePath.shapePrimitives.forEach(({ shape, transform: matrix, holes }) =>\n    {\n        const indexOffset = indices.length;\n        const vertOffset = vertices.length / 2;\n\n        const points: number[] = [];\n\n        const build = shapeBuilders[shape.type];\n        let topology: Topology = 'triangle-list';\n        // TODO - this can be cached...\n        // TODO - THIS IS DONE TWICE!!!!!!\n        // ONCE FOR STROKE AND ONCE FOR FILL\n        // move to the ShapePath2D class itself?\n\n        build.build(shape, points);\n\n        if (matrix)\n        {\n            transformVertices(points, matrix);\n        }\n\n        if (!isStroke)\n        {\n            if (holes)\n            {\n                const holeIndices: number[] = [];\n\n                const otherPoints = points.slice();\n\n                const holeArrays = getHoleArrays(holes);\n\n                holeArrays.forEach((holePoints) =>\n                {\n                    holeIndices.push(otherPoints.length / 2);\n                    otherPoints.push(...holePoints);\n                });\n\n                triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);\n            }\n            else\n            {\n                build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n            }\n        }\n        else\n        {\n            const close = (shape as Polygon).closePath ?? true;\n            const lineStyle = style as ConvertedStrokeStyle;\n\n            if (!lineStyle.pixelLine)\n            {\n                buildLine(points, lineStyle, false, close, vertices, indices);\n            }\n            else\n            {\n                buildPixelLine(points, close, vertices, indices);\n                topology = 'line-list';\n            }\n        }\n\n        const uvsOffset = uvs.length / 2;\n\n        const texture = style.texture;\n\n        if (texture !== Texture.WHITE)\n        {\n            const textureMatrix = generateTextureFillMatrix(tempTextureMatrix, style, shape, matrix);\n\n            buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, (vertices.length / 2) - vertOffset, textureMatrix);\n        }\n        else\n        {\n            buildSimpleUvs(uvs, uvsOffset, 2, (vertices.length / 2) - vertOffset);\n        }\n\n        const graphicsBatch = BigPool.get(BatchableGraphics);\n\n        graphicsBatch.indexOffset = indexOffset;\n        graphicsBatch.indexSize = indices.length - indexOffset;\n\n        graphicsBatch.attributeOffset = vertOffset;\n        graphicsBatch.attributeSize = (vertices.length / 2) - vertOffset;\n\n        graphicsBatch.baseColor = style.color;\n        graphicsBatch.alpha = style.alpha;\n\n        graphicsBatch.texture = texture;\n        graphicsBatch.geometryData = geometryData;\n        graphicsBatch.topology = topology;\n\n        batches.push(graphicsBatch);\n    });\n}\n\nfunction getHoleArrays(holePrimitives: ShapePrimitiveWithHoles[])\n{\n    const holeArrays = [];\n\n    for (let k = 0; k < holePrimitives.length; k++)\n    {\n        const holePrimitive = holePrimitives[k].shape;\n\n        // TODO - need to transform the points via there transform here..\n        const holePoints: number[] = [];\n\n        const holeBuilder = shapeBuilders[holePrimitive.type] as ShapeBuildCommand;\n\n        holeBuilder.build(holePrimitive, holePoints);\n\n        holeArrays.push(holePoints);\n    }\n\n    return holeArrays;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}