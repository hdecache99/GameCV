{"ast":null,"code":"import { DOMAdapter } from '../../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../../extensions/Extensions.mjs';\nimport { TextureSource } from './TextureSource.mjs';\n\"use strict\";\nclass CanvasSource extends TextureSource {\n  constructor(options) {\n    if (!options.resource) {\n      options.resource = DOMAdapter.get().createCanvas();\n    }\n    if (!options.width) {\n      options.width = options.resource.width;\n      if (!options.autoDensity) {\n        options.width /= options.resolution;\n      }\n    }\n    if (!options.height) {\n      options.height = options.resource.height;\n      if (!options.autoDensity) {\n        options.height /= options.resolution;\n      }\n    }\n    super(options);\n    this.uploadMethodId = \"image\";\n    this.autoDensity = options.autoDensity;\n    this.resizeCanvas();\n    this.transparent = !!options.transparent;\n  }\n  resizeCanvas() {\n    if (this.autoDensity && \"style\" in this.resource) {\n      this.resource.style.width = `${this.width}px`;\n      this.resource.style.height = `${this.height}px`;\n    }\n    if (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) {\n      this.resource.width = this.pixelWidth;\n      this.resource.height = this.pixelHeight;\n    }\n  }\n  resize(width = this.width, height = this.height, resolution = this._resolution) {\n    const didResize = super.resize(width, height, resolution);\n    if (didResize) {\n      this.resizeCanvas();\n    }\n    return didResize;\n  }\n  static test(resource) {\n    return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas;\n  }\n  /**\n   * Returns the 2D rendering context for the canvas.\n   * Caches the context after creating it.\n   * @returns The 2D rendering context of the canvas.\n   */\n  get context2D() {\n    return this._context2D || (this._context2D = this.resource.getContext(\"2d\"));\n  }\n}\nCanvasSource.extension = ExtensionType.TextureSource;\nexport { CanvasSource };","map":{"version":3,"names":["CanvasSource","TextureSource","constructor","options","resource","DOMAdapter","get","createCanvas","width","autoDensity","resolution","height","uploadMethodId","resizeCanvas","transparent","style","pixelWidth","pixelHeight","resize","_resolution","didResize","test","globalThis","HTMLCanvasElement","OffscreenCanvas","context2D","_context2D","getContext","extension","ExtensionType"],"sources":["C:\\Users\\emalv\\OneDrive\\Desktop\\Portafolio\\cv-ciudad\\node_modules\\pixi.js\\src\\rendering\\renderers\\shared\\texture\\sources\\CanvasSource.ts"],"sourcesContent":["import { DOMAdapter } from '../../../../../environment/adapter';\nimport { ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from './TextureSource';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { TextureSourceOptions } from './TextureSource';\n\nexport interface CanvasSourceOptions extends TextureSourceOptions<ICanvas>\n{\n    /**\n     * Should the canvas be resized to preserve its screen width and height regardless\n     * of the resolution of the renderer, this is only supported for HTMLCanvasElement\n     * and will be ignored if the canvas is an OffscreenCanvas.\n     */\n    autoDensity?: boolean;\n    /** if true, this canvas will be set up to be transparent where possible */\n    transparent?: boolean;\n}\n\nexport class CanvasSource extends TextureSource<ICanvas>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n\n    public uploadMethodId = 'image';\n    public autoDensity: boolean;\n    public transparent: boolean;\n\n    private _context2D: CanvasRenderingContext2D;\n\n    constructor(options: CanvasSourceOptions)\n    {\n        if (!options.resource)\n        {\n            options.resource = DOMAdapter.get().createCanvas();\n        }\n\n        if (!options.width)\n        {\n            options.width = options.resource.width;\n\n            if (!options.autoDensity)\n            {\n                options.width /= options.resolution;\n            }\n        }\n\n        if (!options.height)\n        {\n            options.height = options.resource.height;\n\n            if (!options.autoDensity)\n            {\n                options.height /= options.resolution;\n            }\n        }\n\n        super(options);\n\n        this.autoDensity = options.autoDensity;\n\n        this.resizeCanvas();\n\n        this.transparent = !!options.transparent;\n    }\n\n    public resizeCanvas()\n    {\n        if (this.autoDensity && 'style' in this.resource)\n        {\n            this.resource.style.width = `${this.width}px`;\n            this.resource.style.height = `${this.height}px`;\n        }\n\n        // only resize if wee need to, as this clears the canvas (even if values are set to the same)\n        if (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight)\n        {\n            this.resource.width = this.pixelWidth;\n            this.resource.height = this.pixelHeight;\n        }\n    }\n\n    public resize(width = this.width, height = this.height, resolution = this._resolution): boolean\n    {\n        const didResize = super.resize(width, height, resolution);\n\n        if (didResize)\n        {\n            this.resizeCanvas();\n        }\n\n        return didResize;\n    }\n\n    public static test(resource: any): resource is ICanvas\n    {\n        return (globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement)\n        || (globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas);\n    }\n\n    /**\n     * Returns the 2D rendering context for the canvas.\n     * Caches the context after creating it.\n     * @returns The 2D rendering context of the canvas.\n     */\n    get context2D(): CanvasRenderingContext2D\n    {\n        return this._context2D || (this._context2D = this.resource.getContext('2d') as CanvasRenderingContext2D);\n    }\n}\n"],"mappings":";;;;AAoBO,MAAMA,YAAA,SAAqBC,aAClC;EASIC,YAAYC,OACZ;IACQ,KAACA,OAAA,CAAQC,QACb;MACID,OAAA,CAAQC,QAAW,GAAAC,UAAA,CAAWC,GAAI,GAAEC,YAAa;IAAA;IAGjD,KAACJ,OAAA,CAAQK,KACb;MACYL,OAAA,CAAAK,KAAA,GAAQL,OAAA,CAAQC,QAAS,CAAAI,KAAA;MAE7B,KAACL,OAAA,CAAQM,WACb;QACIN,OAAA,CAAQK,KAAA,IAASL,OAAQ,CAAAO,UAAA;MAAA;IAC7B;IAGA,KAACP,OAAA,CAAQQ,MACb;MACYR,OAAA,CAAAQ,MAAA,GAASR,OAAA,CAAQC,QAAS,CAAAO,MAAA;MAE9B,KAACR,OAAA,CAAQM,WACb;QACIN,OAAA,CAAQQ,MAAA,IAAUR,OAAQ,CAAAO,UAAA;MAAA;IAC9B;IAGJ,MAAMP,OAAO;IAjCjB,KAAOS,cAAiB;IAmCpB,KAAKH,WAAA,GAAcN,OAAQ,CAAAM,WAAA;IAE3B,KAAKI,YAAa;IAEb,KAAAC,WAAA,GAAc,CAAC,CAACX,OAAQ,CAAAW,WAAA;EAAA;EAG1BD,YACPA,CAAA;IACI,IAAI,IAAK,CAAAJ,WAAA,IAAe,OAAW,SAAKL,QACxC;MACI,KAAKA,QAAS,CAAAW,KAAA,CAAMP,KAAQ,MAAG,KAAKA,KAAK;MACzC,KAAKJ,QAAS,CAAAW,KAAA,CAAMJ,MAAS,MAAG,KAAKA,MAAM;IAAA;IAI3C,SAAKP,QAAA,CAASI,KAAU,UAAKQ,UAAA,IAAc,IAAK,CAAAZ,QAAA,CAASO,MAAW,UAAKM,WAC7E;MACS,KAAAb,QAAA,CAASI,KAAA,GAAQ,IAAK,CAAAQ,UAAA;MACtB,KAAAZ,QAAA,CAASO,MAAA,GAAS,IAAK,CAAAM,WAAA;IAAA;EAChC;EAGGC,OAAOV,KAAA,GAAQ,IAAK,CAAAA,KAAA,EAAOG,MAAA,GAAS,IAAK,CAAAA,MAAA,EAAQD,UAAa,QAAKS,WAC1E;IACI,MAAMC,SAAY,SAAMF,MAAO,CAAAV,KAAA,EAAOG,MAAA,EAAQD,UAAU;IAExD,IAAIU,SACJ;MACI,KAAKP,YAAa;IAAA;IAGf,OAAAO,SAAA;EAAA;EAGX,OAAcC,KAAKjB,QACnB;IACI,OAAQkB,UAAA,CAAWC,iBAAqB,IAAAnB,QAAA,YAAoBmB,iBACxD,IAAAD,UAAA,CAAWE,eAAA,IAAmBpB,QAAoB,YAAAoB,eAAA;EAAA;EAC1D;AAAA;AAAA;AAAA;AAAA;EAOA,IAAIC,SACJA,CAAA;IACI,OAAO,KAAKC,UAAe,UAAKA,UAAA,GAAa,IAAK,CAAAtB,QAAA,CAASuB,UAAA,CAAW,IAAI;EAAA;AAElF;AAzFa3B,YAAA,CAEK4B,SAAA,GAA+BC,aAAc,CAAA5B,aAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}