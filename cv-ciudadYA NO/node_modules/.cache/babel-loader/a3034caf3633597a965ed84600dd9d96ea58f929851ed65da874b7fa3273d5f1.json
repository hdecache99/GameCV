{"ast":null,"code":"import { Cache } from '../../assets/cache/Cache.mjs';\nimport { ObservablePoint } from '../../maths/point/ObservablePoint.mjs';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture.mjs';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { warn } from '../../utils/logging/warn.mjs';\nimport { Transform } from '../../utils/misc/Transform.mjs';\nimport { ViewContainer } from '../view/ViewContainer.mjs';\n\"use strict\";\nconst _TilingSprite = class _TilingSprite extends ViewContainer {\n  constructor(...args) {\n    let options = args[0] || {};\n    if (options instanceof Texture) {\n      options = {\n        texture: options\n      };\n    }\n    if (args.length > 1) {\n      deprecation(v8_0_0, \"use new TilingSprite({ texture, width:100, height:100 }) instead\");\n      options.width = args[1];\n      options.height = args[2];\n    }\n    options = {\n      ..._TilingSprite.defaultOptions,\n      ...options\n    };\n    const {\n      texture,\n      anchor,\n      tilePosition,\n      tileScale,\n      tileRotation,\n      width,\n      height,\n      applyAnchorToTexture,\n      roundPixels,\n      ...rest\n    } = options ?? {};\n    super({\n      label: \"TilingSprite\",\n      ...rest\n    });\n    this.renderPipeId = \"tilingSprite\";\n    this.batched = true;\n    this.allowChildren = false;\n    this._anchor = new ObservablePoint({\n      _onUpdate: () => {\n        this.onViewUpdate();\n      }\n    });\n    this.applyAnchorToTexture = applyAnchorToTexture;\n    this.texture = texture;\n    this._width = width ?? texture.width;\n    this._height = height ?? texture.height;\n    this._tileTransform = new Transform({\n      observer: {\n        _onUpdate: () => this.onViewUpdate()\n      }\n    });\n    if (anchor) this.anchor = anchor;\n    this.tilePosition = tilePosition;\n    this.tileScale = tileScale;\n    this.tileRotation = tileRotation;\n    this.roundPixels = roundPixels ?? false;\n  }\n  /**\n   * Creates a new tiling sprite.\n   * @param source - The source to create the texture from.\n   * @param options - The options for creating the tiling sprite.\n   * @returns A new tiling sprite.\n   */\n  static from(source, options = {}) {\n    if (typeof source === \"string\") {\n      return new _TilingSprite({\n        texture: Cache.get(source),\n        ...options\n      });\n    }\n    return new _TilingSprite({\n      texture: source,\n      ...options\n    });\n  }\n  /**\n   * @see {@link scene.TilingSpriteOptions.applyAnchorToTexture}\n   * @deprecated since 8.0.0\n   */\n  get uvRespectAnchor() {\n    warn(\"uvRespectAnchor is deprecated, please use applyAnchorToTexture instead\");\n    return this.applyAnchorToTexture;\n  }\n  set uvRespectAnchor(value) {\n    warn(\"uvRespectAnchor is deprecated, please use applyAnchorToTexture instead\");\n    this.applyAnchorToTexture = value;\n  }\n  /**\n   * Changes frame clamping in corresponding textureMatrix\n   * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n   * @default 0.5\n   * @member {number}\n   */\n  get clampMargin() {\n    return this._texture.textureMatrix.clampMargin;\n  }\n  set clampMargin(value) {\n    this._texture.textureMatrix.clampMargin = value;\n  }\n  /**\n   * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n   * and passed to the constructor.\n   *\n   * The default is `(0,0)`, this means the sprite's origin is the top left.\n   *\n   * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n   *\n   * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n   *\n   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n   * @example\n   * import { TilingSprite } from 'pixi.js';\n   *\n   * const sprite = new TilingSprite({texture: Texture.WHITE});\n   * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n   */\n  get anchor() {\n    return this._anchor;\n  }\n  set anchor(value) {\n    typeof value === \"number\" ? this._anchor.set(value) : this._anchor.copyFrom(value);\n  }\n  /** The offset of the image that is being tiled. */\n  get tilePosition() {\n    return this._tileTransform.position;\n  }\n  set tilePosition(value) {\n    this._tileTransform.position.copyFrom(value);\n  }\n  /** The scaling of the image that is being tiled. */\n  get tileScale() {\n    return this._tileTransform.scale;\n  }\n  set tileScale(value) {\n    typeof value === \"number\" ? this._tileTransform.scale.set(value) : this._tileTransform.scale.copyFrom(value);\n  }\n  set tileRotation(value) {\n    this._tileTransform.rotation = value;\n  }\n  /** The rotation of the image that is being tiled. */\n  get tileRotation() {\n    return this._tileTransform.rotation;\n  }\n  /** The transform of the image that is being tiled. */\n  get tileTransform() {\n    return this._tileTransform;\n  }\n  set texture(value) {\n    value || (value = Texture.EMPTY);\n    const currentTexture = this._texture;\n    if (currentTexture === value) return;\n    if (currentTexture && currentTexture.dynamic) currentTexture.off(\"update\", this.onViewUpdate, this);\n    if (value.dynamic) value.on(\"update\", this.onViewUpdate, this);\n    this._texture = value;\n    this.onViewUpdate();\n  }\n  /** The texture that the sprite is using. */\n  get texture() {\n    return this._texture;\n  }\n  /** The width of the tiling area. */\n  set width(value) {\n    this._width = value;\n    this.onViewUpdate();\n  }\n  get width() {\n    return this._width;\n  }\n  set height(value) {\n    this._height = value;\n    this.onViewUpdate();\n  }\n  /** The height of the tiling area. */\n  get height() {\n    return this._height;\n  }\n  /**\n   * Sets the size of the TilingSprite to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   */\n  setSize(value, height) {\n    if (typeof value === \"object\") {\n      height = value.height ?? value.width;\n      value = value.width;\n    }\n    this._width = value;\n    this._height = height ?? value;\n    this.onViewUpdate();\n  }\n  /**\n   * Retrieves the size of the TilingSprite as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the TilingSprite.\n   */\n  getSize(out) {\n    out || (out = {});\n    out.width = this._width;\n    out.height = this._height;\n    return out;\n  }\n  /**\n   * @private\n   */\n  updateBounds() {\n    const bounds = this._bounds;\n    const anchor = this._anchor;\n    const width = this._width;\n    const height = this._height;\n    bounds.minX = -anchor._x * width;\n    bounds.maxX = bounds.minX + width;\n    bounds.minY = -anchor._y * height;\n    bounds.maxY = bounds.minY + height;\n  }\n  /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */\n  containsPoint(point) {\n    const width = this._width;\n    const height = this._height;\n    const x1 = -width * this._anchor._x;\n    let y1 = 0;\n    if (point.x >= x1 && point.x <= x1 + width) {\n      y1 = -height * this._anchor._y;\n      if (point.y >= y1 && point.y <= y1 + height) return true;\n    }\n    return false;\n  }\n  /**\n   * Destroys this sprite renderable and optionally its texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n   */\n  destroy(options = false) {\n    super.destroy(options);\n    this._anchor = null;\n    this._tileTransform = null;\n    this._bounds = null;\n    const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n      this._texture.destroy(destroyTextureSource);\n    }\n    this._texture = null;\n  }\n};\n/** default options for the TilingSprite */\n_TilingSprite.defaultOptions = {\n  /** The texture to use for the sprite. */\n  texture: Texture.EMPTY,\n  /** The anchor point of the sprite */\n  anchor: {\n    x: 0,\n    y: 0\n  },\n  /** The offset of the image that is being tiled. */\n  tilePosition: {\n    x: 0,\n    y: 0\n  },\n  /** Scaling of the image that is being tiled. */\n  tileScale: {\n    x: 1,\n    y: 1\n  },\n  /** The rotation of the image that is being tiled. */\n  tileRotation: 0,\n  /**\n   * Flags whether the tiling pattern should originate from the origin instead of the top-left corner in\n   * local space.\n   *\n   * This will make the texture coordinates assigned to each vertex dependent on the value of the anchor. Without\n   * this, the top-left corner always gets the (0, 0) texture coordinate.\n   * @default false\n   */\n  applyAnchorToTexture: false\n};\nlet TilingSprite = _TilingSprite;\nexport { TilingSprite };","map":{"version":3,"names":["_TilingSprite","ViewContainer","constructor","args","options","Texture","texture","length","deprecation","v8_0_0","width","height","defaultOptions","anchor","tilePosition","tileScale","tileRotation","applyAnchorToTexture","roundPixels","rest","label","renderPipeId","batched","allowChildren","_anchor","ObservablePoint","_onUpdate","onViewUpdate","_width","_height","_tileTransform","Transform","observer","from","source","Cache","get","uvRespectAnchor","warn","value","clampMargin","_texture","textureMatrix","set","copyFrom","position","scale","rotation","tileTransform","EMPTY","currentTexture","dynamic","off","on","setSize","getSize","out","updateBounds","bounds","_bounds","minX","_x","maxX","minY","_y","maxY","containsPoint","point","x1","y1","x","y","destroy","destroyTexture","destroyTextureSource","textureSource","TilingSprite"],"sources":["C:\\Users\\emalv\\OneDrive\\Desktop\\Portafolio\\cv-ciudad\\node_modules\\pixi.js\\src\\scene\\sprite-tiling\\TilingSprite.ts"],"sourcesContent":["import { Cache } from '../../assets/cache/Cache';\nimport { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { warn } from '../../utils/logging/warn';\nimport { Transform } from '../../utils/misc/Transform';\nimport { ViewContainer, type ViewContainerOptions } from '../view/ViewContainer';\n\nimport type { Size } from '../../maths/misc/Size';\nimport type { PointData } from '../../maths/point/PointData';\nimport type { Instruction } from '../../rendering/renderers/shared/instructions/Instruction';\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { Optional } from '../container/container-mixins/measureMixin';\nimport type { DestroyOptions } from '../container/destroyTypes';\n\n/**\n * Constructor options used for `TilingSprite` instances. Extends {@link scene.TilingSpriteViewOptions}\n * ```js\n * const tilingSprite = new TilingSprite({\n *    texture: Texture.from('assets/image.png'),\n *    width: 100,\n *    height: 100,\n *    tilePosition: { x: 100, y: 100 },\n *    tileScale: { x: 2, y: 2 },\n * });\n * ```\n * @see {@link scene.TilingSprite}\n * @see {@link scene.TilingSpriteViewOptions}\n * @memberof scene\n */\nexport interface TilingSpriteOptions extends PixiMixins.TilingSpriteOptions, ViewContainerOptions\n{\n    /**\n     * The anchor point of the sprite\n     * @default {x: 0, y: 0}\n     */\n    anchor?: PointData | number;\n    /**\n     * The offset of the image that is being tiled.\n     * @default {x: 0, y: 0}\n     */\n    tilePosition?: PointData\n    /**\n     * Scaling of the image that is being tiled.\n     * @default {x: 1, y: 1}\n     */\n    tileScale?: PointData\n    /**\n     * The rotation of the image that is being tiled.\n     * @default 0\n     */\n    tileRotation?: number\n    /**\n     * The texture to use for the sprite.\n     * @default Texture.WHITE\n     */\n    texture?: Texture\n    /**\n     * The width of the tiling sprite. #\n     * @default 256\n     */\n    width?: number\n    /**\n     * The height of the tiling sprite.\n     * @default 256\n     */\n    height?: number\n    // TODO needs a better name..\n    /**\n     * @todo\n     * @default false\n     */\n    applyAnchorToTexture?: boolean\n    /** Whether or not to round the x/y position. */\n    roundPixels?: boolean;\n}\nexport interface TilingSprite extends PixiMixins.TilingSprite, ViewContainer {}\n\n/**\n * A tiling sprite is a fast way of rendering a tiling image.\n * @example\n * const tilingSprite = new TilingSprite({\n *    texture: Texture.from('assets/image.png'),\n *    width: 100,\n *    height: 100,\n * });\n *\n * tilingSprite.tilePosition.x = 100;\n * tilingSprite.tilePosition.y = 100;\n *\n * app.stage.addChild(tilingSprite);\n * @memberof scene\n * @extends scene.Container\n */\nexport class TilingSprite extends ViewContainer implements View, Instruction\n{\n    /**\n     * Creates a new tiling sprite.\n     * @param source - The source to create the texture from.\n     * @param options - The options for creating the tiling sprite.\n     * @returns A new tiling sprite.\n     */\n    public static from(source: Texture | string, options: TilingSpriteOptions = {})\n    {\n        if (typeof source === 'string')\n        {\n            return new TilingSprite({\n                texture: Cache.get(source),\n                ...options,\n            });\n        }\n\n        return new TilingSprite({\n            texture: source,\n            ...options,\n        });\n    }\n\n    /** default options for the TilingSprite */\n    public static defaultOptions: TilingSpriteOptions = {\n        /** The texture to use for the sprite. */\n        texture: Texture.EMPTY,\n        /** The anchor point of the sprite */\n        anchor: { x: 0, y: 0 },\n        /** The offset of the image that is being tiled. */\n        tilePosition: { x: 0, y: 0 },\n        /** Scaling of the image that is being tiled. */\n        tileScale: { x: 1, y: 1 },\n        /** The rotation of the image that is being tiled. */\n        tileRotation: 0,\n        /**\n         * Flags whether the tiling pattern should originate from the origin instead of the top-left corner in\n         * local space.\n         *\n         * This will make the texture coordinates assigned to each vertex dependent on the value of the anchor. Without\n         * this, the top-left corner always gets the (0, 0) texture coordinate.\n         * @default false\n         */\n        applyAnchorToTexture: false,\n    };\n\n    public override readonly renderPipeId: string = 'tilingSprite';\n    public readonly batched = true;\n\n    /**\n     * Flags whether the tiling pattern should originate from the origin instead of the top-left corner in\n     * local space.\n     *\n     * This will make the texture coordinates assigned to each vertex dependent on the value of the anchor. Without\n     * this, the top-left corner always gets the (0, 0) texture coordinate.\n     * @default false\n     */\n    public applyAnchorToTexture: boolean;\n    /**\n     * @see {@link scene.TilingSpriteOptions.applyAnchorToTexture}\n     * @deprecated since 8.0.0\n     */\n    public get uvRespectAnchor(): boolean\n    {\n        warn('uvRespectAnchor is deprecated, please use applyAnchorToTexture instead');\n\n        return this.applyAnchorToTexture;\n    }\n    public set uvRespectAnchor(value: boolean)\n    {\n        warn('uvRespectAnchor is deprecated, please use applyAnchorToTexture instead');\n        this.applyAnchorToTexture = value;\n    }\n    public _anchor: ObservablePoint;\n\n    public _tileTransform: Transform;\n    public _texture: Texture;\n\n    private _width: number;\n    private _height: number;\n\n    /**\n     * @param {rendering.Texture | scene.TilingSpriteOptions} options - The options for creating the tiling sprite.\n     */\n    constructor(options?: Texture | TilingSpriteOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(texture: Texture, width: number, height: number);\n    constructor(...args: [(Texture | TilingSpriteOptions)?] | [Texture, number, number])\n    {\n        let options = args[0] || {};\n\n        if (options instanceof Texture)\n        {\n            options = { texture: options };\n        }\n\n        if (args.length > 1)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'use new TilingSprite({ texture, width:100, height:100 }) instead');\n            // #endif\n\n            options.width = args[1];\n            options.height = args[2];\n        }\n\n        options = { ...TilingSprite.defaultOptions, ...options };\n\n        const {\n            texture,\n            anchor,\n            tilePosition,\n            tileScale,\n            tileRotation,\n            width,\n            height,\n            applyAnchorToTexture,\n            roundPixels,\n            ...rest\n        } = options ?? {};\n\n        super({\n\n            label: 'TilingSprite',\n            ...rest\n        });\n\n        this.allowChildren = false;\n\n        this._anchor = new ObservablePoint(\n            {\n                _onUpdate: () =>\n                {\n                    this.onViewUpdate();\n                }\n            },\n        );\n\n        this.applyAnchorToTexture = applyAnchorToTexture;\n\n        this.texture = texture;\n        this._width = width ?? texture.width;\n        this._height = height ?? texture.height;\n\n        this._tileTransform = new Transform({\n            observer: {\n                _onUpdate: () => this.onViewUpdate(),\n            }\n        });\n\n        if (anchor) this.anchor = anchor;\n        this.tilePosition = tilePosition;\n        this.tileScale = tileScale;\n        this.tileRotation = tileRotation;\n\n        this.roundPixels = roundPixels ?? false;\n    }\n\n    /**\n     * Changes frame clamping in corresponding textureMatrix\n     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n     * @default 0.5\n     * @member {number}\n     */\n    get clampMargin()\n    {\n        return this._texture.textureMatrix.clampMargin;\n    }\n\n    set clampMargin(value: number)\n    {\n        this._texture.textureMatrix.clampMargin = value;\n    }\n\n    /**\n     * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n     * and passed to the constructor.\n     *\n     * The default is `(0,0)`, this means the sprite's origin is the top left.\n     *\n     * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n     *\n     * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n     *\n     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n     * @example\n     * import { TilingSprite } from 'pixi.js';\n     *\n     * const sprite = new TilingSprite({texture: Texture.WHITE});\n     * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n     */\n    get anchor(): ObservablePoint\n    {\n        return this._anchor;\n    }\n\n    set anchor(value: PointData | number)\n    {\n        typeof value === 'number' ? this._anchor.set(value) : this._anchor.copyFrom(value);\n    }\n\n    /** The offset of the image that is being tiled. */\n    get tilePosition(): ObservablePoint\n    {\n        return this._tileTransform.position;\n    }\n\n    set tilePosition(value: PointData)\n    {\n        this._tileTransform.position.copyFrom(value);\n    }\n\n    /** The scaling of the image that is being tiled. */\n    get tileScale(): ObservablePoint\n    {\n        return this._tileTransform.scale;\n    }\n\n    set tileScale(value: PointData | number)\n    {\n        typeof value === 'number' ? this._tileTransform.scale.set(value) : this._tileTransform.scale.copyFrom(value);\n    }\n\n    set tileRotation(value)\n    {\n        this._tileTransform.rotation = value;\n    }\n\n    /** The rotation of the image that is being tiled. */\n    get tileRotation()\n    {\n        return this._tileTransform.rotation;\n    }\n\n    /** The transform of the image that is being tiled. */\n    get tileTransform()\n    {\n        return this._tileTransform;\n    }\n\n    set texture(value: Texture)\n    {\n        value ||= Texture.EMPTY;\n\n        const currentTexture = this._texture;\n\n        if (currentTexture === value) return;\n\n        if (currentTexture && currentTexture.dynamic) currentTexture.off('update', this.onViewUpdate, this);\n        if (value.dynamic) value.on('update', this.onViewUpdate, this);\n\n        this._texture = value;\n\n        this.onViewUpdate();\n    }\n\n    /** The texture that the sprite is using. */\n    get texture()\n    {\n        return this._texture;\n    }\n\n    /** The width of the tiling area. */\n    override set width(value: number)\n    {\n        this._width = value;\n        this.onViewUpdate();\n    }\n\n    override get width()\n    {\n        return this._width;\n    }\n\n    override set height(value: number)\n    {\n        this._height = value;\n        this.onViewUpdate();\n    }\n\n    /** The height of the tiling area. */\n    override get height()\n    {\n        return this._height;\n    }\n\n    /**\n     * Sets the size of the TilingSprite to the specified width and height.\n     * This is faster than setting the width and height separately.\n     * @param value - This can be either a number or a [Size]{@link Size} object.\n     * @param height - The height to set. Defaults to the value of `width` if not provided.\n     */\n    public override setSize(value: number | Optional<Size, 'height'>, height?: number): void\n    {\n        if (typeof value === 'object')\n        {\n            height = value.height ?? value.width;\n            value = value.width;\n        }\n\n        this._width = value;\n        this._height = height ?? value;\n\n        this.onViewUpdate();\n    }\n\n    /**\n     * Retrieves the size of the TilingSprite as a [Size]{@link Size} object.\n     * This is faster than get the width and height separately.\n     * @param out - Optional object to store the size in.\n     * @returns - The size of the TilingSprite.\n     */\n    public override getSize(out?: Size): Size\n    {\n        out ||= {} as Size;\n        out.width = this._width;\n        out.height = this._height;\n\n        return out;\n    }\n\n    /**\n     * @private\n     */\n    protected override updateBounds()\n    {\n        const bounds = this._bounds;\n\n        const anchor = this._anchor;\n\n        const width = this._width;\n        const height = this._height;\n\n        bounds.minX = -anchor._x * width;\n        bounds.maxX = bounds.minX + width;\n\n        bounds.minY = -anchor._y * height;\n        bounds.maxY = bounds.minY + height;\n    }\n\n    /**\n     * Checks if the object contains the given point.\n     * @param point - The point to check\n     */\n    public override containsPoint(point: PointData)\n    {\n        const width = this._width;\n        const height = this._height;\n        const x1 = -width * this._anchor._x;\n        let y1 = 0;\n\n        if (point.x >= x1 && point.x <= x1 + width)\n        {\n            y1 = -height * this._anchor._y;\n\n            if (point.y >= y1 && point.y <= y1 + height) return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Destroys this sprite renderable and optionally its texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n     */\n    public override destroy(options: DestroyOptions = false)\n    {\n        super.destroy(options);\n\n        this._anchor = null;\n        this._tileTransform = null;\n        this._bounds = null;\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            this._texture.destroy(destroyTextureSource);\n        }\n\n        this._texture = null;\n    }\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}