{"ast":null,"code":"import { ExtensionType } from '../extensions/Extensions.mjs';\nimport { Matrix } from '../maths/matrix/Matrix.mjs';\nimport { Point } from '../maths/point/Point.mjs';\nimport { BindGroup } from '../rendering/renderers/gpu/shader/BindGroup.mjs';\nimport { Geometry } from '../rendering/renderers/shared/geometry/Geometry.mjs';\nimport { UniformGroup } from '../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture.mjs';\nimport { TexturePool } from '../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { RendererType } from '../rendering/renderers/types.mjs';\nimport { Bounds } from '../scene/container/bounds/Bounds.mjs';\nimport { getGlobalRenderableBounds } from '../scene/container/bounds/getRenderableBounds.mjs';\nimport { warn } from '../utils/logging/warn.mjs';\n\"use strict\";\nconst quadGeometry = new Geometry({\n  attributes: {\n    aPosition: {\n      buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      format: \"float32x2\",\n      stride: 2 * 4,\n      offset: 0\n    }\n  },\n  indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])\n});\nclass FilterSystem {\n  constructor(renderer) {\n    this._filterStackIndex = 0;\n    this._filterStack = [];\n    this._filterGlobalUniforms = new UniformGroup({\n      uInputSize: {\n        value: new Float32Array(4),\n        type: \"vec4<f32>\"\n      },\n      uInputPixel: {\n        value: new Float32Array(4),\n        type: \"vec4<f32>\"\n      },\n      uInputClamp: {\n        value: new Float32Array(4),\n        type: \"vec4<f32>\"\n      },\n      uOutputFrame: {\n        value: new Float32Array(4),\n        type: \"vec4<f32>\"\n      },\n      uGlobalFrame: {\n        value: new Float32Array(4),\n        type: \"vec4<f32>\"\n      },\n      uOutputTexture: {\n        value: new Float32Array(4),\n        type: \"vec4<f32>\"\n      }\n    });\n    this._globalFilterBindGroup = new BindGroup({});\n    this.renderer = renderer;\n  }\n  /**\n   * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n   * @readonly\n   */\n  get activeBackTexture() {\n    return this._activeFilterData?.backTexture;\n  }\n  push(instruction) {\n    const renderer = this.renderer;\n    const filters = instruction.filterEffect.filters;\n    if (!this._filterStack[this._filterStackIndex]) {\n      this._filterStack[this._filterStackIndex] = this._getFilterData();\n    }\n    const filterData = this._filterStack[this._filterStackIndex];\n    this._filterStackIndex++;\n    if (filters.length === 0) {\n      filterData.skip = true;\n      return;\n    }\n    const bounds = filterData.bounds;\n    if (instruction.renderables) {\n      getGlobalRenderableBounds(instruction.renderables, bounds);\n    } else if (instruction.filterEffect.filterArea) {\n      bounds.clear();\n      bounds.addRect(instruction.filterEffect.filterArea);\n      bounds.applyMatrix(instruction.container.worldTransform);\n    } else {\n      instruction.container.getFastGlobalBounds(true, bounds);\n    }\n    if (instruction.container) {\n      const renderGroup = instruction.container.renderGroup || instruction.container.parentRenderGroup;\n      const filterFrameTransform = renderGroup.cacheToLocalTransform;\n      if (filterFrameTransform) {\n        bounds.applyMatrix(filterFrameTransform);\n      }\n    }\n    const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n    let resolution = Infinity;\n    let padding = 0;\n    let antialias = true;\n    let blendRequired = false;\n    let enabled = false;\n    let clipToViewport = true;\n    for (let i = 0; i < filters.length; i++) {\n      const filter = filters[i];\n      resolution = Math.min(resolution, filter.resolution === \"inherit\" ? colorTextureSource._resolution : filter.resolution);\n      padding += filter.padding;\n      if (filter.antialias === \"off\") {\n        antialias = false;\n      } else if (filter.antialias === \"inherit\") {\n        antialias && (antialias = colorTextureSource.antialias);\n      }\n      if (!filter.clipToViewport) {\n        clipToViewport = false;\n      }\n      const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n      if (!isCompatible) {\n        enabled = false;\n        break;\n      }\n      if (filter.blendRequired && !(renderer.backBuffer?.useBackBuffer ?? true)) {\n        warn(\"Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.\");\n        enabled = false;\n        break;\n      }\n      enabled = filter.enabled || enabled;\n      blendRequired || (blendRequired = filter.blendRequired);\n    }\n    if (!enabled) {\n      filterData.skip = true;\n      return;\n    }\n    if (clipToViewport) {\n      const viewPort = renderer.renderTarget.rootViewPort;\n      const rootResolution = renderer.renderTarget.renderTarget.resolution;\n      bounds.fitBounds(0, viewPort.width / rootResolution, 0, viewPort.height / rootResolution);\n    }\n    bounds.scale(resolution).ceil().scale(1 / resolution).pad(padding | 0);\n    if (!bounds.isPositive) {\n      filterData.skip = true;\n      return;\n    }\n    filterData.skip = false;\n    filterData.bounds = bounds;\n    filterData.blendRequired = blendRequired;\n    filterData.container = instruction.container;\n    filterData.filterEffect = instruction.filterEffect;\n    filterData.previousRenderSurface = renderer.renderTarget.renderSurface;\n    filterData.inputTexture = TexturePool.getOptimalTexture(bounds.width, bounds.height, resolution, antialias);\n    renderer.renderTarget.bind(filterData.inputTexture, true);\n    renderer.globalUniforms.push({\n      offset: bounds\n    });\n  }\n  pop() {\n    const renderer = this.renderer;\n    this._filterStackIndex--;\n    const filterData = this._filterStack[this._filterStackIndex];\n    if (filterData.skip) {\n      return;\n    }\n    this._activeFilterData = filterData;\n    const inputTexture = filterData.inputTexture;\n    const bounds = filterData.bounds;\n    let backTexture = Texture.EMPTY;\n    renderer.renderTarget.finishRenderPass();\n    if (filterData.blendRequired) {\n      const previousBounds = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null;\n      const renderTarget = renderer.renderTarget.getRenderTarget(filterData.previousRenderSurface);\n      backTexture = this.getBackTexture(renderTarget, bounds, previousBounds);\n    }\n    filterData.backTexture = backTexture;\n    const filters = filterData.filterEffect.filters;\n    this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n    this._globalFilterBindGroup.setResource(backTexture.source, 3);\n    renderer.globalUniforms.pop();\n    if (filters.length === 1) {\n      filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);\n      TexturePool.returnTexture(inputTexture);\n    } else {\n      let flip = filterData.inputTexture;\n      let flop = TexturePool.getOptimalTexture(bounds.width, bounds.height, flip.source._resolution, false);\n      let i = 0;\n      for (i = 0; i < filters.length - 1; ++i) {\n        const filter = filters[i];\n        filter.apply(this, flip, flop, true);\n        const t = flip;\n        flip = flop;\n        flop = t;\n      }\n      filters[i].apply(this, flip, filterData.previousRenderSurface, false);\n      TexturePool.returnTexture(flip);\n      TexturePool.returnTexture(flop);\n    }\n    if (filterData.blendRequired) {\n      TexturePool.returnTexture(backTexture);\n    }\n  }\n  getBackTexture(lastRenderSurface, bounds, previousBounds) {\n    const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n    const backTexture = TexturePool.getOptimalTexture(bounds.width, bounds.height, backgroundResolution, false);\n    let x = bounds.minX;\n    let y = bounds.minY;\n    if (previousBounds) {\n      x -= previousBounds.minX;\n      y -= previousBounds.minY;\n    }\n    x = Math.floor(x * backgroundResolution);\n    y = Math.floor(y * backgroundResolution);\n    const width = Math.ceil(bounds.width * backgroundResolution);\n    const height = Math.ceil(bounds.height * backgroundResolution);\n    this.renderer.renderTarget.copyToTexture(lastRenderSurface, backTexture, {\n      x,\n      y\n    }, {\n      width,\n      height\n    }, {\n      x: 0,\n      y: 0\n    });\n    return backTexture;\n  }\n  applyFilter(filter, input, output, clear) {\n    const renderer = this.renderer;\n    const filterData = this._filterStack[this._filterStackIndex];\n    const bounds = filterData.bounds;\n    const offset = Point.shared;\n    const previousRenderSurface = filterData.previousRenderSurface;\n    const isFinalTarget = previousRenderSurface === output;\n    let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n    let currentIndex = this._filterStackIndex - 1;\n    while (currentIndex > 0 && this._filterStack[currentIndex].skip) {\n      --currentIndex;\n    }\n    if (currentIndex > 0) {\n      resolution = this._filterStack[currentIndex].inputTexture.source._resolution;\n    }\n    const filterUniforms = this._filterGlobalUniforms;\n    const uniforms = filterUniforms.uniforms;\n    const outputFrame = uniforms.uOutputFrame;\n    const inputSize = uniforms.uInputSize;\n    const inputPixel = uniforms.uInputPixel;\n    const inputClamp = uniforms.uInputClamp;\n    const globalFrame = uniforms.uGlobalFrame;\n    const outputTexture = uniforms.uOutputTexture;\n    if (isFinalTarget) {\n      let lastIndex = this._filterStackIndex;\n      while (lastIndex > 0) {\n        lastIndex--;\n        const filterData2 = this._filterStack[this._filterStackIndex - 1];\n        if (!filterData2.skip) {\n          offset.x = filterData2.bounds.minX;\n          offset.y = filterData2.bounds.minY;\n          break;\n        }\n      }\n      outputFrame[0] = bounds.minX - offset.x;\n      outputFrame[1] = bounds.minY - offset.y;\n    } else {\n      outputFrame[0] = 0;\n      outputFrame[1] = 0;\n    }\n    outputFrame[2] = input.frame.width;\n    outputFrame[3] = input.frame.height;\n    inputSize[0] = input.source.width;\n    inputSize[1] = input.source.height;\n    inputSize[2] = 1 / inputSize[0];\n    inputSize[3] = 1 / inputSize[1];\n    inputPixel[0] = input.source.pixelWidth;\n    inputPixel[1] = input.source.pixelHeight;\n    inputPixel[2] = 1 / inputPixel[0];\n    inputPixel[3] = 1 / inputPixel[1];\n    inputClamp[0] = 0.5 * inputPixel[2];\n    inputClamp[1] = 0.5 * inputPixel[3];\n    inputClamp[2] = input.frame.width * inputSize[2] - 0.5 * inputPixel[2];\n    inputClamp[3] = input.frame.height * inputSize[3] - 0.5 * inputPixel[3];\n    const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n    globalFrame[0] = offset.x * resolution;\n    globalFrame[1] = offset.y * resolution;\n    globalFrame[2] = rootTexture.source.width * resolution;\n    globalFrame[3] = rootTexture.source.height * resolution;\n    const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n    renderer.renderTarget.bind(output, !!clear);\n    if (output instanceof Texture) {\n      outputTexture[0] = output.frame.width;\n      outputTexture[1] = output.frame.height;\n    } else {\n      outputTexture[0] = renderTarget.width;\n      outputTexture[1] = renderTarget.height;\n    }\n    outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n    filterUniforms.update();\n    if (renderer.renderPipes.uniformBatch) {\n      const batchUniforms = renderer.renderPipes.uniformBatch.getUboResource(filterUniforms);\n      this._globalFilterBindGroup.setResource(batchUniforms, 0);\n    } else {\n      this._globalFilterBindGroup.setResource(filterUniforms, 0);\n    }\n    this._globalFilterBindGroup.setResource(input.source, 1);\n    this._globalFilterBindGroup.setResource(input.source.style, 2);\n    filter.groups[0] = this._globalFilterBindGroup;\n    renderer.encoder.draw({\n      geometry: quadGeometry,\n      shader: filter,\n      state: filter._state,\n      topology: \"triangle-list\"\n    });\n    if (renderer.type === RendererType.WEBGL) {\n      renderer.renderTarget.finishRenderPass();\n    }\n  }\n  _getFilterData() {\n    return {\n      skip: false,\n      inputTexture: null,\n      bounds: new Bounds(),\n      container: null,\n      filterEffect: null,\n      blendRequired: false,\n      previousRenderSurface: null\n    };\n  }\n  /**\n   * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n   *\n   * Use `outputMatrix * vTextureCoord` in the shader.\n   * @param outputMatrix - The matrix to output to.\n   * @param {Sprite} sprite - The sprite to map to.\n   * @returns The mapped matrix.\n   */\n  calculateSpriteMatrix(outputMatrix, sprite) {\n    const data = this._activeFilterData;\n    const mappedMatrix = outputMatrix.set(data.inputTexture._source.width, 0, 0, data.inputTexture._source.height, data.bounds.minX, data.bounds.minY);\n    const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);\n    const renderGroup = sprite.renderGroup || sprite.parentRenderGroup;\n    if (renderGroup && renderGroup.cacheToLocalTransform) {\n      worldTransform.prepend(renderGroup.cacheToLocalTransform);\n    }\n    worldTransform.invert();\n    mappedMatrix.prepend(worldTransform);\n    mappedMatrix.scale(1 / sprite.texture.frame.width, 1 / sprite.texture.frame.height);\n    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n    return mappedMatrix;\n  }\n}\n/** @ignore */\nFilterSystem.extension = {\n  type: [ExtensionType.WebGLSystem, ExtensionType.WebGPUSystem],\n  name: \"filter\"\n};\nexport { FilterSystem };","map":{"version":3,"names":["quadGeometry","Geometry","attributes","aPosition","buffer","Float32Array","format","stride","offset","indexBuffer","Uint32Array","FilterSystem","constructor","renderer","_filterStackIndex","_filterStack","_filterGlobalUniforms","UniformGroup","uInputSize","value","type","uInputPixel","uInputClamp","uOutputFrame","uGlobalFrame","uOutputTexture","_globalFilterBindGroup","BindGroup","activeBackTexture","_activeFilterData","backTexture","push","instruction","filters","filterEffect","_getFilterData","filterData","length","skip","bounds","renderables","getGlobalRenderableBounds","filterArea","clear","addRect","applyMatrix","container","worldTransform","getFastGlobalBounds","renderGroup","parentRenderGroup","filterFrameTransform","cacheToLocalTransform","colorTextureSource","renderTarget","colorTexture","source","resolution","Infinity","padding","antialias","blendRequired","enabled","clipToViewport","i","filter","Math","min","_resolution","isCompatible","compatibleRenderers","backBuffer","useBackBuffer","warn","viewPort","rootViewPort","rootResolution","fitBounds","width","height","scale","ceil","pad","isPositive","previousRenderSurface","renderSurface","inputTexture","TexturePool","getOptimalTexture","bind","globalUniforms","pop","Texture","EMPTY","finishRenderPass","previousBounds","getRenderTarget","getBackTexture","setResource","style","apply","returnTexture","flip","flop","t","lastRenderSurface","backgroundResolution","x","minX","y","minY","floor","copyToTexture","applyFilter","input","output","Point","shared","isFinalTarget","rootRenderTarget","currentIndex","filterUniforms","uniforms","outputFrame","inputSize","inputPixel","inputClamp","globalFrame","outputTexture","lastIndex","filterData2","frame","pixelWidth","pixelHeight","rootTexture","isRoot","update","renderPipes","uniformBatch","batchUniforms","getUboResource","groups","encoder","draw","geometry","shader","state","_state","topology","RendererType","WEBGL","Bounds","calculateSpriteMatrix","outputMatrix","sprite","data","mappedMatrix","set","_source","copyTo","Matrix","prepend","invert","texture","translate","anchor","extension","ExtensionType","WebGLSystem","WebGPUSystem","name"],"sources":["C:\\Users\\emalv\\OneDrive\\Desktop\\Portafolio\\cv-ciudad\\node_modules\\pixi.js\\src\\filters\\FilterSystem.ts"],"sourcesContent":["import { ExtensionType } from '../extensions/Extensions';\nimport { Matrix } from '../maths/matrix/Matrix';\nimport { Point } from '../maths/point/Point';\nimport { BindGroup } from '../rendering/renderers/gpu/shader/BindGroup';\nimport { Geometry } from '../rendering/renderers/shared/geometry/Geometry';\nimport { UniformGroup } from '../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport { TexturePool } from '../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer, RendererType } from '../rendering/renderers/types';\nimport { Bounds } from '../scene/container/bounds/Bounds';\nimport { getGlobalRenderableBounds } from '../scene/container/bounds/getRenderableBounds';\nimport { warn } from '../utils/logging/warn';\n\nimport type { WebGLRenderer } from '../rendering/renderers/gl/WebGLRenderer';\nimport type { WebGPURenderer } from '../rendering/renderers/gpu/WebGPURenderer';\nimport type { Instruction } from '../rendering/renderers/shared/instructions/Instruction';\nimport type { Renderable } from '../rendering/renderers/shared/Renderable';\nimport type { RenderTarget } from '../rendering/renderers/shared/renderTarget/RenderTarget';\nimport type { RenderSurface } from '../rendering/renderers/shared/renderTarget/RenderTargetSystem';\nimport type { System } from '../rendering/renderers/shared/system/System';\nimport type { Container } from '../scene/container/Container';\nimport type { Sprite } from '../scene/sprite/Sprite';\nimport type { Filter } from './Filter';\nimport type { FilterEffect } from './FilterEffect';\n\ntype FilterAction = 'pushFilter' | 'popFilter';\n\n//\nconst quadGeometry = new Geometry({\n    attributes: {\n        aPosition: {\n            buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            format: 'float32x2',\n            stride: 2 * 4,\n            offset: 0,\n        },\n    },\n    indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3]),\n});\n\n/**\n * The filter pipeline is responsible for applying filters scene items!\n *\n * KNOWN BUGS:\n * 1. Global bounds calculation is incorrect if it is used when flip flopping filters. The maths can be found below\n * eg: filters [noiseFilter, blurFilter] noiseFilter will calculate the global bounds incorrectly.\n *\n * 2. RenderGroups do not work with filters. This is because the renderGroup matrix is not currently taken into account.\n *\n * Implementation notes:\n * 1. Gotcha - nesting filters that require blending will not work correctly. This creates a chicken and egg problem\n * the complexity and performance required to do this is not worth it i feel.. but lets see if others agree!\n *\n * 2. Filters are designed to be changed on the fly, this is means that changing filter information each frame will\n * not trigger an instruction rebuild. If you are constantly turning a filter on and off.. its therefore better to set\n * enabled to true or false on the filter. Or setting an empty array.\n *\n * 3. Need to look at perhaps aliasing when flip flopping filters. Really we should only need to antialias the FIRST\n * Texture we render too. The rest can be non aliased. This might help performance.\n * Currently we flip flop with an antialiased texture if antialiasing is enabled on the filter.\n */\nexport interface FilterInstruction extends Instruction\n{\n    renderPipeId: 'filter',\n    action: FilterAction,\n    container?: Container,\n    renderables?: Renderable[],\n    filterEffect: FilterEffect,\n}\n\nexport interface FilterData\n{\n    skip: boolean;\n    enabledLength?: number;\n    inputTexture: Texture\n    bounds: Bounds,\n    blendRequired: boolean,\n    container: Container,\n    filterEffect: FilterEffect,\n    previousRenderSurface: RenderSurface,\n    backTexture?: Texture,\n}\n\n/**\n * System that manages the filter pipeline\n * @memberof rendering\n */\nexport class FilterSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'filter',\n    } as const;\n\n    public readonly renderer: Renderer;\n\n    private _filterStackIndex = 0;\n    private _filterStack: FilterData[] = [];\n\n    private readonly _filterGlobalUniforms = new UniformGroup({\n        uInputSize: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputPixel: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputClamp: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uGlobalFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputTexture: { value: new Float32Array(4), type: 'vec4<f32>' },\n    });\n\n    private readonly _globalFilterBindGroup: BindGroup = new BindGroup({});\n    private _activeFilterData: FilterData;\n\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n     * @readonly\n     */\n    public get activeBackTexture(): Texture | undefined\n    {\n        return this._activeFilterData?.backTexture;\n    }\n\n    public push(instruction: FilterInstruction)\n    {\n        const renderer = this.renderer;\n\n        const filters = instruction.filterEffect.filters;\n\n        if (!this._filterStack[this._filterStackIndex])\n        {\n            this._filterStack[this._filterStackIndex] = this._getFilterData();\n        }\n\n        // get a filter data from the stack. They can be reused multiple times each frame,\n        // so we don't need to worry about overwriting them in a single pass.\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        this._filterStackIndex++;\n\n        // if there are no filters, we skip the pass\n        if (filters.length === 0)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        const bounds: Bounds = filterData.bounds;\n\n        // this path is used by the blend modes mostly!\n        // they collect all renderables and push them into a list.\n        // this list is then used to calculate the bounds of the filter area\n        if (instruction.renderables)\n        {\n            getGlobalRenderableBounds(instruction.renderables, bounds);\n        }\n        // if a filterArea is provided, we save our selves some measuring and just use that area supplied\n        else if (instruction.filterEffect.filterArea)\n        {\n            bounds.clear();\n\n            // transform the filterArea into global space..\n            bounds.addRect(instruction.filterEffect.filterArea);\n\n            // new for v8, we transform the bounds into the space of the container\n            bounds.applyMatrix(instruction.container.worldTransform);\n        }\n        // classic filter path, we get the bounds of the container and use it by recursively\n        // measuring.\n        else\n        {\n            // we want to factor render layers to get the real visual bounds of this container.\n            // so the last param is true..\n            instruction.container.getFastGlobalBounds(true, bounds);\n        }\n\n        if (instruction.container)\n        {\n            // When a container is cached as a texture, its filters need to be applied relative to its\n            // cached parent's coordinate space rather than world space. This transform adjustment ensures\n            // filters are applied in the correct coordinate system.\n            const renderGroup = instruction.container.renderGroup || instruction.container.parentRenderGroup;\n            const filterFrameTransform = renderGroup.cacheToLocalTransform;\n\n            if (filterFrameTransform)\n            {\n                bounds.applyMatrix(filterFrameTransform);\n            }\n        }\n\n        // get GLOBAL bounds of the item we are going to apply the filter to\n\n        const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n\n        // next we get the settings for the filter\n        // we need to find the LOWEST resolution for the filter list\n        let resolution = Infinity;\n        // Padding is additive to add padding to our padding\n        let padding = 0;\n        // if this is true for all filter, it should be true, and otherwise false\n        let antialias = true;\n        // true if any filter requires the previous render target\n        let blendRequired = false;\n        // true if any filter in the list is enabled\n        let enabled = false;\n        // false if any filter in the list has false\n        let clipToViewport = true;\n\n        for (let i = 0; i < filters.length; i++)\n        {\n            const filter = filters[i];\n\n            resolution = Math.min(resolution, filter.resolution === 'inherit'\n                ? colorTextureSource._resolution : filter.resolution);\n            padding += filter.padding;\n\n            if (filter.antialias === 'off')\n            {\n                antialias = false;\n            }\n            else if (filter.antialias === 'inherit')\n            {\n                antialias &&= colorTextureSource.antialias;\n            }\n\n            if (!filter.clipToViewport)\n            {\n                clipToViewport = false;\n            }\n\n            const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n\n            if (!isCompatible)\n            {\n                enabled = false;\n                break;\n            }\n\n            if (filter.blendRequired && !((renderer as WebGLRenderer).backBuffer?.useBackBuffer ?? true))\n            {\n                // #if _DEBUG\n                // eslint-disable-next-line max-len\n                warn('Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.');\n                // #endif\n\n                enabled = false;\n                break;\n            }\n\n            enabled = filter.enabled || enabled;\n            blendRequired ||= filter.blendRequired;\n        }\n\n        // if no filters are enabled lets skip!\n        if (!enabled)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // here we constrain the bounds to the viewport we will render too\n        // this should not take into account the x, y offset of the viewport - as this is\n        // handled by the viewport on the gpu.\n        if (clipToViewport)\n        {\n            const viewPort = renderer.renderTarget.rootViewPort;\n\n            const rootResolution = renderer.renderTarget.renderTarget.resolution;\n\n            bounds.fitBounds(0, viewPort.width / rootResolution, 0, viewPort.height / rootResolution);\n        }\n\n        // round the bounds to the nearest pixel\n        bounds\n            .scale(resolution)\n            .ceil()\n            .scale(1 / resolution)\n            .pad(padding | 0);\n\n        // skip if the bounds are negative or zero as this means they are\n        // not visible on the screen\n        if (!bounds.isPositive)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // set all the filter data\n        filterData.skip = false;\n\n        filterData.bounds = bounds;\n        filterData.blendRequired = blendRequired;\n        filterData.container = instruction.container;\n        filterData.filterEffect = instruction.filterEffect;\n\n        filterData.previousRenderSurface = renderer.renderTarget.renderSurface;\n\n        // bind...\n        // get a P02 texture from our pool...\n        filterData.inputTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            resolution,\n            antialias,\n        );\n\n        renderer.renderTarget.bind(filterData.inputTexture, true);\n        // set the global uniforms to take into account the bounds offset required\n\n        renderer.globalUniforms.push({\n            offset: bounds,\n        });\n    }\n\n    public pop()\n    {\n        const renderer = this.renderer;\n\n        this._filterStackIndex--;\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        // if we are skipping this filter then we just do nothing :D\n        if (filterData.skip)\n        {\n            return;\n        }\n\n        this._activeFilterData = filterData;\n\n        const inputTexture = filterData.inputTexture;\n\n        const bounds = filterData.bounds;\n\n        let backTexture = Texture.EMPTY;\n\n        renderer.renderTarget.finishRenderPass();\n\n        if (filterData.blendRequired)\n        {\n            // this actually forces the current commandQueue to render everything so far.\n            // if we don't do this, we won't be able to copy pixels for the background\n            const previousBounds = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null;\n\n            const renderTarget = renderer.renderTarget.getRenderTarget(filterData.previousRenderSurface);\n\n            backTexture = this.getBackTexture(renderTarget, bounds, previousBounds);\n        }\n\n        filterData.backTexture = backTexture;\n\n        const filters = filterData.filterEffect.filters;\n\n        // get a BufferResource from the uniformBatch.\n        // this will batch the shader uniform data and give us a buffer resource we can\n        // set on our globalUniform Bind Group\n\n        // update the resources on the bind group...\n        this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n        this._globalFilterBindGroup.setResource(backTexture.source, 3);\n\n        renderer.globalUniforms.pop();\n\n        if (filters.length === 1)\n        {\n            // render a single filter...\n            // this.applyFilter(filters[0], inputTexture, filterData.previousRenderSurface, false);\n            filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);\n\n            // return the texture to the pool so we can reuse the next frame\n            TexturePool.returnTexture(inputTexture);\n        }\n        else\n        {\n            let flip = filterData.inputTexture;\n\n            // get another texture that we will render the next filter too\n            let flop = TexturePool.getOptimalTexture(\n                bounds.width,\n                bounds.height,\n                flip.source._resolution,\n                false\n            );\n\n            let i = 0;\n\n            // loop and apply the filters, omitting the last one as we will render that to the final target\n            for (i = 0; i < filters.length - 1; ++i)\n            {\n                const filter = filters[i];\n\n                filter.apply(this, flip, flop, true);\n                const t = flip;\n\n                flip = flop;\n                flop = t;\n            }\n\n            filters[i].apply(this, flip, filterData.previousRenderSurface, false);\n\n            // return those textures for later!\n            TexturePool.returnTexture(flip);\n            TexturePool.returnTexture(flop);\n        }\n\n        // if we made a background texture, lets return that also\n        if (filterData.blendRequired)\n        {\n            TexturePool.returnTexture(backTexture);\n        }\n    }\n\n    public getBackTexture(lastRenderSurface: RenderTarget, bounds: Bounds, previousBounds?: Bounds)\n    {\n        const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n\n        const backTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            backgroundResolution,\n            false,\n        );\n\n        let x = bounds.minX;\n        let y = bounds.minY;\n\n        if (previousBounds)\n        {\n            x -= previousBounds.minX;\n            y -= previousBounds.minY;\n        }\n\n        x = Math.floor(x * backgroundResolution);\n        y = Math.floor(y * backgroundResolution);\n\n        const width = Math.ceil(bounds.width * backgroundResolution);\n        const height = Math.ceil(bounds.height * backgroundResolution);\n\n        this.renderer.renderTarget.copyToTexture(\n            lastRenderSurface,\n            backTexture,\n            { x, y },\n            { width, height },\n            { x: 0, y: 0 }\n        );\n\n        return backTexture;\n    }\n\n    public applyFilter(filter: Filter, input: Texture, output: RenderSurface, clear: boolean)\n    {\n        const renderer = this.renderer;\n\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        const bounds = filterData.bounds;\n\n        const offset = Point.shared;\n        const previousRenderSurface = filterData.previousRenderSurface;\n\n        const isFinalTarget = previousRenderSurface === output;\n\n        let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n\n        // to find the previous resolution we need to account for the skipped filters\n        // the following will find the last non skipped filter...\n        let currentIndex = this._filterStackIndex - 1;\n\n        while (currentIndex > 0 && this._filterStack[currentIndex].skip)\n        {\n            --currentIndex;\n        }\n\n        if (currentIndex > 0)\n        {\n            resolution = this._filterStack[currentIndex].inputTexture.source._resolution;\n        }\n\n        const filterUniforms = this._filterGlobalUniforms;\n        const uniforms = filterUniforms.uniforms;\n\n        const outputFrame = uniforms.uOutputFrame;\n        const inputSize = uniforms.uInputSize;\n        const inputPixel = uniforms.uInputPixel;\n        const inputClamp = uniforms.uInputClamp;\n        const globalFrame = uniforms.uGlobalFrame;\n        const outputTexture = uniforms.uOutputTexture;\n\n        // are we rendering back to the original surface?\n        if (isFinalTarget)\n        {\n            let lastIndex = this._filterStackIndex;\n\n            // get previous bounds.. we must take into account skipped filters also..\n            while (lastIndex > 0)\n            {\n                lastIndex--;\n                const filterData = this._filterStack[this._filterStackIndex - 1];\n\n                if (!filterData.skip)\n                {\n                    offset.x = filterData.bounds.minX;\n                    offset.y = filterData.bounds.minY;\n\n                    break;\n                }\n            }\n\n            outputFrame[0] = bounds.minX - offset.x;\n            outputFrame[1] = bounds.minY - offset.y;\n        }\n        else\n        {\n            outputFrame[0] = 0;\n            outputFrame[1] = 0;\n        }\n\n        outputFrame[2] = input.frame.width;\n        outputFrame[3] = input.frame.height;\n\n        inputSize[0] = input.source.width;\n        inputSize[1] = input.source.height;\n        inputSize[2] = 1 / inputSize[0];\n        inputSize[3] = 1 / inputSize[1];\n\n        inputPixel[0] = input.source.pixelWidth;\n        inputPixel[1] = input.source.pixelHeight;\n        inputPixel[2] = 1.0 / inputPixel[0];\n        inputPixel[3] = 1.0 / inputPixel[1];\n\n        inputClamp[0] = 0.5 * inputPixel[2];\n        inputClamp[1] = 0.5 * inputPixel[3];\n        inputClamp[2] = (input.frame.width * inputSize[2]) - (0.5 * inputPixel[2]);\n        inputClamp[3] = (input.frame.height * inputSize[3]) - (0.5 * inputPixel[3]);\n\n        const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n\n        globalFrame[0] = offset.x * resolution;\n        globalFrame[1] = offset.y * resolution;\n\n        globalFrame[2] = rootTexture.source.width * resolution;\n        globalFrame[3] = rootTexture.source.height * resolution;\n\n        // set the output texture - this is where we are going to render to\n\n        const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n\n        renderer.renderTarget.bind(output, !!clear);\n\n        if (output instanceof Texture)\n        {\n            outputTexture[0] = output.frame.width;\n            outputTexture[1] = output.frame.height;\n        }\n        else\n        {\n            // this means a renderTarget was passed directly\n            outputTexture[0] = renderTarget.width;\n            outputTexture[1] = renderTarget.height;\n        }\n\n        outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n        filterUniforms.update();\n\n        // TODO - should prolly use a adaptor...\n        if ((renderer as WebGPURenderer).renderPipes.uniformBatch)\n        {\n            const batchUniforms = (renderer as WebGPURenderer).renderPipes.uniformBatch\n                .getUboResource(filterUniforms);\n\n            this._globalFilterBindGroup.setResource(batchUniforms, 0);\n        }\n        else\n        {\n            this._globalFilterBindGroup.setResource(filterUniforms, 0);\n        }\n\n        // now lets update the output texture...\n\n        // set bind group..\n        this._globalFilterBindGroup.setResource(input.source, 1);\n        this._globalFilterBindGroup.setResource(input.source.style, 2);\n\n        filter.groups[0] = this._globalFilterBindGroup;\n\n        renderer.encoder.draw({\n            geometry: quadGeometry,\n            shader: filter,\n            state: filter._state,\n            topology: 'triangle-list'\n        });\n\n        // WebGPU blit's automatically, but WebGL does not!\n        if (renderer.type === RendererType.WEBGL)\n        {\n            renderer.renderTarget.finishRenderPass();\n        }\n    }\n\n    private _getFilterData(): FilterData\n    {\n        return {\n            skip: false,\n            inputTexture: null,\n            bounds: new Bounds(),\n            container: null,\n            filterEffect: null,\n            blendRequired: false,\n            previousRenderSurface: null,\n        };\n    }\n\n    /**\n     * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n     *\n     * Use `outputMatrix * vTextureCoord` in the shader.\n     * @param outputMatrix - The matrix to output to.\n     * @param {Sprite} sprite - The sprite to map to.\n     * @returns The mapped matrix.\n     */\n    public calculateSpriteMatrix(outputMatrix: Matrix, sprite: Sprite): Matrix\n    {\n        const data = this._activeFilterData;\n\n        const mappedMatrix = outputMatrix.set(\n            data.inputTexture._source.width,\n            0, 0,\n            data.inputTexture._source.height,\n            data.bounds.minX, data.bounds.minY\n        );\n\n        const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);\n\n        const renderGroup = sprite.renderGroup || sprite.parentRenderGroup;\n\n        if (renderGroup && renderGroup.cacheToLocalTransform)\n        {\n            // get the matrix relative to the render group..\n            worldTransform.prepend(renderGroup.cacheToLocalTransform);\n        }\n\n        worldTransform.invert();\n        mappedMatrix.prepend(worldTransform);\n        mappedMatrix.scale(\n            1.0 / sprite.texture.frame.width,\n            1.0 / sprite.texture.frame.height\n        );\n\n        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n\n        return mappedMatrix;\n    }\n\n    public destroy?: () => void;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}