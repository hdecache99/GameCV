{"ast":null,"code":"import { warn } from '../../utils/logging/warn.mjs';\nimport { Container } from '../container/Container.mjs';\n\"use strict\";\nconst _RenderLayerClass = class _RenderLayerClass extends Container {\n  /**\n   * Creates a new RenderLayer instance\n   * @param options - Configuration options for the RenderLayer\n   * @param {boolean} [options.sortableChildren=false] - If true, layer children will be automatically sorted each render\n   * @param {Function} [options.sortFunction] - Custom function to sort layer children. Default sorts by zIndex\n   */\n  constructor(options = {}) {\n    options = {\n      ..._RenderLayerClass.defaultOptions,\n      ...options\n    };\n    super();\n    /** List of objects to be rendered by this layer */\n    this.renderLayerChildren = [];\n    this.sortableChildren = options.sortableChildren;\n    this.sortFunction = options.sortFunction;\n  }\n  /**\n   * Add an Container to this render layer. The Container will be rendered as part of this layer\n   * while maintaining its original parent in the scene graph.\n   * If the Container already belongs to a layer, it will be removed from the old layer before being added to this one.\n   * @param children - The Container(s) to add to this layer\n   */\n  attach(...children) {\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if (child.parentRenderLayer) {\n        if (child.parentRenderLayer === this) continue;\n        child.parentRenderLayer.detach(child);\n      }\n      this.renderLayerChildren.push(child);\n      child.parentRenderLayer = this;\n      const renderGroup = this.renderGroup || this.parentRenderGroup;\n      if (renderGroup) {\n        renderGroup.structureDidChange = true;\n      }\n    }\n    return children[0];\n  }\n  /**\n   * Remove an Container from this render layer. The Container will no longer be rendered\n   * as part of this layer but maintains its original parent.\n   * @param children - The Container(s) to remove from this layer\n   */\n  detach(...children) {\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const index = this.renderLayerChildren.indexOf(child);\n      if (index !== -1) {\n        this.renderLayerChildren.splice(index, 1);\n      }\n      child.parentRenderLayer = null;\n      const renderGroup = this.renderGroup || this.parentRenderGroup;\n      if (renderGroup) {\n        renderGroup.structureDidChange = true;\n      }\n    }\n    return children[0];\n  }\n  /** Remove all objects from this render layer. */\n  detachAll() {\n    const layerChildren = this.renderLayerChildren;\n    for (let i = 0; i < layerChildren.length; i++) {\n      layerChildren[i].parentRenderLayer = null;\n    }\n    this.renderLayerChildren.length = 0;\n  }\n  collectRenderables(instructionSet, renderer, _currentLayer) {\n    const layerChildren = this.renderLayerChildren;\n    const length = layerChildren.length;\n    if (this.sortableChildren) {\n      this.sortRenderLayerChildren();\n    }\n    for (let i = 0; i < length; i++) {\n      if (!layerChildren[i].parent) {\n        warn(\"Container must be added to both layer and scene graph. Layers only handle render order - the scene graph is required for transforms (addChild)\", layerChildren[i]);\n      }\n      layerChildren[i].collectRenderables(instructionSet, renderer, this);\n    }\n  }\n  /**\n   * Sort the layer's children using the defined sort function.\n   * Will be called each render if sortableChildren is true.\n   * Otherwise can call this manually.\n   */\n  sortRenderLayerChildren() {\n    this.renderLayerChildren.sort(this.sortFunction);\n  }\n  _getGlobalBoundsRecursive(factorRenderLayers, bounds, _currentLayer) {\n    if (!factorRenderLayers) return;\n    const children = this.renderLayerChildren;\n    for (let i = 0; i < children.length; i++) {\n      children[i]._getGlobalBoundsRecursive(true, bounds, this);\n    }\n  }\n};\n/**\n * Default options for RenderLayer instances\n * @property {boolean} sortableChildren - If true, layer children will be automatically sorted each render.\n * Default false.\n * @property {Function} sortFunction - Function used to sort layer children. Default sorts by zIndex.\n */\n_RenderLayerClass.defaultOptions = {\n  sortableChildren: false,\n  sortFunction: (a, b) => a.zIndex - b.zIndex\n};\nlet RenderLayerClass = _RenderLayerClass;\nconst RenderLayer = RenderLayerClass;\nexport { RenderLayer, RenderLayerClass };","map":{"version":3,"names":["_RenderLayerClass","Container","constructor","options","defaultOptions","renderLayerChildren","sortableChildren","sortFunction","attach","children","i","length","child","parentRenderLayer","detach","push","renderGroup","parentRenderGroup","structureDidChange","index","indexOf","splice","detachAll","layerChildren","collectRenderables","instructionSet","renderer","_currentLayer","sortRenderLayerChildren","parent","warn","sort","_getGlobalBoundsRecursive","factorRenderLayers","bounds","a","b","zIndex","RenderLayerClass","RenderLayer"],"sources":["C:\\Users\\emalv\\OneDrive\\Desktop\\Portafolio\\cv-ciudad\\node_modules\\pixi.js\\src\\scene\\layers\\RenderLayer.ts"],"sourcesContent":["import { type InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport { type Renderer } from '../../rendering/renderers/types';\nimport { warn } from '../../utils/logging/warn';\nimport { type Bounds } from '../container/bounds/Bounds';\nimport { Container } from '../container/Container';\n\nimport type EventEmitter from 'eventemitter3';\n// TODO make it clear render layer cannot have 'filters'\n\n/**\n * Options for configuring a RenderLayer.\n * @memberof scene\n */\nexport interface RenderLayerOptions\n{\n    /**\n     * If true, the layer's children will be sorted by zIndex before rendering\n     * If false, you can manually sort the children using sortRenderLayerChildren when ever you need!\n     * @default false\n     */\n    sortableChildren?: boolean;\n\n    /**\n     * Custom sort function to sort layer children. Default sorts by zIndex.\n     * @param a - First container to compare\n     * @param b - Second container to compare\n     * @returns Negative if a should render before b, positive if b should render before a\n     */\n    sortFunction?: (a: Container, b: Container) => number;\n}\n\n/*\n * Here we are essentially hiding the Container API even though this class extends a Container.\n * This is just so it fits into the current architecture. When users use a RenderLayer,\n * the Container properties will be hidden from them, as they don't do anything in renderLayers.\n */\ntype ContainerKeys = keyof Container;\ntype PartialContainerKeys = Exclude<ContainerKeys,\n'parent' | 'didChange' | '_updateFlags' | keyof EventEmitter | 'parentRenderLayer' |\n'destroyed' | 'layerParentId' | 'sortableChildren' | 'getFastGlobalBounds'\n>;\nexport type IRenderLayer = Omit<RenderLayerClass, PartialContainerKeys>;\n\n/**\n * The RenderLayer API provides a way to control the rendering order of objects independently\n * of their logical parent-child relationships in the scene graph.\n * This allows developers to decouple how objects are transformed\n * (via their logical parent) from how they are rendered on the screen.\n *\n * ### Key Concepts\n *\n * #### RenderLayers Control Rendering Order:\n * - RenderLayers define where in the render stack objects are drawn,\n * but they do not affect an object's transformations (e.g., position, scale, rotation) or logical hierarchy.\n * - RenderLayers can be added anywhere in the scene graph.\n *\n * #### Logical Parenting Remains Unchanged:\n * - Objects still have a logical parent for transformations via addChild.\n * - Assigning an object to a layer does not reparent it.\n *\n * #### Explicit Control:\n * - Developers assign objects to layers using renderLayer.add and remove them using renderLayer.remove.\n * ---\n * ### API Details\n *\n * #### 1. Creating a RenderLayer\n * A RenderLayer is a lightweight object responsible for controlling render order.\n * It has no children or transformations of its own\n * but can be inserted anywhere in the scene graph to define its render position.\n * ```js\n * const layer = new RenderLayer();\n * app.stage.addChild(layer); // Insert the layer into the scene graph\n * ```\n *\n * #### 2. Adding Objects to a Layer\n * Use renderLayer.add to assign an object to a layer.\n * This overrides the object's default render order defined by its logical parent.\n * ```js\n * const rect = new PIXI.Graphics();\n * container.addChild(rect);    // Add to logical parent\n * layer.attach(rect);      // Control render order via the layer\n * ```\n *\n * #### 3. Removing Objects from a Layer\n * To stop an object from being rendered in the layer, use remove.\n * ```js\n * layer.remove(rect); // Stop rendering rect via the layer\n * ```\n * When an object is removed from its logical parent (removeChild), it is automatically removed from the layer.\n *\n * #### 4. Re-Adding Objects to Layers\n * If an object is re-added to a logical parent, it does not automatically reassign itself to the layer.\n * Developers must explicitly reassign it.\n * ```js\n * container.addChild(rect);    // Logical parent\n * layer.attach(rect);      // Explicitly reassign to the layer\n * ```\n *\n * #### 5. Layer Position in Scene Graph\n * A layer's position in the scene graph determines its render priority relative to other layers and objects.\n * Layers can be inserted anywhere in the scene graph.\n * ```js\n * const backgroundLayer = new RenderLayer();\n * const uiLayer = new RenderLayer();\n *\n * app.stage.addChild(backgroundLayer);\n * app.stage.addChild(world);\n * app.stage.addChild(uiLayer);\n * ```\n * This is a new API and therefore considered experimental at this stage.\n * While the core is pretty robust, there are still a few tricky issues we need to tackle.\n * However, even with the known issues below, we believe this API is incredibly useful!\n *\n * Known issues:\n *  - Interaction may not work as expected since hit testing does not account for the visual render order created by layers.\n *    For example, if an object is visually moved to the front via a layer, hit testing will still use its original position.\n *  - RenderLayers and their children must all belong to the same renderGroup to work correctly\n * @memberof scene\n * @class RenderLayer\n * @extends null\n */\nexport class RenderLayerClass extends Container\n{\n    /**\n     * Default options for RenderLayer instances\n     * @property {boolean} sortableChildren - If true, layer children will be automatically sorted each render.\n     * Default false.\n     * @property {Function} sortFunction - Function used to sort layer children. Default sorts by zIndex.\n     */\n    public static defaultOptions: RenderLayerOptions = {\n        sortableChildren: false,\n        sortFunction: (a, b) => a.zIndex - b.zIndex,\n    };\n\n    /** Function used to sort layer children if sortableChildren is true */\n    public sortFunction: (a: Container, b: Container) => number;\n\n    /** List of objects to be rendered by this layer */\n    public renderLayerChildren: Container[] = [];\n\n    /**\n     * Creates a new RenderLayer instance\n     * @param options - Configuration options for the RenderLayer\n     * @param {boolean} [options.sortableChildren=false] - If true, layer children will be automatically sorted each render\n     * @param {Function} [options.sortFunction] - Custom function to sort layer children. Default sorts by zIndex\n     */\n    constructor(options: RenderLayerOptions = {})\n    {\n        options = { ...RenderLayerClass.defaultOptions, ...options };\n\n        super();\n\n        this.sortableChildren = options.sortableChildren;\n        this.sortFunction = options.sortFunction;\n    }\n\n    /**\n     * Add an Container to this render layer. The Container will be rendered as part of this layer\n     * while maintaining its original parent in the scene graph.\n     * If the Container already belongs to a layer, it will be removed from the old layer before being added to this one.\n     * @param children - The Container(s) to add to this layer\n     */\n    public attach<U extends Container[]>(...children: U): U[0]\n    {\n        for (let i = 0; i < children.length; i++)\n        {\n            const child = children[i];\n\n            if (child.parentRenderLayer)\n            {\n                if (child.parentRenderLayer === this) continue;\n\n                child.parentRenderLayer.detach(child);\n            }\n\n            this.renderLayerChildren.push(child);\n\n            child.parentRenderLayer = this;\n\n            const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n            if (renderGroup)\n            {\n                renderGroup.structureDidChange = true;\n            }\n        }\n\n        return children[0];\n    }\n\n    /**\n     * Remove an Container from this render layer. The Container will no longer be rendered\n     * as part of this layer but maintains its original parent.\n     * @param children - The Container(s) to remove from this layer\n     */\n    public detach<U extends Container[]>(...children: U): U[0]\n    {\n        for (let i = 0; i < children.length; i++)\n        {\n            const child = children[i];\n\n            const index = this.renderLayerChildren.indexOf(child);\n\n            if (index !== -1)\n            {\n                this.renderLayerChildren.splice(index, 1);\n            }\n\n            child.parentRenderLayer = null;\n\n            const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n            if (renderGroup)\n            {\n                renderGroup.structureDidChange = true;\n            }\n        }\n\n        return children[0];\n    }\n\n    /** Remove all objects from this render layer. */\n    public detachAll()\n    {\n        const layerChildren = this.renderLayerChildren;\n\n        for (let i = 0; i < layerChildren.length; i++)\n        {\n            layerChildren[i].parentRenderLayer = null;\n        }\n\n        this.renderLayerChildren.length = 0;\n    }\n\n    public override collectRenderables(instructionSet: InstructionSet, renderer: Renderer, _currentLayer: RenderLayerClass\n    ): void\n    {\n        const layerChildren = this.renderLayerChildren;\n        const length = layerChildren.length;\n\n        if (this.sortableChildren)\n        {\n            this.sortRenderLayerChildren();\n        }\n\n        for (let i = 0; i < length; i++)\n        {\n            if (!layerChildren[i].parent)\n            {\n                // eslint-disable-next-line max-len\n                warn('Container must be added to both layer and scene graph. Layers only handle render order - the scene graph is required for transforms (addChild)',\n                    layerChildren[i]);\n            }\n\n            layerChildren[i].collectRenderables(instructionSet, renderer, this);\n        }\n    }\n\n    /**\n     * Sort the layer's children using the defined sort function.\n     * Will be called each render if sortableChildren is true.\n     * Otherwise can call this manually.\n     */\n    public sortRenderLayerChildren()\n    {\n        this.renderLayerChildren.sort(this.sortFunction);\n    }\n\n    public override _getGlobalBoundsRecursive(\n        factorRenderLayers: boolean,\n        bounds: Bounds,\n        _currentLayer: RenderLayerClass,\n    ): void\n    {\n        if (!factorRenderLayers) return;\n\n        const children = this.renderLayerChildren;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            children[i]._getGlobalBoundsRecursive(true, bounds, this);\n        }\n    }\n}\n\nexport const RenderLayer = RenderLayerClass as {\n    new (options?: RenderLayerOptions): IRenderLayer;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}