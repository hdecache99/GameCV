{"ast":null,"code":"import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { Bounds } from '../bounds/Bounds.mjs';\nimport { boundsPool } from '../bounds/utils/matrixAndBoundsPool.mjs';\n\"use strict\";\nconst tempMatrix = new Matrix();\nconst getFastGlobalBoundsMixin = {\n  /**\n   * Computes the global bounds for the container, considering its children and optionally\n   * factoring in render layers. It starts by clearing the provided bounds object, then\n   * recursively calculates the bounds, and finally applies the world transformation.\n   * @param {boolean} [factorRenderLayers] - Whether to consider render layers in the calculation.\n   * @param {Bounds} [bounds] - The bounds object to store the result. If not provided, a new one is created.\n   * @returns {Bounds} The computed bounds.\n   * @memberof scene.Container#\n   */\n  getFastGlobalBounds(factorRenderLayers, bounds) {\n    bounds || (bounds = new Bounds());\n    bounds.clear();\n    this._getGlobalBoundsRecursive(!!factorRenderLayers, bounds, this.parentRenderLayer);\n    if (!bounds.isValid) {\n      bounds.set(0, 0, 0, 0);\n    }\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    bounds.applyMatrix(renderGroup.worldTransform);\n    return bounds;\n  },\n  /**\n   * Recursively calculates the global bounds for the container and its children.\n   * It considers visibility, measurability, and effects, and applies transformations\n   * as necessary to compute the bounds accurately.\n   * @param {boolean} factorRenderLayers - Whether to consider render layers in the calculation.\n   * @param {Bounds} bounds - The bounds object to update with the calculated values.\n   * @param {IRenderLayer} currentLayer - The current render layer being processed.\n   * @memberof scene.Container#\n   */\n  _getGlobalBoundsRecursive(factorRenderLayers, bounds, currentLayer) {\n    let localBounds = bounds;\n    if (factorRenderLayers && this.parentRenderLayer && this.parentRenderLayer !== currentLayer) return;\n    if (this.localDisplayStatus !== 7 || !this.measurable) {\n      return;\n    }\n    const manageEffects = !!this.effects.length;\n    if (this.renderGroup || manageEffects) {\n      localBounds = boundsPool.get().clear();\n    }\n    if (this.boundsArea) {\n      bounds.addRect(this.boundsArea, this.worldTransform);\n    } else {\n      if (this.renderPipeId) {\n        const viewBounds = this.bounds;\n        localBounds.addFrame(viewBounds.minX, viewBounds.minY, viewBounds.maxX, viewBounds.maxY, this.groupTransform);\n      }\n      const children = this.children;\n      for (let i = 0; i < children.length; i++) {\n        children[i]._getGlobalBoundsRecursive(factorRenderLayers, localBounds, currentLayer);\n      }\n    }\n    if (manageEffects) {\n      let advanced = false;\n      const renderGroup = this.renderGroup || this.parentRenderGroup;\n      for (let i = 0; i < this.effects.length; i++) {\n        if (this.effects[i].addBounds) {\n          if (!advanced) {\n            advanced = true;\n            localBounds.applyMatrix(renderGroup.worldTransform);\n          }\n          this.effects[i].addBounds(localBounds, true);\n        }\n      }\n      if (advanced) {\n        localBounds.applyMatrix(renderGroup.worldTransform.copyTo(tempMatrix).invert());\n        bounds.addBounds(localBounds, this.relativeGroupTransform);\n      }\n      bounds.addBounds(localBounds);\n      boundsPool.return(localBounds);\n    } else if (this.renderGroup) {\n      bounds.addBounds(localBounds, this.relativeGroupTransform);\n      boundsPool.return(localBounds);\n    }\n  }\n};\nexport { getFastGlobalBoundsMixin };","map":{"version":3,"names":["tempMatrix","Matrix","getFastGlobalBoundsMixin","getFastGlobalBounds","factorRenderLayers","bounds","Bounds","clear","_getGlobalBoundsRecursive","parentRenderLayer","isValid","set","renderGroup","parentRenderGroup","applyMatrix","worldTransform","currentLayer","localBounds","localDisplayStatus","measurable","manageEffects","effects","length","boundsPool","get","boundsArea","addRect","renderPipeId","viewBounds","addFrame","minX","minY","maxX","maxY","groupTransform","children","i","advanced","addBounds","copyTo","invert","relativeGroupTransform","return"],"sources":["C:\\Users\\emalv\\OneDrive\\Desktop\\Portafolio\\cv-ciudad\\node_modules\\pixi.js\\src\\scene\\container\\container-mixins\\getFastGlobalBoundsMixin.ts"],"sourcesContent":["import { Matrix } from '../../../maths/matrix/Matrix';\nimport { type Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport { type IRenderLayer } from '../../layers/RenderLayer';\nimport { Bounds } from '../bounds/Bounds';\nimport { boundsPool } from '../bounds/utils/matrixAndBoundsPool';\n\nimport type { Container } from '../Container';\n\nconst tempMatrix = new Matrix();\n\n/**\n * Interface for the GetFastGlobalBoundsMixin, which provides methods to compute\n * an approximate global bounding box for a container and its children.\n */\nexport interface GetFastGlobalBoundsMixin\n{\n    /**\n     * Computes an approximate global bounding box for the container and its children.\n     * This method is optimized for speed by using axis-aligned bounding boxes (AABBs),\n     * and uses the last render results from when it updated the transforms. This function does not update them.\n     * which may result in slightly larger bounds but never smaller than the actual bounds.\n     *\n     * for accurate (but less performant) results use `container.getGlobalBounds`\n     * @param {boolean} [factorRenderLayers] - A flag indicating whether to consider render layers in the calculation.\n     * @param {Bounds} [bounds] - The output bounds object to store the result. If not provided, a new one is created.\n     * @returns {Bounds} The computed bounds.\n     * @memberof scene.Container#\n     */\n    getFastGlobalBounds(factorRenderLayers?: boolean, bounds?: Bounds): Bounds;\n\n    /**\n     * Recursively calculates the global bounds for the container and its children.\n     * This method is used internally by getFastGlobalBounds to traverse the scene graph.\n     * @param {boolean} factorRenderLayers - A flag indicating whether to consider render layers in the calculation.\n     * @param {Bounds} bounds - The bounds object to update with the calculated values.\n     * @param {IRenderLayer} currentLayer - The current render layer being processed.\n     * @memberof scene.Container#\n     */\n    _getGlobalBoundsRecursive(\n        factorRenderLayers: boolean,\n        bounds: Bounds,\n        currentLayer: IRenderLayer,\n    ): void;\n}\n\n/**\n * Mixin providing the implementation of the GetFastGlobalBoundsMixin interface.\n * It includes methods to compute and recursively calculate global bounds for containers.\n */\nexport const getFastGlobalBoundsMixin: Partial<Container> = {\n    /**\n     * Computes the global bounds for the container, considering its children and optionally\n     * factoring in render layers. It starts by clearing the provided bounds object, then\n     * recursively calculates the bounds, and finally applies the world transformation.\n     * @param {boolean} [factorRenderLayers] - Whether to consider render layers in the calculation.\n     * @param {Bounds} [bounds] - The bounds object to store the result. If not provided, a new one is created.\n     * @returns {Bounds} The computed bounds.\n     * @memberof scene.Container#\n     */\n    getFastGlobalBounds(factorRenderLayers?: boolean, bounds?: Bounds): Bounds\n    {\n        bounds ||= new Bounds();\n\n        // Initialize the bounds for fresh calculations.\n        bounds.clear();\n\n        // Calculate bounds recursively, starting from the current container.\n        this._getGlobalBoundsRecursive(!!factorRenderLayers, bounds, this.parentRenderLayer);\n\n        // Validate the calculated bounds, resetting if invalid.\n        if (!bounds.isValid)\n        {\n            bounds.set(0, 0, 0, 0);\n        }\n\n        // Apply the world transformation to the bounds.\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        bounds.applyMatrix(renderGroup.worldTransform);\n\n        return bounds;\n    },\n\n    /**\n     * Recursively calculates the global bounds for the container and its children.\n     * It considers visibility, measurability, and effects, and applies transformations\n     * as necessary to compute the bounds accurately.\n     * @param {boolean} factorRenderLayers - Whether to consider render layers in the calculation.\n     * @param {Bounds} bounds - The bounds object to update with the calculated values.\n     * @param {IRenderLayer} currentLayer - The current render layer being processed.\n     * @memberof scene.Container#\n     */\n    _getGlobalBoundsRecursive(\n        factorRenderLayers: boolean,\n        bounds: Bounds,\n        currentLayer: IRenderLayer,\n    )\n    {\n        let localBounds = bounds;\n\n        // Skip if the container is not in the current render layer when factoring render layers.\n        if (factorRenderLayers && this.parentRenderLayer && this.parentRenderLayer !== currentLayer) return;\n\n        // Skip if the container is not fully visible or not measurable.\n        if (this.localDisplayStatus !== 0b111 || (!this.measurable))\n        {\n            return;\n        }\n\n        // Determine if effects need to be managed, requiring separate bounds handling.\n        const manageEffects = !!this.effects.length;\n\n        // Use a temporary bounds object if the container is a render group or has effects.\n        if (this.renderGroup || manageEffects)\n        {\n            localBounds = boundsPool.get().clear();\n        }\n\n        // Add the container's own bounds area to the bounds if it exists.\n        if (this.boundsArea)\n        {\n            bounds.addRect(this.boundsArea, this.worldTransform);\n        }\n        else\n        {\n            // If the container is renderable, add its bounds to the local bounds.\n            if (this.renderPipeId)\n            {\n                const viewBounds = (this as Renderable).bounds;\n\n                localBounds.addFrame(\n                    viewBounds.minX,\n                    viewBounds.minY,\n                    viewBounds.maxX,\n                    viewBounds.maxY,\n                    this.groupTransform\n                );\n            }\n\n            // Recursively process each child to include their bounds.\n            const children = this.children;\n\n            for (let i = 0; i < children.length; i++)\n            {\n                children[i]._getGlobalBoundsRecursive(factorRenderLayers, localBounds, currentLayer);\n            }\n        }\n\n        // If effects are managed, apply them to the bounds.\n        if (manageEffects)\n        {\n            let advanced = false;\n            const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n            // Apply each effect that modifies bounds.\n            for (let i = 0; i < this.effects.length; i++)\n            {\n                if (this.effects[i].addBounds)\n                {\n                    if (!advanced)\n                    {\n                        advanced = true;\n                        localBounds.applyMatrix(renderGroup.worldTransform);\n                    }\n                    this.effects[i].addBounds(localBounds, true);\n                }\n            }\n\n            // Adjust bounds back to the local coordinate space if advanced bounds were calculated.\n            if (advanced)\n            {\n                localBounds.applyMatrix(renderGroup.worldTransform.copyTo(tempMatrix).invert());\n                bounds.addBounds(localBounds, this.relativeGroupTransform);\n            }\n\n            // Add the local bounds to the final bounds and return the temporary bounds object.\n            bounds.addBounds(localBounds);\n            boundsPool.return(localBounds);\n        }\n        else if (this.renderGroup)\n        {\n            // If the container is a render group, add its local bounds to the final bounds.\n            bounds.addBounds(localBounds, this.relativeGroupTransform);\n            boundsPool.return(localBounds);\n        }\n    }\n\n} as Container;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}