{"ast":null,"code":"\"use strict\";\n\nfunction updateQuadBounds(bounds, anchor, texture) {\n  const {\n    width,\n    height\n  } = texture.orig;\n  const trim = texture.trim;\n  if (trim) {\n    const sourceWidth = trim.width;\n    const sourceHeight = trim.height;\n    bounds.minX = trim.x - anchor._x * width;\n    bounds.maxX = bounds.minX + sourceWidth;\n    bounds.minY = trim.y - anchor._y * height;\n    bounds.maxY = bounds.minY + sourceHeight;\n  } else {\n    bounds.minX = -anchor._x * width;\n    bounds.maxX = bounds.minX + width;\n    bounds.minY = -anchor._y * height;\n    bounds.maxY = bounds.minY + height;\n  }\n}\nexport { updateQuadBounds };","map":{"version":3,"names":["updateQuadBounds","bounds","anchor","texture","width","height","orig","trim","sourceWidth","sourceHeight","minX","x","_x","maxX","minY","y","_y","maxY"],"sources":["C:\\Users\\emalv\\OneDrive\\Desktop\\Portafolio\\cv-ciudad\\node_modules\\pixi.js\\src\\utils\\data\\updateQuadBounds.ts"],"sourcesContent":["import type { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../../scene/container/bounds/Bounds';\n\n/**\n * Updates the bounds of a quad (a rectangular area) based on the provided texture and anchor point.\n *\n * This function calculates the minimum and maximum x and y coordinates of the bounds, taking into\n * account the texture's original dimensions and any trimming that may have been applied to it.\n * @param {BoundsData} bounds - The bounds object to be updated. It contains minX, maxX, minY, and maxY properties.\n * @param {ObservablePoint} anchor - The anchor point of the texture, which affects the positioning of the bounds.\n * @param {Texture} texture - The texture whose dimensions and trimming information are used to update the bounds.\n */\nexport function updateQuadBounds(\n    bounds: BoundsData,\n    anchor: ObservablePoint,\n    texture: Texture\n): void\n{\n    const { width, height } = texture.orig;\n    const trim = texture.trim;\n\n    // If the texture has trimming information, adjust the bounds accordingly\n    if (trim)\n    {\n        // Calculate the source width and height from the trim\n        const sourceWidth = trim.width;\n        const sourceHeight = trim.height;\n\n        // Update the bounds using the trim's x and y offsets and the anchor point\n        bounds.minX = trim.x - (anchor._x * width);\n        bounds.maxX = bounds.minX + sourceWidth;\n\n        bounds.minY = trim.y - (anchor._y * height);\n        bounds.maxY = bounds.minY + sourceHeight;\n    }\n    // If there is no trimming, calculate the bounds based solely on the texture's original dimensions\n    else\n    {\n        bounds.minX = -anchor._x * width;\n        bounds.maxX = bounds.minX + width;\n\n        bounds.minY = -anchor._y * height;\n        bounds.maxY = bounds.minY + height;\n    }\n}\n"],"mappings":";;AAagB,SAAAA,iBACZC,MACA,EAAAC,MAAA,EACAC,OAEJ;EACI,MAAM;IAAEC,KAAA;IAAOC;EAAO,IAAIF,OAAQ,CAAAG,IAAA;EAClC,MAAMC,IAAA,GAAOJ,OAAQ,CAAAI,IAAA;EAGrB,IAAIA,IACJ;IAEI,MAAMC,WAAA,GAAcD,IAAK,CAAAH,KAAA;IACzB,MAAMK,YAAA,GAAeF,IAAK,CAAAF,MAAA;IAG1BJ,MAAA,CAAOS,IAAO,GAAAH,IAAA,CAAKI,CAAK,GAAAT,MAAA,CAAOU,EAAK,GAAAR,KAAA;IAC7BH,MAAA,CAAAY,IAAA,GAAOZ,MAAA,CAAOS,IAAO,GAAAF,WAAA;IAE5BP,MAAA,CAAOa,IAAO,GAAAP,IAAA,CAAKQ,CAAK,GAAAb,MAAA,CAAOc,EAAK,GAAAX,MAAA;IAC7BJ,MAAA,CAAAgB,IAAA,GAAOhB,MAAA,CAAOa,IAAO,GAAAL,YAAA;EAAA,CAIhC;IACWR,MAAA,CAAAS,IAAA,GAAO,CAACR,MAAA,CAAOU,EAAK,GAAAR,KAAA;IACpBH,MAAA,CAAAY,IAAA,GAAOZ,MAAA,CAAOS,IAAO,GAAAN,KAAA;IAErBH,MAAA,CAAAa,IAAA,GAAO,CAACZ,MAAA,CAAOc,EAAK,GAAAX,MAAA;IACpBJ,MAAA,CAAAgB,IAAA,GAAOhB,MAAA,CAAOa,IAAO,GAAAT,MAAA;EAAA;AAEpC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}