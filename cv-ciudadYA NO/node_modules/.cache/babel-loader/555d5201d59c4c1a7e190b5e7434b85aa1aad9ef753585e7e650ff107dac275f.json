{"ast":null,"code":"import { updateTransformBackwards } from '../bounds/getGlobalBounds.mjs';\nimport { matrixPool } from '../bounds/utils/matrixAndBoundsPool.mjs';\nimport { multiplyColors } from '../utils/multiplyColors.mjs';\n\"use strict\";\nfunction bgr2rgb(color) {\n  return ((color & 255) << 16) + (color & 65280) + (color >> 16 & 255);\n}\nconst getGlobalMixin = {\n  /**\n   * Returns the global (compound) alpha of the container within the scene.\n   * @param skipUpdate - Performance optimization flag:\n   *   - If false (default): Recalculates the entire alpha chain through parents for accuracy\n   *   - If true: Uses cached worldAlpha from the last render pass for better performance\n   * @returns The resulting alpha value (between 0 and 1)\n   * @example\n   * // Accurate but slower - recalculates entire alpha chain\n   * const preciseAlpha = container.getGlobalAlpha();\n   *\n   * // Faster but may be outdated - uses cached alpha\n   * const cachedAlpha = container.getGlobalAlpha(true);\n   */\n  getGlobalAlpha(skipUpdate) {\n    if (skipUpdate) {\n      if (this.renderGroup) {\n        return this.renderGroup.worldAlpha;\n      }\n      if (this.parentRenderGroup) {\n        return this.parentRenderGroup.worldAlpha * this.alpha;\n      }\n      return this.alpha;\n    }\n    let alpha = this.alpha;\n    let current = this.parent;\n    while (current) {\n      alpha *= current.alpha;\n      current = current.parent;\n    }\n    return alpha;\n  },\n  /**\n   * Returns the global transform matrix of the container within the scene.\n   * @param matrix - Optional matrix to store the result. If not provided, a new Matrix will be created.\n   * @param skipUpdate - Performance optimization flag:\n   *   - If false (default): Recalculates the entire transform chain for accuracy\n   *   - If true: Uses cached worldTransform from the last render pass for better performance\n   * @returns The resulting transformation matrix (either the input matrix or a new one)\n   * @example\n   * // Accurate but slower - recalculates entire transform chain\n   * const preciseTransform = container.getGlobalTransform();\n   *\n   * // Faster but may be outdated - uses cached transform\n   * const cachedTransform = container.getGlobalTransform(undefined, true);\n   *\n   * // Reuse existing matrix\n   * const existingMatrix = new Matrix();\n   * container.getGlobalTransform(existingMatrix);\n   */\n  getGlobalTransform(matrix, skipUpdate) {\n    if (skipUpdate) {\n      return matrix.copyFrom(this.worldTransform);\n    }\n    this.updateLocalTransform();\n    const parentTransform = updateTransformBackwards(this, matrixPool.get().identity());\n    matrix.appendFrom(this.localTransform, parentTransform);\n    matrixPool.return(parentTransform);\n    return matrix;\n  },\n  /**\n   * Returns the global (compound) tint color of the container within the scene.\n   * @param skipUpdate - Performance optimization flag:\n   *   - If false (default): Recalculates the entire tint chain through parents for accuracy\n   *   - If true: Uses cached worldColor from the last render pass for better performance\n   * @returns The resulting tint color as a 24-bit RGB number (0xRRGGBB)\n   * @example\n   * // Accurate but slower - recalculates entire tint chain\n   * const preciseTint = container.getGlobalTint();\n   *\n   * // Faster but may be outdated - uses cached tint\n   * const cachedTint = container.getGlobalTint(true);\n   */\n  getGlobalTint(skipUpdate) {\n    if (skipUpdate) {\n      if (this.renderGroup) {\n        return bgr2rgb(this.renderGroup.worldColor);\n      }\n      if (this.parentRenderGroup) {\n        return bgr2rgb(multiplyColors(this.localColor, this.parentRenderGroup.worldColor));\n      }\n      return this.tint;\n    }\n    let color = this.localColor;\n    let parent = this.parent;\n    while (parent) {\n      color = multiplyColors(color, parent.localColor);\n      parent = parent.parent;\n    }\n    return bgr2rgb(color);\n  }\n};\nexport { bgr2rgb, getGlobalMixin };","map":{"version":3,"names":["bgr2rgb","color","getGlobalMixin","getGlobalAlpha","skipUpdate","renderGroup","worldAlpha","parentRenderGroup","alpha","current","parent","getGlobalTransform","matrix","copyFrom","worldTransform","updateLocalTransform","parentTransform","updateTransformBackwards","matrixPool","get","identity","appendFrom","localTransform","return","getGlobalTint","worldColor","multiplyColors","localColor","tint"],"sources":["C:\\Users\\emalv\\OneDrive\\Desktop\\Portafolio\\cv-ciudad\\node_modules\\pixi.js\\src\\scene\\container\\container-mixins\\getGlobalMixin.ts"],"sourcesContent":["import { updateTransformBackwards } from '../bounds/getGlobalBounds';\nimport { matrixPool } from '../bounds/utils/matrixAndBoundsPool';\nimport { multiplyColors } from '../utils/multiplyColors';\n\nimport type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { Container } from '../Container';\n\nexport function bgr2rgb(color: number): number\n{\n    return ((color & 0xFF) << 16) + (color & 0xFF00) + ((color >> 16) & 0xFF);\n}\n\nexport interface GetGlobalMixin\n{\n    getGlobalAlpha(skipUpdate: boolean): number;\n    getGlobalTransform(matrix: Matrix, skipUpdate: boolean): Matrix;\n    getGlobalTint(skipUpdate?: boolean): number;\n}\n\nexport const getGlobalMixin: Partial<Container> = {\n    /**\n     * Returns the global (compound) alpha of the container within the scene.\n     * @param skipUpdate - Performance optimization flag:\n     *   - If false (default): Recalculates the entire alpha chain through parents for accuracy\n     *   - If true: Uses cached worldAlpha from the last render pass for better performance\n     * @returns The resulting alpha value (between 0 and 1)\n     * @example\n     * // Accurate but slower - recalculates entire alpha chain\n     * const preciseAlpha = container.getGlobalAlpha();\n     *\n     * // Faster but may be outdated - uses cached alpha\n     * const cachedAlpha = container.getGlobalAlpha(true);\n     */\n    getGlobalAlpha(skipUpdate: boolean): number\n    {\n        if (skipUpdate)\n        {\n            if (this.renderGroup)\n            {\n                return this.renderGroup.worldAlpha;\n            }\n\n            if (this.parentRenderGroup)\n            {\n                return this.parentRenderGroup.worldAlpha * this.alpha;\n            }\n\n            return this.alpha;\n        }\n\n        let alpha = this.alpha;\n        let current = this.parent;\n\n        while (current)\n        {\n            alpha *= current.alpha;\n            current = current.parent;\n        }\n\n        return alpha;\n    },\n\n    /**\n     * Returns the global transform matrix of the container within the scene.\n     * @param matrix - Optional matrix to store the result. If not provided, a new Matrix will be created.\n     * @param skipUpdate - Performance optimization flag:\n     *   - If false (default): Recalculates the entire transform chain for accuracy\n     *   - If true: Uses cached worldTransform from the last render pass for better performance\n     * @returns The resulting transformation matrix (either the input matrix or a new one)\n     * @example\n     * // Accurate but slower - recalculates entire transform chain\n     * const preciseTransform = container.getGlobalTransform();\n     *\n     * // Faster but may be outdated - uses cached transform\n     * const cachedTransform = container.getGlobalTransform(undefined, true);\n     *\n     * // Reuse existing matrix\n     * const existingMatrix = new Matrix();\n     * container.getGlobalTransform(existingMatrix);\n     */\n    getGlobalTransform(matrix: Matrix, skipUpdate: boolean): Matrix\n    {\n        if (skipUpdate)\n        {\n            return matrix.copyFrom(this.worldTransform);\n        }\n\n        this.updateLocalTransform();\n\n        const parentTransform = updateTransformBackwards(this, matrixPool.get().identity());\n\n        matrix.appendFrom(this.localTransform, parentTransform);\n        matrixPool.return(parentTransform);\n\n        return matrix;\n    },\n\n    /**\n     * Returns the global (compound) tint color of the container within the scene.\n     * @param skipUpdate - Performance optimization flag:\n     *   - If false (default): Recalculates the entire tint chain through parents for accuracy\n     *   - If true: Uses cached worldColor from the last render pass for better performance\n     * @returns The resulting tint color as a 24-bit RGB number (0xRRGGBB)\n     * @example\n     * // Accurate but slower - recalculates entire tint chain\n     * const preciseTint = container.getGlobalTint();\n     *\n     * // Faster but may be outdated - uses cached tint\n     * const cachedTint = container.getGlobalTint(true);\n     */\n    getGlobalTint(skipUpdate?: boolean): number\n    {\n        if (skipUpdate)\n        {\n            if (this.renderGroup)\n            {\n                return bgr2rgb(this.renderGroup.worldColor);\n            }\n\n            if (this.parentRenderGroup)\n            {\n                return bgr2rgb(\n                    multiplyColors(this.localColor, this.parentRenderGroup.worldColor)\n                );\n            }\n\n            return this.tint;\n        }\n\n        let color = this.localColor;\n        let parent = this.parent;\n\n        while (parent)\n        {\n            color = multiplyColors(color, parent.localColor);\n            parent = parent.parent;\n        }\n\n        return bgr2rgb(color);\n    }\n\n} as Container;\n"],"mappings":";;;;AAOO,SAASA,QAAQC,KACxB;EACI,SAASA,KAAA,GAAQ,GAAS,YAAOA,KAAQ,aAAYA,KAAA,IAAS,EAAM;AACxE;AASO,MAAMC,cAAqC;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAc9CC,eAAeC,UACf;IACI,IAAIA,UACJ;MACI,IAAI,KAAKC,WACT;QACI,OAAO,KAAKA,WAAY,CAAAC,UAAA;MAAA;MAG5B,IAAI,KAAKC,iBACT;QACW,YAAKA,iBAAkB,CAAAD,UAAA,GAAa,IAAK,CAAAE,KAAA;MAAA;MAGpD,OAAO,IAAK,CAAAA,KAAA;IAAA;IAGhB,IAAIA,KAAA,GAAQ,IAAK,CAAAA,KAAA;IACjB,IAAIC,OAAA,GAAU,IAAK,CAAAC,MAAA;IAEnB,OAAOD,OACP;MACID,KAAA,IAASC,OAAQ,CAAAD,KAAA;MACjBC,OAAA,GAAUA,OAAQ,CAAAC,MAAA;IAAA;IAGf,OAAAF,KAAA;EAAA,CACX;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAoBAG,mBAAmBC,MAAA,EAAgBR,UACnC;IACI,IAAIA,UACJ;MACW,OAAAQ,MAAA,CAAOC,QAAS,MAAKC,cAAc;IAAA;IAG9C,KAAKC,oBAAqB;IAE1B,MAAMC,eAAA,GAAkBC,wBAAyB,OAAMC,UAAA,CAAWC,GAAI,GAAEC,QAAA,EAAU;IAE3ER,MAAA,CAAAS,UAAA,CAAW,IAAK,CAAAC,cAAA,EAAgBN,eAAe;IACtDE,UAAA,CAAWK,MAAA,CAAOP,eAAe;IAE1B,OAAAJ,MAAA;EAAA,CACX;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAeAY,cAAcpB,UACd;IACI,IAAIA,UACJ;MACI,IAAI,KAAKC,WACT;QACW,OAAAL,OAAA,CAAQ,IAAK,CAAAK,WAAA,CAAYoB,UAAU;MAAA;MAG9C,IAAI,KAAKlB,iBACT;QACW,OAAAP,OAAA,CACH0B,cAAe,MAAKC,UAAY,OAAKpB,iBAAA,CAAkBkB,UAAU,EACrE;MAAA;MAGJ,OAAO,IAAK,CAAAG,IAAA;IAAA;IAGhB,IAAI3B,KAAA,GAAQ,IAAK,CAAA0B,UAAA;IACjB,IAAIjB,MAAA,GAAS,IAAK,CAAAA,MAAA;IAElB,OAAOA,MACP;MACYT,KAAA,GAAAyB,cAAA,CAAezB,KAAO,EAAAS,MAAA,CAAOiB,UAAU;MAC/CjB,MAAA,GAASA,MAAO,CAAAA,MAAA;IAAA;IAGpB,OAAOV,OAAA,CAAQC,KAAK;EAAA;AAG5B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}