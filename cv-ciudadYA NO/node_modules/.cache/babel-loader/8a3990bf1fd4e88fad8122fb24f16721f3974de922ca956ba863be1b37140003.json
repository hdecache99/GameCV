{"ast":null,"code":"import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { BufferUsage } from '../../shared/buffer/const.mjs';\nimport { BUFFER_TYPE } from './const.mjs';\nimport { GlBuffer } from './GlBuffer.mjs';\n\"use strict\";\nclass GlBufferSystem {\n  /**\n   * @param {Renderer} renderer - The renderer this System works for.\n   */\n  constructor(renderer) {\n    this._gpuBuffers = /* @__PURE__ */Object.create(null);\n    /** Cache keeping track of the base bound buffer bases */\n    this._boundBufferBases = /* @__PURE__ */Object.create(null);\n    this._minBaseLocation = 0;\n    this._nextBindBaseIndex = this._minBaseLocation;\n    this._bindCallId = 0;\n    this._renderer = renderer;\n    this._renderer.renderableGC.addManagedHash(this, \"_gpuBuffers\");\n  }\n  /**\n   * @ignore\n   */\n  destroy() {\n    this._renderer = null;\n    this._gl = null;\n    this._gpuBuffers = null;\n    this._boundBufferBases = null;\n  }\n  /** Sets up the renderer context and necessary buffers. */\n  contextChange() {\n    const gl = this._gl = this._renderer.gl;\n    this._gpuBuffers = /* @__PURE__ */Object.create(null);\n    this._maxBindings = gl.MAX_UNIFORM_BUFFER_BINDINGS ? gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS) : 0;\n  }\n  getGlBuffer(buffer) {\n    return this._gpuBuffers[buffer.uid] || this.createGLBuffer(buffer);\n  }\n  /**\n   * This binds specified buffer. On first run, it will create the webGL buffers for the context too\n   * @param buffer - the buffer to bind to the renderer\n   */\n  bind(buffer) {\n    const {\n      _gl: gl\n    } = this;\n    const glBuffer = this.getGlBuffer(buffer);\n    gl.bindBuffer(glBuffer.type, glBuffer.buffer);\n  }\n  /**\n   * Binds an uniform buffer to at the given index.\n   *\n   * A cache is used so a buffer will not be bound again if already bound.\n   * @param glBuffer - the buffer to bind\n   * @param index - the base index to bind it to.\n   */\n  bindBufferBase(glBuffer, index) {\n    const {\n      _gl: gl\n    } = this;\n    if (this._boundBufferBases[index] !== glBuffer) {\n      this._boundBufferBases[index] = glBuffer;\n      glBuffer._lastBindBaseLocation = index;\n      gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);\n    }\n  }\n  nextBindBase(hasTransformFeedback) {\n    this._bindCallId++;\n    this._minBaseLocation = 0;\n    if (hasTransformFeedback) {\n      this._boundBufferBases[0] = null;\n      this._minBaseLocation = 1;\n      if (this._nextBindBaseIndex < 1) {\n        this._nextBindBaseIndex = 1;\n      }\n    }\n  }\n  freeLocationForBufferBase(glBuffer) {\n    let freeIndex = this.getLastBindBaseLocation(glBuffer);\n    if (freeIndex >= this._minBaseLocation) {\n      glBuffer._lastBindCallId = this._bindCallId;\n      return freeIndex;\n    }\n    let loop = 0;\n    let nextIndex = this._nextBindBaseIndex;\n    while (loop < 2) {\n      if (nextIndex >= this._maxBindings) {\n        nextIndex = this._minBaseLocation;\n        loop++;\n      }\n      const curBuf = this._boundBufferBases[nextIndex];\n      if (curBuf && curBuf._lastBindCallId === this._bindCallId) {\n        nextIndex++;\n        continue;\n      }\n      break;\n    }\n    freeIndex = nextIndex;\n    this._nextBindBaseIndex = nextIndex + 1;\n    if (loop >= 2) {\n      return -1;\n    }\n    glBuffer._lastBindCallId = this._bindCallId;\n    this._boundBufferBases[freeIndex] = null;\n    return freeIndex;\n  }\n  getLastBindBaseLocation(glBuffer) {\n    const index = glBuffer._lastBindBaseLocation;\n    if (this._boundBufferBases[index] === glBuffer) {\n      return index;\n    }\n    return -1;\n  }\n  /**\n   * Binds a buffer whilst also binding its range.\n   * This will make the buffer start from the offset supplied rather than 0 when it is read.\n   * @param glBuffer - the buffer to bind\n   * @param index - the base index to bind at, defaults to 0\n   * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc\n   * @param size - the size to bind at (this is blocks of 256).\n   */\n  bindBufferRange(glBuffer, index, offset, size) {\n    const {\n      _gl: gl\n    } = this;\n    offset || (offset = 0);\n    index || (index = 0);\n    this._boundBufferBases[index] = null;\n    gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, size || 256);\n  }\n  /**\n   * Will ensure the data in the buffer is uploaded to the GPU.\n   * @param {Buffer} buffer - the buffer to update\n   */\n  updateBuffer(buffer) {\n    const {\n      _gl: gl\n    } = this;\n    const glBuffer = this.getGlBuffer(buffer);\n    if (buffer._updateID === glBuffer.updateID) {\n      return glBuffer;\n    }\n    glBuffer.updateID = buffer._updateID;\n    gl.bindBuffer(glBuffer.type, glBuffer.buffer);\n    const data = buffer.data;\n    const drawType = buffer.descriptor.usage & BufferUsage.STATIC ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;\n    if (data) {\n      if (glBuffer.byteLength >= data.byteLength) {\n        gl.bufferSubData(glBuffer.type, 0, data, 0, buffer._updateSize / data.BYTES_PER_ELEMENT);\n      } else {\n        glBuffer.byteLength = data.byteLength;\n        gl.bufferData(glBuffer.type, data, drawType);\n      }\n    } else {\n      glBuffer.byteLength = buffer.descriptor.size;\n      gl.bufferData(glBuffer.type, glBuffer.byteLength, drawType);\n    }\n    return glBuffer;\n  }\n  /** dispose all WebGL resources of all managed buffers */\n  destroyAll() {\n    const gl = this._gl;\n    for (const id in this._gpuBuffers) {\n      gl.deleteBuffer(this._gpuBuffers[id].buffer);\n    }\n    this._gpuBuffers = /* @__PURE__ */Object.create(null);\n  }\n  /**\n   * Disposes buffer\n   * @param {Buffer} buffer - buffer with data\n   * @param {boolean} [contextLost=false] - If context was lost, we suppress deleteVertexArray\n   */\n  onBufferDestroy(buffer, contextLost) {\n    const glBuffer = this._gpuBuffers[buffer.uid];\n    const gl = this._gl;\n    if (!contextLost) {\n      gl.deleteBuffer(glBuffer.buffer);\n    }\n    this._gpuBuffers[buffer.uid] = null;\n  }\n  /**\n   * creates and attaches a GLBuffer object tied to the current context.\n   * @param buffer\n   * @protected\n   */\n  createGLBuffer(buffer) {\n    const {\n      _gl: gl\n    } = this;\n    let type = BUFFER_TYPE.ARRAY_BUFFER;\n    if (buffer.descriptor.usage & BufferUsage.INDEX) {\n      type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;\n    } else if (buffer.descriptor.usage & BufferUsage.UNIFORM) {\n      type = BUFFER_TYPE.UNIFORM_BUFFER;\n    }\n    const glBuffer = new GlBuffer(gl.createBuffer(), type);\n    this._gpuBuffers[buffer.uid] = glBuffer;\n    buffer.on(\"destroy\", this.onBufferDestroy, this);\n    return glBuffer;\n  }\n  resetState() {\n    this._boundBufferBases = /* @__PURE__ */Object.create(null);\n  }\n}\n/** @ignore */\nGlBufferSystem.extension = {\n  type: [ExtensionType.WebGLSystem],\n  name: \"buffer\"\n};\nexport { GlBufferSystem };","map":{"version":3,"names":["GlBufferSystem","constructor","renderer","_gpuBuffers","Object","create","_boundBufferBases","_minBaseLocation","_nextBindBaseIndex","_bindCallId","_renderer","renderableGC","addManagedHash","destroy","_gl","contextChange","gl","_maxBindings","MAX_UNIFORM_BUFFER_BINDINGS","getParameter","getGlBuffer","buffer","uid","createGLBuffer","bind","glBuffer","bindBuffer","type","bindBufferBase","index","_lastBindBaseLocation","UNIFORM_BUFFER","nextBindBase","hasTransformFeedback","freeLocationForBufferBase","freeIndex","getLastBindBaseLocation","_lastBindCallId","loop","nextIndex","curBuf","bindBufferRange","offset","size","updateBuffer","_updateID","updateID","data","drawType","descriptor","usage","BufferUsage","STATIC","STATIC_DRAW","DYNAMIC_DRAW","byteLength","bufferSubData","_updateSize","BYTES_PER_ELEMENT","bufferData","destroyAll","id","deleteBuffer","onBufferDestroy","contextLost","BUFFER_TYPE","ARRAY_BUFFER","INDEX","ELEMENT_ARRAY_BUFFER","UNIFORM","GlBuffer","createBuffer","on","resetState","extension","ExtensionType","WebGLSystem","name"],"sources":["C:\\Users\\emalv\\OneDrive\\Desktop\\Portafolio\\cv-ciudad\\node_modules\\pixi.js\\src\\rendering\\renderers\\gl\\buffer\\GlBufferSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions';\nimport { BufferUsage } from '../../shared/buffer/const';\nimport { BUFFER_TYPE } from './const';\nimport { GlBuffer } from './GlBuffer';\n\nimport type { Buffer } from '../../shared/buffer/Buffer';\nimport type { System } from '../../shared/system/System';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { WebGLRenderer } from '../WebGLRenderer';\n\n/**\n * System plugin to the renderer to manage buffers.\n *\n * WebGL uses Buffers as a way to store objects to the GPU.\n * This system makes working with them a lot easier.\n *\n * Buffers are used in three main places in WebGL\n * - geometry information\n * - Uniform information (via uniform buffer objects - a WebGL 2 only feature)\n * - Transform feedback information. (WebGL 2 only feature)\n *\n * This system will handle the binding of buffers to the GPU as well as uploading\n * them. With this system, you never need to work directly with GPU buffers, but instead work with\n * the Buffer class.\n * @class\n * @memberof rendering\n */\nexport class GlBufferSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'buffer',\n    } as const;\n\n    private _gl: GlRenderingContext;\n    private _gpuBuffers: {[key: number]: GlBuffer} = Object.create(null);\n\n    /** Cache keeping track of the base bound buffer bases */\n    private _boundBufferBases: {[key: number]: GlBuffer} = Object.create(null);\n\n    private _renderer: WebGLRenderer;\n\n    private _minBaseLocation = 0;\n    private _maxBindings: number;\n    private _nextBindBaseIndex = this._minBaseLocation;\n    private _bindCallId = 0;\n\n    /**\n     * @param {Renderer} renderer - The renderer this System works for.\n     */\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n\n        this._renderer.renderableGC.addManagedHash(this, '_gpuBuffers');\n    }\n\n    /**\n     * @ignore\n     */\n    public destroy(): void\n    {\n        this._renderer = null;\n        this._gl = null;\n        this._gpuBuffers = null;\n        (this._boundBufferBases as null) = null;\n    }\n\n    /** Sets up the renderer context and necessary buffers. */\n    protected contextChange(): void\n    {\n        const gl = this._gl = this._renderer.gl;\n\n        this._gpuBuffers = Object.create(null);\n        this._maxBindings = gl.MAX_UNIFORM_BUFFER_BINDINGS ? gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS) : 0;\n    }\n\n    public getGlBuffer(buffer: Buffer): GlBuffer\n    {\n        return this._gpuBuffers[buffer.uid] || this.createGLBuffer(buffer);\n    }\n\n    /**\n     * This binds specified buffer. On first run, it will create the webGL buffers for the context too\n     * @param buffer - the buffer to bind to the renderer\n     */\n    public bind(buffer: Buffer): void\n    {\n        const { _gl: gl } = this;\n\n        const glBuffer = this.getGlBuffer(buffer);\n\n        gl.bindBuffer(glBuffer.type, glBuffer.buffer);\n    }\n\n    /**\n     * Binds an uniform buffer to at the given index.\n     *\n     * A cache is used so a buffer will not be bound again if already bound.\n     * @param glBuffer - the buffer to bind\n     * @param index - the base index to bind it to.\n     */\n    public bindBufferBase(glBuffer: GlBuffer, index: number): void\n    {\n        const { _gl: gl } = this;\n\n        if (this._boundBufferBases[index] !== glBuffer)\n        {\n            this._boundBufferBases[index] = glBuffer;\n            glBuffer._lastBindBaseLocation = index;\n\n            gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);\n        }\n    }\n\n    public nextBindBase(hasTransformFeedback: boolean)\n    {\n        this._bindCallId++;\n        this._minBaseLocation = 0;\n        if (hasTransformFeedback)\n        {\n            this._boundBufferBases[0] = null;\n            this._minBaseLocation = 1;\n            if (this._nextBindBaseIndex < 1)\n            {\n                this._nextBindBaseIndex = 1;\n            }\n        }\n    }\n\n    public freeLocationForBufferBase(glBuffer: GlBuffer): number\n    {\n        let freeIndex = this.getLastBindBaseLocation(glBuffer);\n\n        // check if it is already bound..\n        if (freeIndex >= this._minBaseLocation)\n        {\n            glBuffer._lastBindCallId = this._bindCallId;\n\n            return freeIndex;\n        }\n\n        let loop = 0;\n        let nextIndex = this._nextBindBaseIndex;\n\n        while (loop < 2)\n        {\n            if (nextIndex >= this._maxBindings)\n            {\n                nextIndex = this._minBaseLocation;\n                loop++;\n            }\n\n            const curBuf = this._boundBufferBases[nextIndex];\n\n            if (curBuf && curBuf._lastBindCallId === this._bindCallId)\n            {\n                nextIndex++;\n                continue;\n            }\n            break;\n        }\n\n        freeIndex = nextIndex;\n        this._nextBindBaseIndex = nextIndex + 1;\n\n        if (loop >= 2)\n        {\n            // TODO: error\n            return -1;\n        }\n\n        glBuffer._lastBindCallId = this._bindCallId;\n        this._boundBufferBases[freeIndex] = null;\n\n        return freeIndex;\n    }\n\n    public getLastBindBaseLocation(glBuffer: GlBuffer): number\n    {\n        const index = glBuffer._lastBindBaseLocation;\n\n        if (this._boundBufferBases[index] === glBuffer)\n        {\n            return index;\n        }\n\n        return -1;\n    }\n\n    /**\n     * Binds a buffer whilst also binding its range.\n     * This will make the buffer start from the offset supplied rather than 0 when it is read.\n     * @param glBuffer - the buffer to bind\n     * @param index - the base index to bind at, defaults to 0\n     * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc\n     * @param size - the size to bind at (this is blocks of 256).\n     */\n    public bindBufferRange(glBuffer: GlBuffer, index?: number, offset?: number, size?: number): void\n    {\n        const { _gl: gl } = this;\n\n        offset ||= 0;\n        index ||= 0;\n\n        this._boundBufferBases[index] = null;\n\n        gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, size || 256);\n    }\n\n    /**\n     * Will ensure the data in the buffer is uploaded to the GPU.\n     * @param {Buffer} buffer - the buffer to update\n     */\n    public updateBuffer(buffer: Buffer): GlBuffer\n    {\n        const { _gl: gl } = this;\n\n        const glBuffer = this.getGlBuffer(buffer);\n\n        if (buffer._updateID === glBuffer.updateID)\n        {\n            return glBuffer;\n        }\n\n        glBuffer.updateID = buffer._updateID;\n\n        gl.bindBuffer(glBuffer.type, glBuffer.buffer);\n\n        const data = buffer.data;\n\n        const drawType = (buffer.descriptor.usage & BufferUsage.STATIC) ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;\n\n        if (data)\n        {\n            if (glBuffer.byteLength >= data.byteLength)\n            {\n                // assuming our buffers are aligned to 4 bits...\n                // offset is always zero for now!\n                gl.bufferSubData(glBuffer.type, 0, data, 0, buffer._updateSize / data.BYTES_PER_ELEMENT);\n            }\n            else\n            {\n                glBuffer.byteLength = data.byteLength;\n                // assuming our buffers are aligned to 4 bits...\n                gl.bufferData(glBuffer.type, data, drawType);\n            }\n        }\n        else\n        {\n            glBuffer.byteLength = buffer.descriptor.size;\n            gl.bufferData(glBuffer.type, glBuffer.byteLength, drawType);\n        }\n\n        return glBuffer;\n    }\n\n    /** dispose all WebGL resources of all managed buffers */\n    public destroyAll(): void\n    {\n        const gl = this._gl;\n\n        for (const id in this._gpuBuffers)\n        {\n            gl.deleteBuffer(this._gpuBuffers[id].buffer);\n        }\n\n        this._gpuBuffers = Object.create(null);\n    }\n\n    /**\n     * Disposes buffer\n     * @param {Buffer} buffer - buffer with data\n     * @param {boolean} [contextLost=false] - If context was lost, we suppress deleteVertexArray\n     */\n    protected onBufferDestroy(buffer: Buffer, contextLost?: boolean): void\n    {\n        const glBuffer = this._gpuBuffers[buffer.uid];\n\n        const gl = this._gl;\n\n        if (!contextLost)\n        {\n            gl.deleteBuffer(glBuffer.buffer);\n        }\n\n        this._gpuBuffers[buffer.uid] = null;\n    }\n\n    /**\n     * creates and attaches a GLBuffer object tied to the current context.\n     * @param buffer\n     * @protected\n     */\n    protected createGLBuffer(buffer: Buffer): GlBuffer\n    {\n        const { _gl: gl } = this;\n\n        let type = BUFFER_TYPE.ARRAY_BUFFER;\n\n        if ((buffer.descriptor.usage & BufferUsage.INDEX))\n        {\n            type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;\n        }\n        else if ((buffer.descriptor.usage & BufferUsage.UNIFORM))\n        {\n            type = BUFFER_TYPE.UNIFORM_BUFFER;\n        }\n\n        const glBuffer = new GlBuffer(gl.createBuffer(), type);\n\n        this._gpuBuffers[buffer.uid] = glBuffer;\n\n        buffer.on('destroy', this.onBufferDestroy, this);\n\n        return glBuffer;\n    }\n\n    public resetState(): void\n    {\n        this._boundBufferBases = Object.create(null);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}