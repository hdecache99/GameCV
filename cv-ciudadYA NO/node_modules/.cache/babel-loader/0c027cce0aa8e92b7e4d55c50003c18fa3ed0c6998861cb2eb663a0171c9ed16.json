{"ast":null,"code":"import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { getMaxTexturesPerBatch } from '../../../rendering/batcher/gl/utils/maxRecommendedTextures.mjs';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup.mjs';\nimport { compileHighShaderGpuProgram } from '../../../rendering/high-shader/compileHighShaderToProgram.mjs';\nimport { colorBit } from '../../../rendering/high-shader/shader-bits/colorBit.mjs';\nimport { generateTextureBatchBit } from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit.mjs';\nimport { localUniformBitGroup2 } from '../../../rendering/high-shader/shader-bits/localUniformBit.mjs';\nimport { roundPixelsBit } from '../../../rendering/high-shader/shader-bits/roundPixelsBit.mjs';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\n\"use strict\";\nclass GpuGraphicsAdaptor {\n  init() {\n    const localUniforms = new UniformGroup({\n      uTransformMatrix: {\n        value: new Matrix(),\n        type: \"mat3x3<f32>\"\n      },\n      uColor: {\n        value: new Float32Array([1, 1, 1, 1]),\n        type: \"vec4<f32>\"\n      },\n      uRound: {\n        value: 0,\n        type: \"f32\"\n      }\n    });\n    const gpuProgram = compileHighShaderGpuProgram({\n      name: \"graphics\",\n      bits: [colorBit, generateTextureBatchBit(getMaxTexturesPerBatch()), localUniformBitGroup2, roundPixelsBit]\n    });\n    this.shader = new Shader({\n      gpuProgram,\n      resources: {\n        // added on the fly!\n        localUniforms\n      }\n    });\n  }\n  execute(graphicsPipe, renderable) {\n    const context = renderable.context;\n    const shader = context.customShader || this.shader;\n    const renderer = graphicsPipe.renderer;\n    const contextSystem = renderer.graphicsContext;\n    const {\n      batcher,\n      instructions\n    } = contextSystem.getContextRenderData(context);\n    const encoder = renderer.encoder;\n    encoder.setGeometry(batcher.geometry, shader.gpuProgram);\n    const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n    encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);\n    const localBindGroup = renderer.renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);\n    encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);\n    const batches = instructions.instructions;\n    let topology = null;\n    for (let i = 0; i < instructions.instructionSize; i++) {\n      const batch = batches[i];\n      if (batch.topology !== topology) {\n        topology = batch.topology;\n        encoder.setPipelineFromGeometryProgramAndState(batcher.geometry, shader.gpuProgram, graphicsPipe.state, batch.topology);\n      }\n      shader.groups[1] = batch.bindGroup;\n      if (!batch.gpuBindGroup) {\n        const textureBatch = batch.textures;\n        batch.bindGroup = getTextureBatchBindGroup(textureBatch.textures, textureBatch.count);\n        batch.gpuBindGroup = renderer.bindGroup.getBindGroup(batch.bindGroup, shader.gpuProgram, 1);\n      }\n      encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);\n      encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n    }\n  }\n  destroy() {\n    this.shader.destroy(true);\n    this.shader = null;\n  }\n}\n/** @ignore */\nGpuGraphicsAdaptor.extension = {\n  type: [ExtensionType.WebGPUPipesAdaptor],\n  name: \"graphics\"\n};\nexport { GpuGraphicsAdaptor };","map":{"version":3,"names":["GpuGraphicsAdaptor","init","localUniforms","UniformGroup","uTransformMatrix","value","Matrix","type","uColor","Float32Array","uRound","gpuProgram","compileHighShaderGpuProgram","name","bits","colorBit","generateTextureBatchBit","getMaxTexturesPerBatch","localUniformBitGroup2","roundPixelsBit","shader","Shader","resources","execute","graphicsPipe","renderable","context","customShader","renderer","contextSystem","graphicsContext","batcher","instructions","getContextRenderData","encoder","setGeometry","geometry","globalUniformsBindGroup","globalUniforms","bindGroup","setBindGroup","localBindGroup","renderPipes","uniformBatch","getUniformBindGroup","batches","topology","i","instructionSize","batch","setPipelineFromGeometryProgramAndState","state","groups","gpuBindGroup","textureBatch","textures","getTextureBatchBindGroup","count","getBindGroup","renderPassEncoder","drawIndexed","size","start","destroy","extension","ExtensionType","WebGPUPipesAdaptor"],"sources":["C:\\Users\\emalv\\OneDrive\\Desktop\\Portafolio\\cv-ciudad\\node_modules\\pixi.js\\src\\scene\\graphics\\gpu\\GpuGraphicsAdaptor.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { getMaxTexturesPerBatch } from '../../../rendering/batcher/gl/utils/maxRecommendedTextures';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup';\nimport { compileHighShaderGpuProgram } from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { colorBit } from '../../../rendering/high-shader/shader-bits/colorBit';\nimport { generateTextureBatchBit } from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit';\nimport { localUniformBitGroup2 } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBit } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\n\nimport type { Batch } from '../../../rendering/batcher/shared/Batcher';\nimport type { GpuEncoderSystem } from '../../../rendering/renderers/gpu/GpuEncoderSystem';\nimport type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { Graphics } from '../shared/Graphics';\nimport type { GraphicsAdaptor, GraphicsPipe } from '../shared/GraphicsPipe';\n\n/**\n * A GraphicsAdaptor that uses the GPU to render graphics.\n * @memberof rendering\n * @ignore\n */\nexport class GpuGraphicsAdaptor implements GraphicsAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipesAdaptor,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public shader: Shader;\n\n    public init()\n    {\n        const localUniforms = new UniformGroup({\n            uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n            uRound: { value: 0, type: 'f32' },\n        });\n\n        const gpuProgram = compileHighShaderGpuProgram({\n            name: 'graphics',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(getMaxTexturesPerBatch()),\n\n                localUniformBitGroup2,\n                roundPixelsBit\n            ]\n        });\n\n        this.shader = new Shader({\n            gpuProgram,\n            resources: {\n                // added on the fly!\n                localUniforms,\n            },\n        });\n    }\n\n    public execute(graphicsPipe: GraphicsPipe, renderable: Graphics): void\n    {\n        const context = renderable.context;\n        const shader = context.customShader || this.shader;\n        const renderer = graphicsPipe.renderer as WebGPURenderer;\n        const contextSystem = renderer.graphicsContext;\n\n        const {\n            batcher, instructions\n        } = contextSystem.getContextRenderData(context);\n\n        // WebGPU specific...\n\n        // TODO perf test this a bit...\n        const encoder = renderer.encoder as GpuEncoderSystem;\n\n        encoder.setGeometry(batcher.geometry, shader.gpuProgram);\n\n        const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n\n        encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);\n\n        const localBindGroup = (renderer as WebGPURenderer)\n            .renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);\n\n        encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);\n\n        const batches = instructions.instructions as Batch[];\n\n        let topology: Topology = null;\n\n        for (let i = 0; i < instructions.instructionSize; i++)\n        {\n            const batch = batches[i];\n\n            if (batch.topology !== topology)\n            {\n                topology = batch.topology;\n\n                encoder.setPipelineFromGeometryProgramAndState(\n                    batcher.geometry,\n                    shader.gpuProgram,\n                    graphicsPipe.state,\n                    batch.topology\n                );\n            }\n\n            shader.groups[1] = batch.bindGroup;\n\n            if (!batch.gpuBindGroup)\n            {\n                const textureBatch = batch.textures;\n\n                batch.bindGroup = getTextureBatchBindGroup(textureBatch.textures, textureBatch.count);\n                batch.gpuBindGroup = renderer.bindGroup.getBindGroup(\n                    batch.bindGroup, shader.gpuProgram, 1\n                );\n            }\n\n            encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);\n\n            encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n        }\n    }\n\n    public destroy(): void\n    {\n        this.shader.destroy(true);\n        this.shader = null;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}