{"ast":null,"code":"import { Color } from '../../color/Color.mjs';\nimport { Rectangle } from '../../maths/shapes/Rectangle.mjs';\nimport { CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool.mjs';\nimport { ImageSource } from '../../rendering/renderers/shared/texture/sources/ImageSource.mjs';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture.mjs';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics.mjs';\nimport { fontStringFromTextStyle } from '../text/canvas/utils/fontStringFromTextStyle.mjs';\nimport { getCanvasFillStyle } from '../text/canvas/utils/getCanvasFillStyle.mjs';\nimport { TextStyle } from '../text/TextStyle.mjs';\nimport { AbstractBitmapFont } from './AbstractBitmapFont.mjs';\nimport { resolveCharacters } from './utils/resolveCharacters.mjs';\n\"use strict\";\nconst _DynamicBitmapFont = class _DynamicBitmapFont extends AbstractBitmapFont {\n  /**\n   * @param options - The options for the dynamic bitmap font.\n   */\n  constructor(options) {\n    super();\n    /**\n     * this is a resolution modifier for the font size..\n     * texture resolution will also be used to scale texture according to its font size also\n     */\n    this.resolution = 1;\n    /** The pages of the font. */\n    this.pages = [];\n    this._padding = 0;\n    this._measureCache = /* @__PURE__ */Object.create(null);\n    this._currentChars = [];\n    this._currentX = 0;\n    this._currentY = 0;\n    this._currentPageIndex = -1;\n    this._skipKerning = false;\n    const dynamicOptions = {\n      ..._DynamicBitmapFont.defaultOptions,\n      ...options\n    };\n    this._textureSize = dynamicOptions.textureSize;\n    this._mipmap = dynamicOptions.mipmap;\n    const style = dynamicOptions.style.clone();\n    if (dynamicOptions.overrideFill) {\n      style._fill.color = 16777215;\n      style._fill.alpha = 1;\n      style._fill.texture = Texture.WHITE;\n      style._fill.fill = null;\n    }\n    this.applyFillAsTint = dynamicOptions.overrideFill;\n    const requestedFontSize = style.fontSize;\n    style.fontSize = this.baseMeasurementFontSize;\n    const font = fontStringFromTextStyle(style);\n    if (dynamicOptions.overrideSize) {\n      if (style._stroke) {\n        style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;\n      }\n    } else {\n      style.fontSize = this.baseRenderedFontSize = requestedFontSize;\n    }\n    this._style = style;\n    this._skipKerning = dynamicOptions.skipKerning ?? false;\n    this.resolution = dynamicOptions.resolution ?? 1;\n    this._padding = dynamicOptions.padding ?? 4;\n    this.fontMetrics = CanvasTextMetrics.measureFont(font);\n    this.lineHeight = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;\n  }\n  ensureCharacters(chars) {\n    const charList = resolveCharacters(chars).filter(char => !this._currentChars.includes(char)).filter((char, index, self) => self.indexOf(char) === index);\n    if (!charList.length) return;\n    this._currentChars = [...this._currentChars, ...charList];\n    let pageData;\n    if (this._currentPageIndex === -1) {\n      pageData = this._nextPage();\n    } else {\n      pageData = this.pages[this._currentPageIndex];\n    }\n    let {\n      canvas,\n      context\n    } = pageData.canvasAndContext;\n    let textureSource = pageData.texture.source;\n    const style = this._style;\n    let currentX = this._currentX;\n    let currentY = this._currentY;\n    const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;\n    const padding = this._padding * fontScale;\n    let maxCharHeight = 0;\n    let skipTexture = false;\n    const maxTextureWidth = canvas.width / this.resolution;\n    const maxTextureHeight = canvas.height / this.resolution;\n    for (let i = 0; i < charList.length; i++) {\n      const char = charList[i];\n      const metrics = CanvasTextMetrics.measureText(char, style, canvas, false);\n      metrics.lineHeight = metrics.height;\n      const width = metrics.width * fontScale;\n      const textureGlyphWidth = Math.ceil((style.fontStyle === \"italic\" ? 2 : 1) * width);\n      const height = metrics.height * fontScale;\n      const paddedWidth = textureGlyphWidth + padding * 2;\n      const paddedHeight = height + padding * 2;\n      skipTexture = false;\n      if (char !== \"\\n\" && char !== \"\\r\" && char !== \"\t\" && char !== \" \") {\n        skipTexture = true;\n        maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));\n      }\n      if (currentX + paddedWidth > maxTextureWidth) {\n        currentY += maxCharHeight;\n        maxCharHeight = paddedHeight;\n        currentX = 0;\n        if (currentY + maxCharHeight > maxTextureHeight) {\n          textureSource.update();\n          const pageData2 = this._nextPage();\n          canvas = pageData2.canvasAndContext.canvas;\n          context = pageData2.canvasAndContext.context;\n          textureSource = pageData2.texture.source;\n          currentY = 0;\n        }\n      }\n      const xAdvance = width / fontScale - (style.dropShadow?.distance ?? 0) - (style._stroke?.width ?? 0);\n      this.chars[char] = {\n        id: char.codePointAt(0),\n        xOffset: -this._padding,\n        yOffset: -this._padding,\n        xAdvance,\n        kerning: {}\n      };\n      if (skipTexture) {\n        this._drawGlyph(context, metrics, currentX + padding, currentY + padding, fontScale, style);\n        const px = textureSource.width * fontScale;\n        const py = textureSource.height * fontScale;\n        const frame = new Rectangle(currentX / px * textureSource.width, currentY / py * textureSource.height, paddedWidth / px * textureSource.width, paddedHeight / py * textureSource.height);\n        this.chars[char].texture = new Texture({\n          source: textureSource,\n          frame\n        });\n        currentX += Math.ceil(paddedWidth);\n      }\n    }\n    textureSource.update();\n    this._currentX = currentX;\n    this._currentY = currentY;\n    this._skipKerning && this._applyKerning(charList, context);\n  }\n  /**\n   * @deprecated since 8.0.0\n   * The map of base page textures (i.e., sheets of glyphs).\n   */\n  get pageTextures() {\n    deprecation(v8_0_0, \"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.\");\n    return this.pages;\n  }\n  _applyKerning(newChars, context) {\n    const measureCache = this._measureCache;\n    for (let i = 0; i < newChars.length; i++) {\n      const first = newChars[i];\n      for (let j = 0; j < this._currentChars.length; j++) {\n        const second = this._currentChars[j];\n        let c1 = measureCache[first];\n        if (!c1) c1 = measureCache[first] = context.measureText(first).width;\n        let c2 = measureCache[second];\n        if (!c2) c2 = measureCache[second] = context.measureText(second).width;\n        let total = context.measureText(first + second).width;\n        let amount = total - (c1 + c2);\n        if (amount) {\n          this.chars[first].kerning[second] = amount;\n        }\n        total = context.measureText(first + second).width;\n        amount = total - (c1 + c2);\n        if (amount) {\n          this.chars[second].kerning[first] = amount;\n        }\n      }\n    }\n  }\n  _nextPage() {\n    this._currentPageIndex++;\n    const textureResolution = this.resolution;\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(this._textureSize, this._textureSize, textureResolution);\n    this._setupContext(canvasAndContext.context, this._style, textureResolution);\n    const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);\n    const texture = new Texture({\n      source: new ImageSource({\n        resource: canvasAndContext.canvas,\n        resolution,\n        alphaMode: \"premultiply-alpha-on-upload\",\n        autoGenerateMipmaps: this._mipmap\n      })\n    });\n    const pageData = {\n      canvasAndContext,\n      texture\n    };\n    this.pages[this._currentPageIndex] = pageData;\n    return pageData;\n  }\n  // canvas style!\n  _setupContext(context, style, resolution) {\n    style.fontSize = this.baseRenderedFontSize;\n    context.scale(resolution, resolution);\n    context.font = fontStringFromTextStyle(style);\n    style.fontSize = this.baseMeasurementFontSize;\n    context.textBaseline = style.textBaseline;\n    const stroke = style._stroke;\n    const strokeThickness = stroke?.width ?? 0;\n    if (stroke) {\n      context.lineWidth = strokeThickness;\n      context.lineJoin = stroke.join;\n      context.miterLimit = stroke.miterLimit;\n      context.strokeStyle = getCanvasFillStyle(stroke, context);\n    }\n    if (style._fill) {\n      context.fillStyle = getCanvasFillStyle(style._fill, context);\n    }\n    if (style.dropShadow) {\n      const shadowOptions = style.dropShadow;\n      const rgb = Color.shared.setValue(shadowOptions.color).toArray();\n      const dropShadowBlur = shadowOptions.blur * resolution;\n      const dropShadowDistance = shadowOptions.distance * resolution;\n      context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;\n      context.shadowBlur = dropShadowBlur;\n      context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n      context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;\n    } else {\n      context.shadowColor = \"black\";\n      context.shadowBlur = 0;\n      context.shadowOffsetX = 0;\n      context.shadowOffsetY = 0;\n    }\n  }\n  _drawGlyph(context, metrics, x, y, fontScale, style) {\n    const char = metrics.text;\n    const fontProperties = metrics.fontProperties;\n    const stroke = style._stroke;\n    const strokeThickness = (stroke?.width ?? 0) * fontScale;\n    const tx = x + strokeThickness / 2;\n    const ty = y - strokeThickness / 2;\n    const descent = fontProperties.descent * fontScale;\n    const lineHeight = metrics.lineHeight * fontScale;\n    if (style.stroke && strokeThickness) {\n      context.strokeText(char, tx, ty + lineHeight - descent);\n    }\n    if (style._fill) {\n      context.fillText(char, tx, ty + lineHeight - descent);\n    }\n  }\n  destroy() {\n    super.destroy();\n    for (let i = 0; i < this.pages.length; i++) {\n      const {\n        canvasAndContext,\n        texture\n      } = this.pages[i];\n      CanvasPool.returnCanvasAndContext(canvasAndContext);\n      texture.destroy(true);\n    }\n    this.pages = null;\n  }\n};\n_DynamicBitmapFont.defaultOptions = {\n  textureSize: 512,\n  style: new TextStyle(),\n  mipmap: true\n};\nlet DynamicBitmapFont = _DynamicBitmapFont;\nexport { DynamicBitmapFont };","map":{"version":3,"names":["_DynamicBitmapFont","AbstractBitmapFont","constructor","options","resolution","pages","_padding","_measureCache","Object","create","_currentChars","_currentX","_currentY","_currentPageIndex","_skipKerning","dynamicOptions","defaultOptions","_textureSize","textureSize","_mipmap","mipmap","style","clone","overrideFill","_fill","color","alpha","texture","Texture","WHITE","fill","applyFillAsTint","requestedFontSize","fontSize","baseMeasurementFontSize","font","fontStringFromTextStyle","overrideSize","_stroke","width","baseRenderedFontSize","_style","skipKerning","padding","fontMetrics","CanvasTextMetrics","measureFont","lineHeight","ensureCharacters","chars","charList","resolveCharacters","filter","char","includes","index","self","indexOf","length","pageData","_nextPage","canvas","context","canvasAndContext","textureSource","source","currentX","currentY","fontScale","maxCharHeight","skipTexture","maxTextureWidth","maxTextureHeight","height","i","metrics","measureText","textureGlyphWidth","Math","ceil","fontStyle","paddedWidth","paddedHeight","max","update","pageData2","xAdvance","dropShadow","distance","id","codePointAt","xOffset","yOffset","kerning","_drawGlyph","px","py","frame","Rectangle","_applyKerning","pageTextures","deprecation","v8_0_0","newChars","measureCache","first","j","second","c1","c2","total","amount","textureResolution","CanvasPool","getOptimalCanvasAndContext","_setupContext","ImageSource","resource","alphaMode","autoGenerateMipmaps","scale","textBaseline","stroke","strokeThickness","lineWidth","lineJoin","join","miterLimit","strokeStyle","getCanvasFillStyle","fillStyle","shadowOptions","rgb","Color","shared","setValue","toArray","dropShadowBlur","blur","dropShadowDistance","shadowColor","shadowBlur","shadowOffsetX","cos","angle","shadowOffsetY","sin","x","y","text","fontProperties","tx","ty","descent","strokeText","fillText","destroy","returnCanvasAndContext","TextStyle","DynamicBitmapFont"],"sources":["C:\\Users\\emalv\\OneDrive\\Desktop\\Portafolio\\cv-ciudad\\node_modules\\pixi.js\\src\\scene\\text-bitmap\\DynamicBitmapFont.ts"],"sourcesContent":["import { Color } from '../../color/Color';\nimport { Rectangle } from '../../maths/shapes/Rectangle';\nimport { CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport { ImageSource } from '../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics';\nimport { fontStringFromTextStyle } from '../text/canvas/utils/fontStringFromTextStyle';\nimport { getCanvasFillStyle } from '../text/canvas/utils/getCanvasFillStyle';\nimport { TextStyle } from '../text/TextStyle';\nimport { AbstractBitmapFont } from './AbstractBitmapFont';\nimport { resolveCharacters } from './utils/resolveCharacters';\n\nimport type { ICanvasRenderingContext2D } from '../../environment/canvas/ICanvasRenderingContext2D';\nimport type { CanvasAndContext } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\n\nexport interface DynamicBitmapFontOptions\n{\n    style: TextStyle\n    skipKerning?: boolean\n    resolution?: number\n    padding?: number\n    overrideFill?: boolean\n    overrideSize?: boolean\n    textureSize?: number\n    mipmap?: boolean\n}\n\n/**\n * A BitmapFont that generates its glyphs dynamically.\n * @memberof text\n * @ignore\n */\nexport class DynamicBitmapFont extends AbstractBitmapFont<DynamicBitmapFont>\n{\n    public static defaultOptions: DynamicBitmapFontOptions = {\n        textureSize: 512,\n        style: new TextStyle(),\n        mipmap: true,\n    };\n    /**\n     * this is a resolution modifier for the font size..\n     * texture resolution will also be used to scale texture according to its font size also\n     */\n    public resolution = 1;\n    /** The pages of the font. */\n    public override readonly pages: {canvasAndContext?: CanvasAndContext, texture: Texture}[] = [];\n\n    private readonly _padding: number = 0;\n    private readonly _measureCache: Record<string, number> = Object.create(null);\n    private _currentChars: string[] = [];\n    private _currentX = 0;\n    private _currentY = 0;\n    private _currentPageIndex = -1;\n    private readonly _style: TextStyle;\n    private readonly _skipKerning: boolean = false;\n    private readonly _textureSize: number;\n    private readonly _mipmap: boolean;\n\n    /**\n     * @param options - The options for the dynamic bitmap font.\n     */\n    constructor(options: DynamicBitmapFontOptions)\n    {\n        super();\n\n        const dynamicOptions = { ...DynamicBitmapFont.defaultOptions, ...options };\n\n        this._textureSize = dynamicOptions.textureSize;\n        this._mipmap = dynamicOptions.mipmap;\n\n        const style = dynamicOptions.style.clone();\n\n        if (dynamicOptions.overrideFill)\n        {\n            // assuming no shape fill..\n            style._fill.color = 0xffffff;\n            style._fill.alpha = 1;\n            style._fill.texture = Texture.WHITE;\n            style._fill.fill = null;\n        }\n\n        this.applyFillAsTint = dynamicOptions.overrideFill;\n\n        const requestedFontSize = style.fontSize;\n\n        // adjust font size to match the base measurement size\n        style.fontSize = this.baseMeasurementFontSize;\n\n        const font = fontStringFromTextStyle(style);\n\n        if (dynamicOptions.overrideSize)\n        {\n            if (style._stroke)\n            {\n                // we want the stroke to fit the size of the requested text, so we need to scale it\n                // accordingly (eg font size 20, with stroke 10 - stroke is 50% of size,\n                // as dynamic font is size 100, the stroke should be adjusted to 50 to make it look right)\n                style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;\n            }\n        }\n        else\n        {\n            style.fontSize = this.baseRenderedFontSize = requestedFontSize;\n        }\n\n        this._style = style;\n        this._skipKerning = dynamicOptions.skipKerning ?? false;\n        this.resolution = dynamicOptions.resolution ?? 1;\n        this._padding = dynamicOptions.padding ?? 4;\n\n        (this.fontMetrics as FontMetrics) = CanvasTextMetrics.measureFont(font);\n        (this.lineHeight as number) = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;\n    }\n\n    public ensureCharacters(chars: string): void\n    {\n        const charList = resolveCharacters(chars)\n            .filter((char) => !this._currentChars.includes(char))\n            .filter((char, index, self) => self.indexOf(char) === index);\n        // filter returns..\n\n        if (!charList.length) return;\n\n        this._currentChars = [...this._currentChars, ...charList];\n\n        let pageData;\n\n        if (this._currentPageIndex === -1)\n        {\n            pageData = this._nextPage();\n        }\n        else\n        {\n            pageData = this.pages[this._currentPageIndex];\n        }\n\n        let { canvas, context } = pageData.canvasAndContext;\n        let textureSource = pageData.texture.source;\n\n        const style = this._style;\n\n        let currentX = this._currentX;\n        let currentY = this._currentY;\n\n        const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;\n        const padding = this._padding * fontScale;\n\n        let maxCharHeight = 0;\n        let skipTexture = false;\n\n        const maxTextureWidth = canvas.width / this.resolution;\n        const maxTextureHeight = canvas.height / this.resolution;\n\n        for (let i = 0; i < charList.length; i++)\n        {\n            const char = charList[i];\n\n            const metrics = CanvasTextMetrics.measureText(char, style, canvas, false);\n\n            // override the line height.. we want this to be the glyps height\n            // not the user specified one.\n            metrics.lineHeight = metrics.height;\n\n            const width = metrics.width * fontScale;\n            // This is ugly - but italics are given more space so they don't overlap\n            const textureGlyphWidth = Math.ceil((style.fontStyle === 'italic' ? 2 : 1) * width);\n\n            const height = (metrics.height) * fontScale;\n\n            const paddedWidth = textureGlyphWidth + (padding * 2);\n            const paddedHeight = height + (padding * 2);\n\n            skipTexture = false;\n            // don't let empty characters count towards the maxCharHeight\n            if (char !== '\\n' && char !== '\\r' && char !== '\\t' && char !== ' ')\n            {\n                skipTexture = true;\n                maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));// / 1.5;\n            }\n\n            if (currentX + paddedWidth > maxTextureWidth)\n            {\n                currentY += maxCharHeight;\n\n                // reset the line x and height..\n                maxCharHeight = paddedHeight;\n                currentX = 0;\n\n                if (currentY + maxCharHeight > maxTextureHeight)\n                {\n                    textureSource.update();\n\n                    const pageData = this._nextPage();\n\n                    canvas = pageData.canvasAndContext.canvas;\n                    context = pageData.canvasAndContext.context;\n                    textureSource = pageData.texture.source;\n\n                    currentY = 0;\n                }\n            }\n\n            const xAdvance = (width / fontScale)\n                - (style.dropShadow?.distance ?? 0)\n                - (style._stroke?.width ?? 0);\n\n            // This is in coord space of the measurements.. not the texture\n            this.chars[char] = {\n                id: char.codePointAt(0),\n                xOffset: -this._padding,\n                yOffset: -this._padding,\n                xAdvance,\n                kerning: {},\n            };\n\n            if (skipTexture)\n            {\n                this._drawGlyph(\n                    context,\n                    metrics,\n                    currentX + padding,\n                    currentY + padding,\n                    fontScale,\n                    style,\n                );\n\n                const px = textureSource.width * fontScale;\n                const py = textureSource.height * fontScale;\n\n                const frame = new Rectangle(\n                    ((currentX) / px) * textureSource.width,\n                    ((currentY) / py) * textureSource.height,\n                    ((paddedWidth) / px) * textureSource.width,\n                    ((paddedHeight) / py) * textureSource.height,\n                );\n\n                this.chars[char].texture = new Texture({\n                    source: textureSource,\n                    frame,\n                });\n\n                currentX += Math.ceil(paddedWidth);\n            }\n\n            // now add it to the font data..\n        }\n\n        textureSource.update();\n\n        this._currentX = currentX;\n        this._currentY = currentY;\n\n        // now apply kerning..\n        this._skipKerning && this._applyKerning(charList, context);\n    }\n\n    /**\n     * @deprecated since 8.0.0\n     * The map of base page textures (i.e., sheets of glyphs).\n     */\n    public override get pageTextures(): DynamicBitmapFont['pages']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.');\n        // #endif\n\n        return this.pages;\n    }\n\n    private _applyKerning(newChars: string[], context: ICanvasRenderingContext2D): void\n    {\n        const measureCache = this._measureCache;\n\n        for (let i = 0; i < newChars.length; i++)\n        {\n            const first = newChars[i];\n\n            for (let j = 0; j < this._currentChars.length; j++)\n            {\n                // first go through new char being first\n                const second = this._currentChars[j];\n\n                let c1 = measureCache[first];\n\n                if (!c1) c1 = measureCache[first] = context.measureText(first).width;\n\n                let c2 = measureCache[second];\n\n                if (!c2) c2 = measureCache[second] = context.measureText(second).width;\n\n                let total = context.measureText(first + second).width;\n                let amount = total - (c1 + c2);\n\n                if (amount)\n                {\n                    this.chars[first].kerning[second] = amount;\n                }\n\n                // then go through new char being second\n                total = context.measureText(first + second).width;\n                amount = total - (c1 + c2);\n\n                if (amount)\n                {\n                    this.chars[second].kerning[first] = amount;\n                }\n            }\n        }\n    }\n\n    private _nextPage(): {canvasAndContext: CanvasAndContext, texture: Texture}\n    {\n        this._currentPageIndex++;\n\n        const textureResolution = this.resolution;\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(\n            this._textureSize,\n            this._textureSize,\n            textureResolution\n        );\n\n        this._setupContext(canvasAndContext.context, this._style, textureResolution);\n\n        const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);\n        const texture = new Texture({\n            source: new ImageSource({\n                resource: canvasAndContext.canvas,\n                resolution,\n                alphaMode: 'premultiply-alpha-on-upload',\n                autoGenerateMipmaps: this._mipmap,\n            }),\n\n        });\n\n        const pageData = {\n            canvasAndContext,\n            texture,\n        };\n\n        this.pages[this._currentPageIndex] = pageData;\n\n        return pageData;\n    }\n\n    // canvas style!\n    private _setupContext(context: ICanvasRenderingContext2D, style: TextStyle, resolution: number): void\n    {\n        style.fontSize = this.baseRenderedFontSize;\n        context.scale(resolution, resolution);\n        context.font = fontStringFromTextStyle(style);\n        style.fontSize = this.baseMeasurementFontSize;\n        context.textBaseline = style.textBaseline;\n\n        const stroke = style._stroke;\n        const strokeThickness = stroke?.width ?? 0;\n\n        if (stroke)\n        {\n            context.lineWidth = strokeThickness;\n            context.lineJoin = stroke.join;\n            context.miterLimit = stroke.miterLimit;\n\n            // TODO prolly cache this??\n            context.strokeStyle = getCanvasFillStyle(stroke, context);\n        }\n\n        if (style._fill)\n        {\n            // set canvas text styles\n            context.fillStyle = getCanvasFillStyle(style._fill, context);\n        }\n\n        if (style.dropShadow)\n        {\n            const shadowOptions = style.dropShadow;\n            const rgb = Color.shared.setValue(shadowOptions.color).toArray();\n\n            const dropShadowBlur = shadowOptions.blur * resolution;\n            const dropShadowDistance = shadowOptions.distance * resolution;\n\n            context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;\n            context.shadowBlur = dropShadowBlur;\n            context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n            context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;\n        }\n        else\n        {\n            context.shadowColor = 'black';\n            context.shadowBlur = 0;\n            context.shadowOffsetX = 0;\n            context.shadowOffsetY = 0;\n        }\n    }\n\n    private _drawGlyph(\n        context: ICanvasRenderingContext2D,\n        metrics: CanvasTextMetrics,\n        x: number,\n        y: number,\n        fontScale: number,\n        style: TextStyle\n    ): void\n    {\n        const char = metrics.text;\n        const fontProperties = metrics.fontProperties;\n        const stroke = style._stroke;\n\n        const strokeThickness = (stroke?.width ?? 0) * fontScale;\n\n        const tx = x + (strokeThickness / 2);\n        const ty = y - (strokeThickness / 2);\n\n        const descent = fontProperties.descent * fontScale;\n        const lineHeight = metrics.lineHeight * fontScale;\n\n        if (style.stroke && strokeThickness)\n        {\n            context.strokeText(char, tx, ty + lineHeight - descent);\n        }\n\n        if (style._fill)\n        {\n            context.fillText(char, tx, ty + lineHeight - descent);\n        }\n    }\n\n    public override destroy(): void\n    {\n        super.destroy();\n\n        for (let i = 0; i < this.pages.length; i++)\n        {\n            const { canvasAndContext, texture } = this.pages[i];\n\n            CanvasPool.returnCanvasAndContext(canvasAndContext);\n            texture.destroy(true);\n        }\n\n        (this.pages as null) = null;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}