{"ast":null,"code":"\"use strict\";\n\nconst WGSL_TO_STD40_SIZE = {\n  f32: 4,\n  i32: 4,\n  \"vec2<f32>\": 8,\n  \"vec3<f32>\": 12,\n  \"vec4<f32>\": 16,\n  \"vec2<i32>\": 8,\n  \"vec3<i32>\": 12,\n  \"vec4<i32>\": 16,\n  \"mat2x2<f32>\": 16 * 2,\n  \"mat3x3<f32>\": 16 * 3,\n  \"mat4x4<f32>\": 16 * 4\n  // TODO - not essential for now but support these in the future\n  // int:      4,\n  // ivec2:    8,\n  // ivec3:    12,\n  // ivec4:    16,\n  // uint:     4,\n  // uvec2:    8,\n  // uvec3:    12,\n  // uvec4:    16,\n  // bool:     4,\n  // bvec2:    8,\n  // bvec3:    12,\n  // bvec4:    16,\n  // mat2:     16 * 2,\n  // mat3:     16 * 3,\n  // mat4:     16 * 4,\n};\nfunction createUboElementsSTD40(uniformData) {\n  const uboElements = uniformData.map(data => ({\n    data,\n    offset: 0,\n    size: 0\n  }));\n  const chunkSize = 16;\n  let size = 0;\n  let offset = 0;\n  for (let i = 0; i < uboElements.length; i++) {\n    const uboElement = uboElements[i];\n    size = WGSL_TO_STD40_SIZE[uboElement.data.type];\n    if (!size) {\n      throw new Error(`Unknown type ${uboElement.data.type}`);\n    }\n    if (uboElement.data.size > 1) {\n      size = Math.max(size, chunkSize) * uboElement.data.size;\n    }\n    const boundary = size === 12 ? 16 : size;\n    uboElement.size = size;\n    const curOffset = offset % chunkSize;\n    if (curOffset > 0 && chunkSize - curOffset < boundary) {\n      offset += (chunkSize - curOffset) % 16;\n    } else {\n      offset += (size - curOffset % size) % size;\n    }\n    uboElement.offset = offset;\n    offset += size;\n  }\n  offset = Math.ceil(offset / 16) * 16;\n  return {\n    uboElements,\n    size: offset\n  };\n}\nexport { WGSL_TO_STD40_SIZE, createUboElementsSTD40 };","map":{"version":3,"names":["WGSL_TO_STD40_SIZE","f32","i32","createUboElementsSTD40","uniformData","uboElements","map","data","offset","size","chunkSize","i","length","uboElement","type","Error","Math","max","boundary","curOffset","ceil"],"sources":["C:\\Users\\emalv\\OneDrive\\Desktop\\Portafolio\\cv-ciudad\\node_modules\\pixi.js\\src\\rendering\\renderers\\gl\\shader\\utils\\createUboElementsSTD40.ts"],"sourcesContent":["import type { UboElement, UboLayout, UniformData } from '../../../shared/shader/types';\n\nexport const WGSL_TO_STD40_SIZE: Record<string, number> = {\n    f32: 4,\n    i32: 4,\n    'vec2<f32>': 8,\n    'vec3<f32>': 12,\n    'vec4<f32>': 16,\n\n    'vec2<i32>': 8,\n    'vec3<i32>': 12,\n    'vec4<i32>': 16,\n\n    'mat2x2<f32>': 16 * 2,\n    'mat3x3<f32>': 16 * 3,\n    'mat4x4<f32>': 16 * 4,\n\n    // TODO - not essential for now but support these in the future\n    // int:      4,\n    // ivec2:    8,\n    // ivec3:    12,\n    // ivec4:    16,\n\n    // uint:     4,\n    // uvec2:    8,\n    // uvec3:    12,\n    // uvec4:    16,\n\n    // bool:     4,\n    // bvec2:    8,\n    // bvec3:    12,\n    // bvec4:    16,\n\n    // mat2:     16 * 2,\n    // mat3:     16 * 3,\n    // mat4:     16 * 4,\n};\n\nexport function createUboElementsSTD40(uniformData: UniformData[]): UboLayout\n{\n    const uboElements: UboElement[] = uniformData.map((data: UniformData) =>\n        ({\n            data,\n            offset: 0,\n            size: 0,\n        }));\n\n    const chunkSize = 16;\n\n    let size = 0;\n    let offset = 0;\n\n    for (let i = 0; i < uboElements.length; i++)\n    {\n        const uboElement = uboElements[i];\n\n        size = WGSL_TO_STD40_SIZE[uboElement.data.type];\n\n        if (!size)\n        {\n            throw new Error(`Unknown type ${uboElement.data.type}`);\n        }\n\n        if (uboElement.data.size > 1)\n        {\n            size = Math.max(size, chunkSize) * uboElement.data.size;\n        }\n\n        const boundary = size === 12 ? 16 : size;\n\n        uboElement.size = size;\n\n        const curOffset = offset % chunkSize;\n\n        if (curOffset > 0 && chunkSize - curOffset < boundary)\n        {\n            offset += (chunkSize - curOffset) % 16;\n        }\n        else\n        {\n            offset += (size - (curOffset % size)) % size;\n        }\n\n        uboElement.offset = offset;\n        offset += size;\n    }\n\n    offset = Math.ceil(offset / 16) * 16;\n\n    return { uboElements, size: offset };\n}\n\n"],"mappings":";;AAEO,MAAMA,kBAA6C;EACtDC,GAAK;EACLC,GAAK;EACL,WAAa;EACb,WAAa;EACb,WAAa;EAEb,WAAa;EACb,WAAa;EACb,WAAa;EAEb,eAAe,EAAK;EACpB,eAAe,EAAK;EACpB,eAAe,EAAK;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;AAqBxB;AAEO,SAASC,uBAAuBC,WACvC;EACI,MAAMC,WAA4B,GAAAD,WAAA,CAAYE,GAAI,CAACC,IAC9C;IACGA,IAAA;IACAC,MAAQ;IACRC,IAAM;EAAA,CACR;EAEN,MAAMC,SAAY;EAElB,IAAID,IAAO;EACX,IAAID,MAAS;EAEb,SAASG,CAAI,MAAGA,CAAI,GAAAN,WAAA,CAAYO,MAAA,EAAQD,CACxC;IACU,MAAAE,UAAA,GAAaR,WAAA,CAAYM,CAAC;IAEzBF,IAAA,GAAAT,kBAAA,CAAmBa,UAAW,CAAAN,IAAA,CAAKO,IAAI;IAE9C,IAAI,CAACL,IACL;MACI,MAAM,IAAIM,KAAM,iBAAgBF,UAAW,CAAAN,IAAA,CAAKO,IAAI,EAAE;IAAA;IAGtD,IAAAD,UAAA,CAAWN,IAAK,CAAAE,IAAA,GAAO,CAC3B;MACIA,IAAA,GAAOO,IAAA,CAAKC,GAAI,CAAAR,IAAA,EAAMC,SAAS,IAAIG,UAAA,CAAWN,IAAK,CAAAE,IAAA;IAAA;IAGjD,MAAAS,QAAA,GAAWT,IAAS,UAAK,EAAK,GAAAA,IAAA;IAEpCI,UAAA,CAAWJ,IAAO,GAAAA,IAAA;IAElB,MAAMU,SAAA,GAAYX,MAAS,GAAAE,SAAA;IAE3B,IAAIS,SAAY,QAAKT,SAAY,GAAAS,SAAA,GAAYD,QAC7C;MACIV,MAAA,KAAWE,SAAA,GAAYS,SAAa;IAAA,CAGxC;MACeX,MAAA,KAAAC,IAAA,GAAQU,SAAA,GAAYV,IAAS,IAAAA,IAAA;IAAA;IAG5CI,UAAA,CAAWL,MAAS,GAAAA,MAAA;IACVA,MAAA,IAAAC,IAAA;EAAA;EAGdD,MAAA,GAASQ,IAAK,CAAAI,IAAA,CAAKZ,MAAS,KAAE,CAAI;EAE3B;IAAEH,WAAa;IAAAI,IAAA,EAAMD;EAAO;AACvC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}