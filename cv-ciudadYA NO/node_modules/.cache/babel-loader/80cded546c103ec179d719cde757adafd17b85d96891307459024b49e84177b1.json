{"ast":null,"code":"import { Point } from '../point/Point.mjs';\n\"use strict\";\nconst tempPoints = [new Point(), new Point(), new Point(), new Point()];\nclass Rectangle {\n  /**\n   * @param x - The X coordinate of the upper-left corner of the rectangle\n   * @param y - The Y coordinate of the upper-left corner of the rectangle\n   * @param width - The overall width of the rectangle\n   * @param height - The overall height of the rectangle\n   */\n  constructor(x = 0, y = 0, width = 0, height = 0) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'rectangle'\n     */\n    this.type = \"rectangle\";\n    this.x = Number(x);\n    this.y = Number(y);\n    this.width = Number(width);\n    this.height = Number(height);\n  }\n  /** Returns the left edge of the rectangle. */\n  get left() {\n    return this.x;\n  }\n  /** Returns the right edge of the rectangle. */\n  get right() {\n    return this.x + this.width;\n  }\n  /** Returns the top edge of the rectangle. */\n  get top() {\n    return this.y;\n  }\n  /** Returns the bottom edge of the rectangle. */\n  get bottom() {\n    return this.y + this.height;\n  }\n  /** Determines whether the Rectangle is empty. */\n  isEmpty() {\n    return this.left === this.right || this.top === this.bottom;\n  }\n  /** A constant empty rectangle. This is a new object every time the property is accessed */\n  static get EMPTY() {\n    return new Rectangle(0, 0, 0, 0);\n  }\n  /**\n   * Creates a clone of this Rectangle\n   * @returns a copy of the rectangle\n   */\n  clone() {\n    return new Rectangle(this.x, this.y, this.width, this.height);\n  }\n  /**\n   * Converts a Bounds object to a Rectangle object.\n   * @param bounds - The bounds to copy and convert to a rectangle.\n   * @returns Returns itself.\n   */\n  copyFromBounds(bounds) {\n    this.x = bounds.minX;\n    this.y = bounds.minY;\n    this.width = bounds.maxX - bounds.minX;\n    this.height = bounds.maxY - bounds.minY;\n    return this;\n  }\n  /**\n   * Copies another rectangle to this one.\n   * @param rectangle - The rectangle to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(rectangle) {\n    this.x = rectangle.x;\n    this.y = rectangle.y;\n    this.width = rectangle.width;\n    this.height = rectangle.height;\n    return this;\n  }\n  /**\n   * Copies this rectangle to another one.\n   * @param rectangle - The rectangle to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(rectangle) {\n    rectangle.copyFrom(this);\n    return rectangle;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this Rectangle\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coordinates are within this Rectangle\n   */\n  contains(x, y) {\n    if (this.width <= 0 || this.height <= 0) {\n      return false;\n    }\n    if (x >= this.x && x < this.x + this.width) {\n      if (y >= this.y && y < this.y + this.height) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @param alignment - The alignment of the stroke, 0.5 by default\n   * @returns Whether the x/y coordinates are within this rectangle\n   */\n  strokeContains(x, y, strokeWidth, alignment = 0.5) {\n    const {\n      width,\n      height\n    } = this;\n    if (width <= 0 || height <= 0) return false;\n    const _x = this.x;\n    const _y = this.y;\n    const strokeWidthOuter = strokeWidth * (1 - alignment);\n    const strokeWidthInner = strokeWidth - strokeWidthOuter;\n    const outerLeft = _x - strokeWidthOuter;\n    const outerRight = _x + width + strokeWidthOuter;\n    const outerTop = _y - strokeWidthOuter;\n    const outerBottom = _y + height + strokeWidthOuter;\n    const innerLeft = _x + strokeWidthInner;\n    const innerRight = _x + width - strokeWidthInner;\n    const innerTop = _y + strokeWidthInner;\n    const innerBottom = _y + height - strokeWidthInner;\n    return x >= outerLeft && x <= outerRight && y >= outerTop && y <= outerBottom && !(x > innerLeft && x < innerRight && y > innerTop && y < innerBottom);\n  }\n  /**\n   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.\n   * Returns true only if the area of the intersection is >0, this means that Rectangles\n   * sharing a side are not overlapping. Another side effect is that an arealess rectangle\n   * (width or height equal to zero) can't intersect any other rectangle.\n   * @param {Rectangle} other - The Rectangle to intersect with `this`.\n   * @param {Matrix} transform - The transformation matrix of `other`.\n   * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.\n   */\n  intersects(other, transform) {\n    if (!transform) {\n      const x02 = this.x < other.x ? other.x : this.x;\n      const x12 = this.right > other.right ? other.right : this.right;\n      if (x12 <= x02) {\n        return false;\n      }\n      const y02 = this.y < other.y ? other.y : this.y;\n      const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;\n      return y12 > y02;\n    }\n    const x0 = this.left;\n    const x1 = this.right;\n    const y0 = this.top;\n    const y1 = this.bottom;\n    if (x1 <= x0 || y1 <= y0) {\n      return false;\n    }\n    const lt = tempPoints[0].set(other.left, other.top);\n    const lb = tempPoints[1].set(other.left, other.bottom);\n    const rt = tempPoints[2].set(other.right, other.top);\n    const rb = tempPoints[3].set(other.right, other.bottom);\n    if (rt.x <= lt.x || lb.y <= lt.y) {\n      return false;\n    }\n    const s = Math.sign(transform.a * transform.d - transform.b * transform.c);\n    if (s === 0) {\n      return false;\n    }\n    transform.apply(lt, lt);\n    transform.apply(lb, lb);\n    transform.apply(rt, rt);\n    transform.apply(rb, rb);\n    if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {\n      return false;\n    }\n    const nx = s * (lb.y - lt.y);\n    const ny = s * (lt.x - lb.x);\n    const n00 = nx * x0 + ny * y0;\n    const n10 = nx * x1 + ny * y0;\n    const n01 = nx * x0 + ny * y1;\n    const n11 = nx * x1 + ny * y1;\n    if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {\n      return false;\n    }\n    const mx = s * (lt.y - rt.y);\n    const my = s * (rt.x - lt.x);\n    const m00 = mx * x0 + my * y0;\n    const m10 = mx * x1 + my * y0;\n    const m01 = mx * x0 + my * y1;\n    const m11 = mx * x1 + my * y1;\n    if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Pads the rectangle making it grow in all directions.\n   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n   * @param paddingX - The horizontal padding amount.\n   * @param paddingY - The vertical padding amount.\n   * @returns Returns itself.\n   */\n  pad(paddingX = 0, paddingY = paddingX) {\n    this.x -= paddingX;\n    this.y -= paddingY;\n    this.width += paddingX * 2;\n    this.height += paddingY * 2;\n    return this;\n  }\n  /**\n   * Fits this rectangle around the passed one.\n   * @param rectangle - The rectangle to fit.\n   * @returns Returns itself.\n   */\n  fit(rectangle) {\n    const x1 = Math.max(this.x, rectangle.x);\n    const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);\n    const y1 = Math.max(this.y, rectangle.y);\n    const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);\n    this.x = x1;\n    this.width = Math.max(x2 - x1, 0);\n    this.y = y1;\n    this.height = Math.max(y2 - y1, 0);\n    return this;\n  }\n  /**\n   * Enlarges rectangle that way its corners lie on grid\n   * @param resolution - resolution\n   * @param eps - precision\n   * @returns Returns itself.\n   */\n  ceil(resolution = 1, eps = 1e-3) {\n    const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;\n    const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;\n    this.x = Math.floor((this.x + eps) * resolution) / resolution;\n    this.y = Math.floor((this.y + eps) * resolution) / resolution;\n    this.width = x2 - this.x;\n    this.height = y2 - this.y;\n    return this;\n  }\n  /**\n   * Enlarges this rectangle to include the passed rectangle.\n   * @param rectangle - The rectangle to include.\n   * @returns Returns itself.\n   */\n  enlarge(rectangle) {\n    const x1 = Math.min(this.x, rectangle.x);\n    const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);\n    const y1 = Math.min(this.y, rectangle.y);\n    const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);\n    this.x = x1;\n    this.width = x2 - x1;\n    this.y = y1;\n    this.height = y2 - y1;\n    return this;\n  }\n  /**\n   * Returns the framing rectangle of the rectangle as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out || (out = new Rectangle());\n    out.copyFrom(this);\n    return out;\n  }\n  /**\n   * Checks if this rectangle fully contains another rectangle.\n   *\n   * A rectangle contains another rectangle if all four corners of the other rectangle\n   * lie within the bounds of this rectangle.\n   *\n   * ```ts\n   * const container = new Rectangle(0, 0, 100, 100);\n   * const inside = new Rectangle(25, 25, 50, 50);\n   * const partial = new Rectangle(75, 75, 50, 50);\n   *\n   * container.containsRect(inside); // Returns true\n   * container.containsRect(partial); // Returns false - partial overlap\n   * ```\n   *\n   * Note: If either rectangle has a width or height of 0, this method returns false\n   * since a zero-area rectangle cannot meaningfully contain another rectangle.\n   * @param other - The rectangle to check if it is contained within this one\n   * @returns True if the other rectangle is fully contained within this one\n   */\n  containsRect(other) {\n    if (this.width <= 0 || this.height <= 0) return false;\n    const x1 = other.x;\n    const y1 = other.y;\n    const x2 = other.x + other.width;\n    const y2 = other.y + other.height;\n    return x1 >= this.x && x1 < this.x + this.width && y1 >= this.y && y1 < this.y + this.height && x2 >= this.x && x2 < this.x + this.width && y2 >= this.y && y2 < this.y + this.height;\n  }\n  toString() {\n    return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;\n  }\n}\nexport { Rectangle };","map":{"version":3,"names":["tempPoints","Point","Rectangle","constructor","x","y","width","height","type","Number","left","right","top","bottom","isEmpty","EMPTY","clone","copyFromBounds","bounds","minX","minY","maxX","maxY","copyFrom","rectangle","copyTo","contains","strokeContains","strokeWidth","alignment","_x","_y","strokeWidthOuter","strokeWidthInner","outerLeft","outerRight","outerTop","outerBottom","innerLeft","innerRight","innerTop","innerBottom","intersects","other","transform","x02","x12","y02","y12","x0","x1","y0","y1","lt","set","lb","rt","rb","s","Math","sign","a","d","b","c","apply","max","min","nx","ny","n00","n10","n01","n11","mx","my","m00","m10","m01","m11","pad","paddingX","paddingY","fit","x2","y2","ceil","resolution","eps","floor","enlarge","getBounds","out","containsRect","toString"],"sources":["C:\\Users\\emalv\\OneDrive\\Desktop\\Portafolio\\cv-ciudad\\node_modules\\pixi.js\\src\\maths\\shapes\\Rectangle.ts"],"sourcesContent":["// import { SHAPES } from '../const';\nimport { Point } from '../point/Point';\n\nimport type { Bounds } from '../../scene/container/bounds/Bounds';\nimport type { Matrix } from '../matrix/Matrix';\nimport type { SHAPE_PRIMITIVE } from '../misc/const';\nimport type { ShapePrimitive } from './ShapePrimitive';\n\nconst tempPoints = [new Point(), new Point(), new Point(), new Point()];\n\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport interface Rectangle extends PixiMixins.Rectangle { }\n\n/**\n * The `Rectangle` object is an area defined by its position, as indicated by its top-left corner\n * point (`x`, `y`) and by its `width` and its `height`.\n *\n * It also provides convenience methods to get and set the position and size of the rectangle such as\n * {@link maths.Rectangle#bottom|bottom}, {@link maths.Rectangle#right|right} and {@link maths.Rectangle#isEmpty|isEmpty}.\n * @memberof maths\n */\nexport class Rectangle implements ShapePrimitive\n{\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'rectangle'\n     */\n    public readonly type: SHAPE_PRIMITIVE = 'rectangle';\n\n    /**\n     * The X coordinate of the upper-left corner of the rectangle\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the upper-left corner of the rectangle\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The overall width of this rectangle\n     *  @default 0\n     */\n    public width: number;\n\n    /**\n     * The overall height of this rectangle\n     * @default 0\n     */\n    public height: number;\n\n    /**\n     * @param x - The X coordinate of the upper-left corner of the rectangle\n     * @param y - The Y coordinate of the upper-left corner of the rectangle\n     * @param width - The overall width of the rectangle\n     * @param height - The overall height of the rectangle\n     */\n    constructor(x: string | number = 0, y: string | number = 0, width: string | number = 0, height: string | number = 0)\n    {\n        this.x = Number(x);\n        this.y = Number(y);\n        this.width = Number(width);\n        this.height = Number(height);\n    }\n\n    /** Returns the left edge of the rectangle. */\n    get left(): number\n    {\n        return this.x;\n    }\n\n    /** Returns the right edge of the rectangle. */\n    get right(): number\n    {\n        return this.x + this.width;\n    }\n\n    /** Returns the top edge of the rectangle. */\n    get top(): number\n    {\n        return this.y;\n    }\n\n    /** Returns the bottom edge of the rectangle. */\n    get bottom(): number\n    {\n        return this.y + this.height;\n    }\n\n    /** Determines whether the Rectangle is empty. */\n    public isEmpty(): boolean\n    {\n        return this.left === this.right || this.top === this.bottom;\n    }\n\n    /** A constant empty rectangle. This is a new object every time the property is accessed */\n    static get EMPTY(): Rectangle\n    {\n        return new Rectangle(0, 0, 0, 0);\n    }\n\n    /**\n     * Creates a clone of this Rectangle\n     * @returns a copy of the rectangle\n     */\n    public clone(): Rectangle\n    {\n        return new Rectangle(this.x, this.y, this.width, this.height);\n    }\n\n    /**\n     * Converts a Bounds object to a Rectangle object.\n     * @param bounds - The bounds to copy and convert to a rectangle.\n     * @returns Returns itself.\n     */\n    public copyFromBounds(bounds: Bounds): this\n    {\n        this.x = bounds.minX;\n        this.y = bounds.minY;\n        this.width = bounds.maxX - bounds.minX;\n        this.height = bounds.maxY - bounds.minY;\n\n        return this;\n    }\n\n    /**\n     * Copies another rectangle to this one.\n     * @param rectangle - The rectangle to copy from.\n     * @returns Returns itself.\n     */\n    public copyFrom(rectangle: Rectangle): Rectangle\n    {\n        this.x = rectangle.x;\n        this.y = rectangle.y;\n        this.width = rectangle.width;\n        this.height = rectangle.height;\n\n        return this;\n    }\n\n    /**\n     * Copies this rectangle to another one.\n     * @param rectangle - The rectangle to copy to.\n     * @returns Returns given parameter.\n     */\n    public copyTo(rectangle: Rectangle): Rectangle\n    {\n        rectangle.copyFrom(this);\n\n        return rectangle;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this Rectangle\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coordinates are within this Rectangle\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.width <= 0 || this.height <= 0)\n        {\n            return false;\n        }\n\n        if (x >= this.x && x < this.x + this.width)\n        {\n            if (y >= this.y && y < this.y + this.height)\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @param alignment - The alignment of the stroke, 0.5 by default\n     * @returns Whether the x/y coordinates are within this rectangle\n     */\n    public strokeContains(x: number, y: number, strokeWidth: number, alignment: number = 0.5): boolean\n    {\n        const { width, height } = this;\n\n        if (width <= 0 || height <= 0) return false;\n\n        const _x = this.x;\n        const _y = this.y;\n\n        const strokeWidthOuter = strokeWidth * (1 - alignment);\n        const strokeWidthInner = strokeWidth - strokeWidthOuter;\n\n        const outerLeft = _x - strokeWidthOuter;\n        const outerRight = _x + width + strokeWidthOuter;\n        const outerTop = _y - strokeWidthOuter;\n        const outerBottom = _y + height + strokeWidthOuter;\n\n        const innerLeft = _x + strokeWidthInner;\n        const innerRight = _x + width - strokeWidthInner;\n        const innerTop = _y + strokeWidthInner;\n        const innerBottom = _y + height - strokeWidthInner;\n\n        return (x >= outerLeft && x <= outerRight && y >= outerTop && y <= outerBottom)\n            && !(x > innerLeft && x < innerRight && y > innerTop && y < innerBottom);\n    }\n    /**\n     * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.\n     * Returns true only if the area of the intersection is >0, this means that Rectangles\n     * sharing a side are not overlapping. Another side effect is that an arealess rectangle\n     * (width or height equal to zero) can't intersect any other rectangle.\n     * @param {Rectangle} other - The Rectangle to intersect with `this`.\n     * @param {Matrix} transform - The transformation matrix of `other`.\n     * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.\n     */\n    public intersects(other: Rectangle, transform?: Matrix): boolean\n    {\n        if (!transform)\n        {\n            const x0 = this.x < other.x ? other.x : this.x;\n            const x1 = this.right > other.right ? other.right : this.right;\n\n            if (x1 <= x0)\n            {\n                return false;\n            }\n\n            const y0 = this.y < other.y ? other.y : this.y;\n            const y1 = this.bottom > other.bottom ? other.bottom : this.bottom;\n\n            return y1 > y0;\n        }\n\n        const x0 = this.left;\n        const x1 = this.right;\n        const y0 = this.top;\n        const y1 = this.bottom;\n\n        if (x1 <= x0 || y1 <= y0)\n        {\n            return false;\n        }\n\n        const lt = tempPoints[0].set(other.left, other.top);\n        const lb = tempPoints[1].set(other.left, other.bottom);\n        const rt = tempPoints[2].set(other.right, other.top);\n        const rb = tempPoints[3].set(other.right, other.bottom);\n\n        if (rt.x <= lt.x || lb.y <= lt.y)\n        {\n            return false;\n        }\n\n        const s = Math.sign((transform.a * transform.d) - (transform.b * transform.c));\n\n        if (s === 0)\n        {\n            return false;\n        }\n\n        transform.apply(lt, lt);\n        transform.apply(lb, lb);\n        transform.apply(rt, rt);\n        transform.apply(rb, rb);\n\n        if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0\n            || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1\n            || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0\n            || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1)\n        {\n            return false;\n        }\n\n        const nx = s * (lb.y - lt.y);\n        const ny = s * (lt.x - lb.x);\n        const n00 = (nx * x0) + (ny * y0);\n        const n10 = (nx * x1) + (ny * y0);\n        const n01 = (nx * x0) + (ny * y1);\n        const n11 = (nx * x1) + (ny * y1);\n\n        if (Math.max(n00, n10, n01, n11) <= (nx * lt.x) + (ny * lt.y)\n            || Math.min(n00, n10, n01, n11) >= (nx * rb.x) + (ny * rb.y))\n        {\n            return false;\n        }\n\n        const mx = s * (lt.y - rt.y);\n        const my = s * (rt.x - lt.x);\n        const m00 = (mx * x0) + (my * y0);\n        const m10 = (mx * x1) + (my * y0);\n        const m01 = (mx * x0) + (my * y1);\n        const m11 = (mx * x1) + (my * y1);\n\n        if (Math.max(m00, m10, m01, m11) <= (mx * lt.x) + (my * lt.y)\n            || Math.min(m00, m10, m01, m11) >= (mx * rb.x) + (my * rb.y))\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Pads the rectangle making it grow in all directions.\n     * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n     * @param paddingX - The horizontal padding amount.\n     * @param paddingY - The vertical padding amount.\n     * @returns Returns itself.\n     */\n    public pad(paddingX = 0, paddingY = paddingX): this\n    {\n        this.x -= paddingX;\n        this.y -= paddingY;\n\n        this.width += paddingX * 2;\n        this.height += paddingY * 2;\n\n        return this;\n    }\n\n    /**\n     * Fits this rectangle around the passed one.\n     * @param rectangle - The rectangle to fit.\n     * @returns Returns itself.\n     */\n    public fit(rectangle: Rectangle): this\n    {\n        const x1 = Math.max(this.x, rectangle.x);\n        const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);\n        const y1 = Math.max(this.y, rectangle.y);\n        const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);\n\n        this.x = x1;\n        this.width = Math.max(x2 - x1, 0);\n        this.y = y1;\n        this.height = Math.max(y2 - y1, 0);\n\n        return this;\n    }\n\n    /**\n     * Enlarges rectangle that way its corners lie on grid\n     * @param resolution - resolution\n     * @param eps - precision\n     * @returns Returns itself.\n     */\n    public ceil(resolution = 1, eps = 0.001): this\n    {\n        const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;\n        const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;\n\n        this.x = Math.floor((this.x + eps) * resolution) / resolution;\n        this.y = Math.floor((this.y + eps) * resolution) / resolution;\n\n        this.width = x2 - this.x;\n        this.height = y2 - this.y;\n\n        return this;\n    }\n\n    /**\n     * Enlarges this rectangle to include the passed rectangle.\n     * @param rectangle - The rectangle to include.\n     * @returns Returns itself.\n     */\n    public enlarge(rectangle: Rectangle): this\n    {\n        const x1 = Math.min(this.x, rectangle.x);\n        const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);\n        const y1 = Math.min(this.y, rectangle.y);\n        const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);\n\n        this.x = x1;\n        this.width = x2 - x1;\n        this.y = y1;\n        this.height = y2 - y1;\n\n        return this;\n    }\n\n    /**\n     * Returns the framing rectangle of the rectangle as a Rectangle object\n     * @param out - optional rectangle to store the result\n     * @returns The framing rectangle\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out ||= new Rectangle();\n        out.copyFrom(this);\n\n        return out;\n    }\n\n    /**\n     * Checks if this rectangle fully contains another rectangle.\n     *\n     * A rectangle contains another rectangle if all four corners of the other rectangle\n     * lie within the bounds of this rectangle.\n     *\n     * ```ts\n     * const container = new Rectangle(0, 0, 100, 100);\n     * const inside = new Rectangle(25, 25, 50, 50);\n     * const partial = new Rectangle(75, 75, 50, 50);\n     *\n     * container.containsRect(inside); // Returns true\n     * container.containsRect(partial); // Returns false - partial overlap\n     * ```\n     *\n     * Note: If either rectangle has a width or height of 0, this method returns false\n     * since a zero-area rectangle cannot meaningfully contain another rectangle.\n     * @param other - The rectangle to check if it is contained within this one\n     * @returns True if the other rectangle is fully contained within this one\n     */\n    public containsRect(other: Rectangle): boolean\n    {\n        if (this.width <= 0 || this.height <= 0) return false;\n\n        const x1 = other.x;\n        const y1 = other.y;\n        const x2 = other.x + other.width;\n        const y2 = other.y + other.height;\n\n        return x1 >= this.x && x1 < this.x + this.width\n            && y1 >= this.y && y1 < this.y + this.height\n            && x2 >= this.x && x2 < this.x + this.width\n            && y2 >= this.y && y2 < this.y + this.height;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;\n    }\n    // #endif\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}