{"ast":null,"code":"import { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet.mjs';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool.mjs';\n\"use strict\";\nclass RenderGroup {\n  constructor() {\n    this.renderPipeId = \"renderGroup\";\n    this.root = null;\n    this.canBundle = false;\n    this.renderGroupParent = null;\n    this.renderGroupChildren = [];\n    this.worldTransform = new Matrix();\n    this.worldColorAlpha = 4294967295;\n    this.worldColor = 16777215;\n    this.worldAlpha = 1;\n    // these updates are transform changes..\n    this.childrenToUpdate = /* @__PURE__ */Object.create(null);\n    this.updateTick = 0;\n    this.gcTick = 0;\n    // these update are renderable changes..\n    this.childrenRenderablesToUpdate = {\n      list: [],\n      index: 0\n    };\n    // other\n    this.structureDidChange = true;\n    this.instructionSet = new InstructionSet();\n    this._onRenderContainers = [];\n    /**\n     * Indicates if the cached texture needs to be updated.\n     * @default true\n     */\n    this.textureNeedsUpdate = true;\n    /**\n     * Indicates if the container should be cached as a texture.\n     * @default false\n     */\n    this.isCachedAsTexture = false;\n    this._matrixDirty = 7;\n  }\n  init(root) {\n    this.root = root;\n    if (root._onRender) this.addOnRender(root);\n    root.didChange = true;\n    const children = root.children;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      child._updateFlags = 15;\n      this.addChild(child);\n    }\n  }\n  enableCacheAsTexture(options = {}) {\n    this.textureOptions = options;\n    this.isCachedAsTexture = true;\n    this.textureNeedsUpdate = true;\n  }\n  disableCacheAsTexture() {\n    this.isCachedAsTexture = false;\n    if (this.texture) {\n      TexturePool.returnTexture(this.texture);\n      this.texture = null;\n    }\n  }\n  updateCacheTexture() {\n    this.textureNeedsUpdate = true;\n  }\n  reset() {\n    this.renderGroupChildren.length = 0;\n    for (const i in this.childrenToUpdate) {\n      const childrenAtDepth = this.childrenToUpdate[i];\n      childrenAtDepth.list.fill(null);\n      childrenAtDepth.index = 0;\n    }\n    this.childrenRenderablesToUpdate.index = 0;\n    this.childrenRenderablesToUpdate.list.fill(null);\n    this.root = null;\n    this.updateTick = 0;\n    this.structureDidChange = true;\n    this._onRenderContainers.length = 0;\n    this.renderGroupParent = null;\n    this.disableCacheAsTexture();\n  }\n  get localTransform() {\n    return this.root.localTransform;\n  }\n  addRenderGroupChild(renderGroupChild) {\n    if (renderGroupChild.renderGroupParent) {\n      renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);\n    }\n    renderGroupChild.renderGroupParent = this;\n    this.renderGroupChildren.push(renderGroupChild);\n  }\n  _removeRenderGroupChild(renderGroupChild) {\n    const index = this.renderGroupChildren.indexOf(renderGroupChild);\n    if (index > -1) {\n      this.renderGroupChildren.splice(index, 1);\n    }\n    renderGroupChild.renderGroupParent = null;\n  }\n  addChild(child) {\n    this.structureDidChange = true;\n    child.parentRenderGroup = this;\n    child.updateTick = -1;\n    if (child.parent === this.root) {\n      child.relativeRenderGroupDepth = 1;\n    } else {\n      child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;\n    }\n    child.didChange = true;\n    this.onChildUpdate(child);\n    if (child.renderGroup) {\n      this.addRenderGroupChild(child.renderGroup);\n      return;\n    }\n    if (child._onRender) this.addOnRender(child);\n    const children = child.children;\n    for (let i = 0; i < children.length; i++) {\n      this.addChild(children[i]);\n    }\n  }\n  removeChild(child) {\n    this.structureDidChange = true;\n    if (child._onRender) {\n      if (!child.renderGroup) {\n        this.removeOnRender(child);\n      }\n    }\n    child.parentRenderGroup = null;\n    if (child.renderGroup) {\n      this._removeRenderGroupChild(child.renderGroup);\n      return;\n    }\n    const children = child.children;\n    for (let i = 0; i < children.length; i++) {\n      this.removeChild(children[i]);\n    }\n  }\n  removeChildren(children) {\n    for (let i = 0; i < children.length; i++) {\n      this.removeChild(children[i]);\n    }\n  }\n  onChildUpdate(child) {\n    let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n    if (!childrenToUpdate) {\n      childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {\n        index: 0,\n        list: []\n      };\n    }\n    childrenToUpdate.list[childrenToUpdate.index++] = child;\n  }\n  updateRenderable(renderable) {\n    if (renderable.globalDisplayStatus < 7) return;\n    this.instructionSet.renderPipes[renderable.renderPipeId].updateRenderable(renderable);\n    renderable.didViewUpdate = false;\n  }\n  onChildViewUpdate(child) {\n    this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;\n  }\n  get isRenderable() {\n    return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;\n  }\n  /**\n   * adding a container to the onRender list will make sure the user function\n   * passed in to the user defined 'onRender` callBack\n   * @param container - the container to add to the onRender list\n   */\n  addOnRender(container) {\n    this._onRenderContainers.push(container);\n  }\n  removeOnRender(container) {\n    this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);\n  }\n  runOnRender(renderer) {\n    for (let i = 0; i < this._onRenderContainers.length; i++) {\n      this._onRenderContainers[i]._onRender(renderer);\n    }\n  }\n  destroy() {\n    this.disableCacheAsTexture();\n    this.renderGroupParent = null;\n    this.root = null;\n    this.childrenRenderablesToUpdate = null;\n    this.childrenToUpdate = null;\n    this.renderGroupChildren = null;\n    this._onRenderContainers = null;\n    this.instructionSet = null;\n  }\n  getChildren(out = []) {\n    const children = this.root.children;\n    for (let i = 0; i < children.length; i++) {\n      this._getChildren(children[i], out);\n    }\n    return out;\n  }\n  _getChildren(container, out = []) {\n    out.push(container);\n    if (container.renderGroup) return out;\n    const children = container.children;\n    for (let i = 0; i < children.length; i++) {\n      this._getChildren(children[i], out);\n    }\n    return out;\n  }\n  invalidateMatrices() {\n    this._matrixDirty = 7;\n  }\n  /**\n   * Returns the inverse of the world transform matrix.\n   * @returns {Matrix} The inverse of the world transform matrix.\n   */\n  get inverseWorldTransform() {\n    if ((this._matrixDirty & 1) === 0) return this._inverseWorldTransform;\n    this._matrixDirty &= ~1;\n    this._inverseWorldTransform || (this._inverseWorldTransform = new Matrix());\n    return this._inverseWorldTransform.copyFrom(this.worldTransform).invert();\n  }\n  /**\n   * Returns the inverse of the texture offset transform matrix.\n   * @returns {Matrix} The inverse of the texture offset transform matrix.\n   */\n  get textureOffsetInverseTransform() {\n    if ((this._matrixDirty & 2) === 0) return this._textureOffsetInverseTransform;\n    this._matrixDirty &= ~2;\n    this._textureOffsetInverseTransform || (this._textureOffsetInverseTransform = new Matrix());\n    return this._textureOffsetInverseTransform.copyFrom(this.inverseWorldTransform).translate(-this._textureBounds.x, -this._textureBounds.y);\n  }\n  /**\n   * Returns the inverse of the parent texture transform matrix.\n   * This is used to properly transform coordinates when rendering into cached textures.\n   * @returns {Matrix} The inverse of the parent texture transform matrix.\n   */\n  get inverseParentTextureTransform() {\n    if ((this._matrixDirty & 4) === 0) return this._inverseParentTextureTransform;\n    this._matrixDirty &= ~4;\n    const parentCacheAsTexture = this._parentCacheAsTextureRenderGroup;\n    if (parentCacheAsTexture) {\n      this._inverseParentTextureTransform || (this._inverseParentTextureTransform = new Matrix());\n      return this._inverseParentTextureTransform.copyFrom(this.worldTransform).prepend(parentCacheAsTexture.inverseWorldTransform).translate(-parentCacheAsTexture._textureBounds.x, -parentCacheAsTexture._textureBounds.y);\n    }\n    return this.worldTransform;\n  }\n  /**\n   * Returns a matrix that transforms coordinates to the correct coordinate space of the texture being rendered to.\n   * This is the texture offset inverse transform of the closest parent RenderGroup that is cached as a texture.\n   * @returns {Matrix | null} The transform matrix for the cached texture coordinate space,\n   * or null if no parent is cached as texture.\n   */\n  get cacheToLocalTransform() {\n    if (!this._parentCacheAsTextureRenderGroup) return null;\n    return this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform;\n  }\n}\nexport { RenderGroup };","map":{"version":3,"names":["RenderGroup","constructor","renderPipeId","root","canBundle","renderGroupParent","renderGroupChildren","worldTransform","Matrix","worldColorAlpha","worldColor","worldAlpha","childrenToUpdate","Object","create","updateTick","gcTick","childrenRenderablesToUpdate","list","index","structureDidChange","instructionSet","InstructionSet","_onRenderContainers","textureNeedsUpdate","isCachedAsTexture","_matrixDirty","init","_onRender","addOnRender","didChange","children","i","length","child","_updateFlags","addChild","enableCacheAsTexture","options","textureOptions","disableCacheAsTexture","texture","TexturePool","returnTexture","updateCacheTexture","reset","childrenAtDepth","fill","localTransform","addRenderGroupChild","renderGroupChild","_removeRenderGroupChild","push","indexOf","splice","parentRenderGroup","parent","relativeRenderGroupDepth","onChildUpdate","renderGroup","removeChild","removeOnRender","removeChildren","updateRenderable","renderable","globalDisplayStatus","renderPipes","didViewUpdate","onChildViewUpdate","isRenderable","localDisplayStatus","container","runOnRender","renderer","destroy","getChildren","out","_getChildren","invalidateMatrices","inverseWorldTransform","_inverseWorldTransform","copyFrom","invert","textureOffsetInverseTransform","_textureOffsetInverseTransform","translate","_textureBounds","x","y","inverseParentTextureTransform","_inverseParentTextureTransform","parentCacheAsTexture","_parentCacheAsTextureRenderGroup","prepend","cacheToLocalTransform"],"sources":["C:\\Users\\emalv\\OneDrive\\Desktop\\Portafolio\\cv-ciudad\\node_modules\\pixi.js\\src\\scene\\container\\RenderGroup.ts"],"sourcesContent":["import { Matrix } from '../../maths/matrix/Matrix';\nimport { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer } from '../../rendering/renderers/types';\n\nimport type { Instruction } from '../../rendering/renderers/shared/instructions/Instruction';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BatchableSprite } from '../sprite/BatchableSprite';\nimport type { ViewContainer } from '../view/ViewContainer';\nimport type { Bounds } from './bounds/Bounds';\nimport type { Container } from './Container';\n\n/**\n * Options for caching a container as a texture.\n * @memberof rendering\n * @see {@link RenderGroup#textureOptions}\n */\nexport interface CacheAsTextureOptions\n{\n    /**\n     * If true, the texture will be antialiased. This smooths out the edges of the texture.\n     * @default false\n     */\n    antialias?: boolean;\n    /**\n     * The resolution of the texture. A higher resolution means a sharper texture but uses more memory.\n     * By default the resolution is 1 which is the same as the rendererers resolution.\n     */\n    resolution?: number;\n}\n\n/**\n * A RenderGroup is a class that is responsible for I generating a set of instructions that are used to render the\n * root container and its children. It also watches for any changes in that container or its children,\n * these changes are analysed and either the instruction set is rebuild or the instructions data is updated.\n * @memberof rendering\n */\nexport class RenderGroup implements Instruction\n{\n    public renderPipeId = 'renderGroup';\n    public root: Container = null;\n\n    public canBundle = false;\n\n    public renderGroupParent: RenderGroup = null;\n    public renderGroupChildren: RenderGroup[] = [];\n\n    public worldTransform: Matrix = new Matrix();\n    public worldColorAlpha = 0xffffffff;\n    public worldColor = 0xffffff;\n    public worldAlpha = 1;\n\n    // these updates are transform changes..\n    public readonly childrenToUpdate: Record<number, { list: Container[]; index: number; }> = Object.create(null);\n    public updateTick = 0;\n    public gcTick = 0;\n\n    // these update are renderable changes..\n    public readonly childrenRenderablesToUpdate: { list: Container[]; index: number; } = { list: [], index: 0 };\n\n    // other\n    public structureDidChange = true;\n\n    public instructionSet: InstructionSet = new InstructionSet();\n\n    private readonly _onRenderContainers: Container[] = [];\n\n    /**\n     * Indicates if the cached texture needs to be updated.\n     * @default true\n     */\n    public textureNeedsUpdate = true;\n\n    /**\n     * Indicates if the container should be cached as a texture.\n     * @default false\n     */\n    public isCachedAsTexture = false;\n\n    /**\n     * The texture used for caching the container. this is only set if isCachedAsTexture is true.\n     * It can only be accessed after a render pass.\n     * @type {Texture | undefined}\n     */\n    public texture?: Texture;\n\n    /**\n     * The bounds of the cached texture.\n     * @type {Bounds | undefined}\n     * @ignore\n     */\n    public _textureBounds?: Bounds;\n\n    /**\n     * The options for caching the container as a texture.\n     * @type {CacheAsTextureOptions}\n     */\n    public textureOptions: CacheAsTextureOptions;\n\n    /**\n     *  holds a reference to the batchable render sprite\n     *  @ignore\n     */\n    public _batchableRenderGroup: BatchableSprite;\n\n    /**\n     * Holds a reference to the closest parent RenderGroup that has isCachedAsTexture enabled.\n     * This is used to properly transform coordinates when rendering into cached textures.\n     * @type {RenderGroup | null}\n     * @ignore\n     */\n    public _parentCacheAsTextureRenderGroup: RenderGroup;\n\n    private _inverseWorldTransform: Matrix;\n    private _textureOffsetInverseTransform: Matrix;\n    private _inverseParentTextureTransform: Matrix;\n\n    private _matrixDirty = 0b111;\n\n    public init(root: Container)\n    {\n        this.root = root;\n\n        if (root._onRender) this.addOnRender(root);\n\n        root.didChange = true;\n\n        const children = root.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            const child = children[i];\n\n            // make sure the children are all updated on the first pass..\n            child._updateFlags = 0b1111;\n\n            this.addChild(child);\n        }\n    }\n\n    public enableCacheAsTexture(options: CacheAsTextureOptions = {}): void\n    {\n        this.textureOptions = options;\n        this.isCachedAsTexture = true;\n        this.textureNeedsUpdate = true;\n    }\n\n    public disableCacheAsTexture(): void\n    {\n        this.isCachedAsTexture = false;\n        if (this.texture)\n        {\n            TexturePool.returnTexture(this.texture);\n            this.texture = null;\n        }\n    }\n\n    public updateCacheTexture(): void\n    {\n        this.textureNeedsUpdate = true;\n    }\n\n    public reset()\n    {\n        this.renderGroupChildren.length = 0;\n\n        for (const i in this.childrenToUpdate)\n        {\n            const childrenAtDepth = this.childrenToUpdate[i];\n\n            childrenAtDepth.list.fill(null);\n            childrenAtDepth.index = 0;\n        }\n\n        this.childrenRenderablesToUpdate.index = 0;\n        this.childrenRenderablesToUpdate.list.fill(null);\n\n        this.root = null;\n        this.updateTick = 0;\n        this.structureDidChange = true;\n\n        this._onRenderContainers.length = 0;\n        this.renderGroupParent = null;\n\n        this.disableCacheAsTexture();\n    }\n\n    get localTransform()\n    {\n        return this.root.localTransform;\n    }\n\n    public addRenderGroupChild(renderGroupChild: RenderGroup)\n    {\n        if (renderGroupChild.renderGroupParent)\n        {\n            renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);\n        }\n\n        renderGroupChild.renderGroupParent = this;\n\n        this.renderGroupChildren.push(renderGroupChild);\n    }\n\n    private _removeRenderGroupChild(renderGroupChild: RenderGroup)\n    {\n        const index = this.renderGroupChildren.indexOf(renderGroupChild);\n\n        if (index > -1)\n        {\n            this.renderGroupChildren.splice(index, 1);\n        }\n\n        renderGroupChild.renderGroupParent = null;\n    }\n\n    public addChild(child: Container)\n    {\n        this.structureDidChange = true;\n\n        child.parentRenderGroup = this;\n\n        child.updateTick = -1;\n\n        if (child.parent === this.root)\n        {\n            child.relativeRenderGroupDepth = 1;\n        }\n        else\n        {\n            child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;\n        }\n\n        child.didChange = true;\n        this.onChildUpdate(child);\n\n        if (child.renderGroup)\n        {\n            this.addRenderGroupChild(child.renderGroup);\n\n            return;\n        }\n\n        if (child._onRender) this.addOnRender(child);\n\n        const children = child.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this.addChild(children[i]);\n        }\n    }\n\n    public removeChild(child: Container)\n    {\n        // remove all the children...\n        this.structureDidChange = true;\n\n        if (child._onRender)\n        {\n            // Remove the child to the onRender list under the following conditions:\n            // 1. If the child is not a render group.\n            // 2. If the child is a render group root of this render group - which it can't be removed from in this case.\n            if (!child.renderGroup)\n            {\n                this.removeOnRender(child);\n            }\n        }\n\n        child.parentRenderGroup = null;\n\n        if (child.renderGroup)\n        {\n            this._removeRenderGroupChild(child.renderGroup);\n\n            return;\n        }\n\n        const children = child.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this.removeChild(children[i]);\n        }\n    }\n\n    public removeChildren(children: Container[])\n    {\n        for (let i = 0; i < children.length; i++)\n        {\n            this.removeChild(children[i]);\n        }\n    }\n\n    public onChildUpdate(child: Container)\n    {\n        let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n\n        if (!childrenToUpdate)\n        {\n            childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {\n                index: 0,\n                list: [],\n            };\n        }\n\n        childrenToUpdate.list[childrenToUpdate.index++] = child;\n    }\n\n    public updateRenderable(renderable: ViewContainer)\n    {\n        if (renderable.globalDisplayStatus < 0b111) return;\n        this.instructionSet.renderPipes[renderable.renderPipeId].updateRenderable(renderable);\n        renderable.didViewUpdate = false;\n    }\n\n    public onChildViewUpdate(child: Container)\n    {\n        this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;\n    }\n\n    get isRenderable(): boolean\n    {\n        return (this.root.localDisplayStatus === 0b111 && this.worldAlpha > 0);\n    }\n\n    /**\n     * adding a container to the onRender list will make sure the user function\n     * passed in to the user defined 'onRender` callBack\n     * @param container - the container to add to the onRender list\n     */\n    public addOnRender(container: Container)\n    {\n        this._onRenderContainers.push(container);\n    }\n\n    public removeOnRender(container: Container)\n    {\n        this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);\n    }\n\n    public runOnRender(renderer: Renderer)\n    {\n        for (let i = 0; i < this._onRenderContainers.length; i++)\n        {\n            this._onRenderContainers[i]._onRender(renderer);\n        }\n    }\n\n    public destroy()\n    {\n        this.disableCacheAsTexture();\n\n        this.renderGroupParent = null;\n        this.root = null;\n        (this.childrenRenderablesToUpdate as any) = null;\n        (this.childrenToUpdate as any) = null;\n        (this.renderGroupChildren as any) = null;\n        (this._onRenderContainers as any) = null;\n        this.instructionSet = null;\n    }\n\n    public getChildren(out: Container[] = []): Container[]\n    {\n        const children = this.root.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this._getChildren(children[i], out);\n        }\n\n        return out;\n    }\n\n    private _getChildren(container: Container, out: Container[] = []): Container[]\n    {\n        out.push(container);\n\n        if (container.renderGroup) return out;\n\n        const children = container.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this._getChildren(children[i], out);\n        }\n\n        return out;\n    }\n\n    public invalidateMatrices()\n    {\n        this._matrixDirty = 0b111;\n    }\n\n    /**\n     * Returns the inverse of the world transform matrix.\n     * @returns {Matrix} The inverse of the world transform matrix.\n     */\n    public get inverseWorldTransform()\n    {\n        if ((this._matrixDirty & 0b001) === 0) return this._inverseWorldTransform;\n\n        this._matrixDirty &= ~0b001;\n\n        // TODO - add dirty flag\n        this._inverseWorldTransform ||= new Matrix();\n\n        return this._inverseWorldTransform\n            .copyFrom(this.worldTransform)\n            .invert();\n    }\n\n    /**\n     * Returns the inverse of the texture offset transform matrix.\n     * @returns {Matrix} The inverse of the texture offset transform matrix.\n     */\n    public get textureOffsetInverseTransform()\n    {\n        if ((this._matrixDirty & 0b010) === 0) return this._textureOffsetInverseTransform;\n\n        this._matrixDirty &= ~0b010;\n\n        this._textureOffsetInverseTransform ||= new Matrix();\n\n        // TODO shared.. bad!\n        return this._textureOffsetInverseTransform\n            .copyFrom(this.inverseWorldTransform)\n            .translate(\n                -this._textureBounds.x,\n                -this._textureBounds.y\n            );\n    }\n\n    /**\n     * Returns the inverse of the parent texture transform matrix.\n     * This is used to properly transform coordinates when rendering into cached textures.\n     * @returns {Matrix} The inverse of the parent texture transform matrix.\n     */\n    public get inverseParentTextureTransform()\n    {\n        if ((this._matrixDirty & 0b100) === 0) return this._inverseParentTextureTransform;\n\n        this._matrixDirty &= ~0b100;\n\n        const parentCacheAsTexture = this._parentCacheAsTextureRenderGroup;\n\n        if (parentCacheAsTexture)\n        {\n            this._inverseParentTextureTransform ||= new Matrix();\n\n            // Get relative transform by removing parent's world transform\n            return this._inverseParentTextureTransform\n                .copyFrom(this.worldTransform)\n                .prepend(parentCacheAsTexture.inverseWorldTransform)\n                // Offset by texture bounds\n                .translate(\n                    -parentCacheAsTexture._textureBounds.x,\n                    -parentCacheAsTexture._textureBounds.y\n                );\n        }\n\n        return this.worldTransform;\n    }\n\n    /**\n     * Returns a matrix that transforms coordinates to the correct coordinate space of the texture being rendered to.\n     * This is the texture offset inverse transform of the closest parent RenderGroup that is cached as a texture.\n     * @returns {Matrix | null} The transform matrix for the cached texture coordinate space,\n     * or null if no parent is cached as texture.\n     */\n    public get cacheToLocalTransform()\n    {\n        if (!this._parentCacheAsTextureRenderGroup) return null;\n\n        return this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}