{"ast":null,"code":"import { FilterEffect } from '../../../filters/FilterEffect.mjs';\nimport { MaskEffectManager } from '../../../rendering/mask/MaskEffectManager.mjs';\n\"use strict\";\nconst effectsMixin = {\n  _maskEffect: null,\n  _maskOptions: {\n    inverse: false\n  },\n  _filterEffect: null,\n  /**\n   * @todo Needs docs.\n   * @memberof scene.Container#\n   * @type {Array<Effect>}\n   */\n  effects: [],\n  _markStructureAsChanged() {\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.structureDidChange = true;\n    }\n  },\n  /**\n   * @todo Needs docs.\n   * @param effect - The effect to add.\n   * @memberof scene.Container#\n   * @ignore\n   */\n  addEffect(effect) {\n    const index = this.effects.indexOf(effect);\n    if (index !== -1) return;\n    this.effects.push(effect);\n    this.effects.sort((a, b) => a.priority - b.priority);\n    this._markStructureAsChanged();\n    this._updateIsSimple();\n  },\n  /**\n   * @todo Needs docs.\n   * @param effect - The effect to remove.\n   * @memberof scene.Container#\n   * @ignore\n   */\n  removeEffect(effect) {\n    const index = this.effects.indexOf(effect);\n    if (index === -1) return;\n    this.effects.splice(index, 1);\n    this._markStructureAsChanged();\n    this._updateIsSimple();\n  },\n  set mask(value) {\n    const effect = this._maskEffect;\n    if (effect?.mask === value) return;\n    if (effect) {\n      this.removeEffect(effect);\n      MaskEffectManager.returnMaskEffect(effect);\n      this._maskEffect = null;\n    }\n    if (value === null || value === void 0) return;\n    this._maskEffect = MaskEffectManager.getMaskEffect(value);\n    this.addEffect(this._maskEffect);\n  },\n  /**\n   * Used to set mask and control mask options.\n   * @param options\n   * @example\n   * import { Graphics, Sprite } from 'pixi.js';\n   *\n   * const graphics = new Graphics();\n   * graphics.beginFill(0xFF3300);\n   * graphics.drawRect(50, 250, 100, 100);\n   * graphics.endFill();\n   *\n   * const sprite = new Sprite(texture);\n   * sprite.setMask({\n   *     mask: graphics,\n   *     inverse: true,\n   * });\n   * @memberof scene.Container#\n   */\n  setMask(options) {\n    this._maskOptions = {\n      ...this._maskOptions,\n      ...options\n    };\n    if (options.mask) {\n      this.mask = options.mask;\n    }\n    this._markStructureAsChanged();\n  },\n  /**\n   * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n   * object to the shape of the mask applied to it. In PixiJS a regular mask must be a\n   * {@link Graphics} or a {@link Sprite} object. This allows for much faster masking in canvas as it\n   * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.\n   * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.\n   * To remove a mask, set this property to `null`.\n   *\n   * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n   * @example\n   * import { Graphics, Sprite } from 'pixi.js';\n   *\n   * const graphics = new Graphics();\n   * graphics.beginFill(0xFF3300);\n   * graphics.drawRect(50, 250, 100, 100);\n   * graphics.endFill();\n   *\n   * const sprite = new Sprite(texture);\n   * sprite.mask = graphics;\n   * @memberof scene.Container#\n   */\n  get mask() {\n    return this._maskEffect?.mask;\n  },\n  set filters(value) {\n    if (!Array.isArray(value) && value) value = [value];\n    const effect = this._filterEffect || (this._filterEffect = new FilterEffect());\n    value = value;\n    const hasFilters = value?.length > 0;\n    const hadFilters = effect.filters?.length > 0;\n    const didChange = hasFilters !== hadFilters;\n    value = Array.isArray(value) ? value.slice(0) : value;\n    effect.filters = Object.freeze(value);\n    if (didChange) {\n      if (hasFilters) {\n        this.addEffect(effect);\n      } else {\n        this.removeEffect(effect);\n        effect.filters = value ?? null;\n      }\n    }\n  },\n  /**\n   * Sets the filters for the displayObject.\n   * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n   * To remove filters simply set this property to `'null'`.\n   * @memberof scene.Container#\n   */\n  get filters() {\n    return this._filterEffect?.filters;\n  },\n  set filterArea(value) {\n    this._filterEffect || (this._filterEffect = new FilterEffect());\n    this._filterEffect.filterArea = value;\n  },\n  /**\n   * The area the filter is applied to. This is used as more of an optimization\n   * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.\n   *\n   * Also works as an interaction mask.\n   * @memberof scene.Container#\n   */\n  get filterArea() {\n    return this._filterEffect?.filterArea;\n  }\n};\nexport { effectsMixin };","map":{"version":3,"names":["effectsMixin","_maskEffect","_maskOptions","inverse","_filterEffect","effects","_markStructureAsChanged","renderGroup","parentRenderGroup","structureDidChange","addEffect","effect","index","indexOf","push","sort","a","b","priority","_updateIsSimple","removeEffect","splice","mask","value","MaskEffectManager","returnMaskEffect","getMaskEffect","setMask","options","filters","Array","isArray","FilterEffect","hasFilters","length","hadFilters","didChange","slice","Object","freeze","filterArea"],"sources":["C:\\Users\\emalv\\OneDrive\\Desktop\\Portafolio\\cv-ciudad\\node_modules\\pixi.js\\src\\scene\\container\\container-mixins\\effectsMixin.ts"],"sourcesContent":["import { FilterEffect } from '../../../filters/FilterEffect';\nimport { MaskEffectManager } from '../../../rendering/mask/MaskEffectManager';\n\nimport type { Filter } from '../../../filters/Filter';\nimport type { Rectangle } from '../../../maths/shapes/Rectangle';\nimport type { MaskEffect } from '../../../rendering/mask/MaskEffectManager';\nimport type { Container } from '../Container';\nimport type { Effect } from '../Effect';\n\nexport interface EffectsMixinConstructor\n{\n    mask?: Mask;\n    setMask?: (options: Partial<MaskOptionsAndMask>) => void;\n    filters?: Filter | Filter[];\n}\n\nexport type Mask = number | Container | null;\n\nexport interface MaskOptions\n{\n    inverse: boolean;\n}\n\nexport interface MaskOptionsAndMask extends MaskOptions\n{\n    mask: Mask;\n}\n\nexport interface EffectsMixin extends Required<EffectsMixinConstructor>\n{\n    _maskEffect?: MaskEffect;\n    _maskOptions?: MaskOptions;\n    _filterEffect?: FilterEffect,\n\n    filterArea?: Rectangle,\n    effects?: Effect[];\n\n    _markStructureAsChanged(): void;\n    addEffect(effect: Effect): void;\n    removeEffect(effect: Effect): void;\n}\n\nexport const effectsMixin: Partial<Container> = {\n    _maskEffect: null,\n    _maskOptions: {\n        inverse: false,\n    },\n    _filterEffect: null,\n\n    /**\n     * @todo Needs docs.\n     * @memberof scene.Container#\n     * @type {Array<Effect>}\n     */\n    effects: [],\n\n    _markStructureAsChanged()\n    {\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.structureDidChange = true;\n        }\n    },\n    /**\n     * @todo Needs docs.\n     * @param effect - The effect to add.\n     * @memberof scene.Container#\n     * @ignore\n     */\n    addEffect(effect: Effect)\n    {\n        const index = this.effects.indexOf(effect);\n\n        if (index !== -1) return; // already exists!\n\n        this.effects.push(effect);\n\n        this.effects.sort((a, b) => a.priority - b.priority);\n\n        this._markStructureAsChanged();\n\n        // if (this.renderGroup)\n        // {\n        //     this.renderGroup.structureDidChange = true;\n        // }\n\n        this._updateIsSimple();\n    },\n    /**\n     * @todo Needs docs.\n     * @param effect - The effect to remove.\n     * @memberof scene.Container#\n     * @ignore\n     */\n    removeEffect(effect: Effect)\n    {\n        const index = this.effects.indexOf(effect);\n\n        if (index === -1) return; // already exists!\n\n        this.effects.splice(index, 1);\n\n        this._markStructureAsChanged();\n\n        this._updateIsSimple();\n    },\n\n    set mask(value: Mask)\n    {\n        const effect = this._maskEffect;\n\n        if (effect?.mask === value) return;\n\n        if (effect)\n        {\n            this.removeEffect(effect);\n\n            MaskEffectManager.returnMaskEffect(effect);\n\n            this._maskEffect = null;\n        }\n\n        if (value === null || value === undefined) return;\n\n        this._maskEffect = MaskEffectManager.getMaskEffect(value);\n\n        this.addEffect(this._maskEffect);\n    },\n\n    /**\n     * Used to set mask and control mask options.\n     * @param options\n     * @example\n     * import { Graphics, Sprite } from 'pixi.js';\n     *\n     * const graphics = new Graphics();\n     * graphics.beginFill(0xFF3300);\n     * graphics.drawRect(50, 250, 100, 100);\n     * graphics.endFill();\n     *\n     * const sprite = new Sprite(texture);\n     * sprite.setMask({\n     *     mask: graphics,\n     *     inverse: true,\n     * });\n     * @memberof scene.Container#\n     */\n    setMask(options: Partial<MaskOptionsAndMask>)\n    {\n        this._maskOptions = {\n            ...this._maskOptions,\n            ...options,\n        };\n\n        if (options.mask)\n        {\n            this.mask = options.mask;\n        }\n\n        this._markStructureAsChanged();\n    },\n\n    /**\n     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n     * object to the shape of the mask applied to it. In PixiJS a regular mask must be a\n     * {@link Graphics} or a {@link Sprite} object. This allows for much faster masking in canvas as it\n     * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.\n     * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.\n     * To remove a mask, set this property to `null`.\n     *\n     * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n     * @example\n     * import { Graphics, Sprite } from 'pixi.js';\n     *\n     * const graphics = new Graphics();\n     * graphics.beginFill(0xFF3300);\n     * graphics.drawRect(50, 250, 100, 100);\n     * graphics.endFill();\n     *\n     * const sprite = new Sprite(texture);\n     * sprite.mask = graphics;\n     * @memberof scene.Container#\n     */\n    get mask(): unknown\n    {\n        return this._maskEffect?.mask;\n    },\n\n    set filters(value: Filter | Filter[] | null | undefined)\n    {\n        if (!Array.isArray(value) && value) value = [value];\n\n        const effect = this._filterEffect ||= new FilterEffect();\n\n        // Ignore the Filter type\n        value = value as Filter[] | null | undefined;\n\n        const hasFilters = value?.length > 0;\n        const hadFilters = effect.filters?.length > 0;\n\n        const didChange = hasFilters !== hadFilters;\n\n        // Clone the filters array so we don't freeze the user-input\n        value = Array.isArray(value) ? value.slice(0) : value;\n\n        // Ensure filters are immutable via filters getter\n        effect.filters = Object.freeze(value);\n\n        if (didChange)\n        {\n            if (hasFilters)\n            {\n                this.addEffect(effect);\n            }\n            else\n            {\n                this.removeEffect(effect);\n\n                // sets the empty array...\n                effect.filters = value ?? null;\n            }\n        }\n    },\n\n    /**\n     * Sets the filters for the displayObject.\n     * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n     * To remove filters simply set this property to `'null'`.\n     * @memberof scene.Container#\n     */\n    get filters(): readonly Filter[]\n    {\n        return this._filterEffect?.filters;\n    },\n\n    set filterArea(value: Rectangle)\n    {\n        this._filterEffect ||= new FilterEffect();\n\n        this._filterEffect.filterArea = value;\n    },\n\n    /**\n     * The area the filter is applied to. This is used as more of an optimization\n     * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.\n     *\n     * Also works as an interaction mask.\n     * @memberof scene.Container#\n     */\n    get filterArea(): Rectangle\n    {\n        return this._filterEffect?.filterArea;\n    },\n\n} as Container;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}