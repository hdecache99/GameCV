{"ast":null,"code":"import { Circle } from '../../../../maths/shapes/Circle.mjs';\nimport { Ellipse } from '../../../../maths/shapes/Ellipse.mjs';\nimport { Polygon } from '../../../../maths/shapes/Polygon.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { RoundedRectangle } from '../../../../maths/shapes/RoundedRectangle.mjs';\nimport { Bounds } from '../../../container/bounds/Bounds.mjs';\nimport { buildAdaptiveBezier } from '../buildCommands/buildAdaptiveBezier.mjs';\nimport { buildAdaptiveQuadratic } from '../buildCommands/buildAdaptiveQuadratic.mjs';\nimport { buildArc } from '../buildCommands/buildArc.mjs';\nimport { buildArcTo } from '../buildCommands/buildArcTo.mjs';\nimport { buildArcToSvg } from '../buildCommands/buildArcToSvg.mjs';\nimport { roundedShapeQuadraticCurve, roundedShapeArc } from './roundShape.mjs';\n\"use strict\";\nconst tempRectangle = new Rectangle();\nclass ShapePath {\n  constructor(graphicsPath2D) {\n    /** The list of shape primitives that make up the path. */\n    this.shapePrimitives = [];\n    this._currentPoly = null;\n    this._bounds = new Bounds();\n    this._graphicsPath2D = graphicsPath2D;\n    this.signed = graphicsPath2D.checkForHoles;\n  }\n  /**\n   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n   * @param x - The x-coordinate for the starting point.\n   * @param y - The y-coordinate for the starting point.\n   * @returns The instance of the current object for chaining.\n   */\n  moveTo(x, y) {\n    this.startPoly(x, y);\n    return this;\n  }\n  /**\n   * Connects the current point to a new point with a straight line. This method updates the current path.\n   * @param x - The x-coordinate of the new point to connect to.\n   * @param y - The y-coordinate of the new point to connect to.\n   * @returns The instance of the current object for chaining.\n   */\n  lineTo(x, y) {\n    this._ensurePoly();\n    const points = this._currentPoly.points;\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n    if (fromX !== x || fromY !== y) {\n      points.push(x, y);\n    }\n    return this;\n  }\n  /**\n   * Adds an arc to the path. The arc is centered at (x, y)\n   *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n   * @param x - The x-coordinate of the arc's center.\n   * @param y - The y-coordinate of the arc's center.\n   * @param radius - The radius of the arc.\n   * @param startAngle - The starting angle of the arc, in radians.\n   * @param endAngle - The ending angle of the arc, in radians.\n   * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n   * @returns The instance of the current object for chaining.\n   */\n  arc(x, y, radius, startAngle, endAngle, counterclockwise) {\n    this._ensurePoly(false);\n    const points = this._currentPoly.points;\n    buildArc(points, x, y, radius, startAngle, endAngle, counterclockwise);\n    return this;\n  }\n  /**\n   * Adds an arc to the path with the arc tangent to the line joining two specified points.\n   * The arc radius is specified by `radius`.\n   * @param x1 - The x-coordinate of the first point.\n   * @param y1 - The y-coordinate of the first point.\n   * @param x2 - The x-coordinate of the second point.\n   * @param y2 - The y-coordinate of the second point.\n   * @param radius - The radius of the arc.\n   * @returns The instance of the current object for chaining.\n   */\n  arcTo(x1, y1, x2, y2, radius) {\n    this._ensurePoly();\n    const points = this._currentPoly.points;\n    buildArcTo(points, x1, y1, x2, y2, radius);\n    return this;\n  }\n  /**\n   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n   * @param rx - The x-radius of the ellipse.\n   * @param ry - The y-radius of the ellipse.\n   * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n   * to the x-axis of the coordinate system, in degrees.\n   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n   * @param x - The x-coordinate of the arc's end point.\n   * @param y - The y-coordinate of the arc's end point.\n   * @returns The instance of the current object for chaining.\n   */\n  arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n    const points = this._currentPoly.points;\n    buildArcToSvg(points, this._currentPoly.lastX, this._currentPoly.lastY, x, y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag);\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires three points: the first two are control points and the third one is the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the first control point.\n   * @param cp1y - The y-coordinate of the first control point.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {\n    this._ensurePoly();\n    const currentPoly = this._currentPoly;\n    buildAdaptiveBezier(this._currentPoly.points, currentPoly.lastX, currentPoly.lastY, cp1x, cp1y, cp2x, cp2y, x, y, smoothness);\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the control point.\n   * @param cp1y - The y-coordinate of the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothing - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveTo(cp1x, cp1y, x, y, smoothing) {\n    this._ensurePoly();\n    const currentPoly = this._currentPoly;\n    buildAdaptiveQuadratic(this._currentPoly.points, currentPoly.lastX, currentPoly.lastY, cp1x, cp1y, x, y, smoothing);\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this.endPoly(true);\n    return this;\n  }\n  /**\n   * Adds another path to the current path. This method allows for the combination of multiple paths into one.\n   * @param path - The `GraphicsPath` object representing the path to add.\n   * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.\n   * @returns The instance of the current object for chaining.\n   */\n  addPath(path, transform) {\n    this.endPoly();\n    if (transform && !transform.isIdentity()) {\n      path = path.clone(true);\n      path.transform(transform);\n    }\n    const shapePrimitives = this.shapePrimitives;\n    const start = shapePrimitives.length;\n    for (let i = 0; i < path.instructions.length; i++) {\n      const instruction = path.instructions[i];\n      this[instruction.action](...instruction.data);\n    }\n    if (path.checkForHoles && shapePrimitives.length - start > 1) {\n      let mainShape = null;\n      for (let i = start; i < shapePrimitives.length; i++) {\n        const shapePrimitive = shapePrimitives[i];\n        if (shapePrimitive.shape.type === \"polygon\") {\n          const polygon = shapePrimitive.shape;\n          const mainPolygon = mainShape?.shape;\n          if (mainPolygon && mainPolygon.containsPolygon(polygon)) {\n            mainShape.holes || (mainShape.holes = []);\n            mainShape.holes.push(shapePrimitive);\n            shapePrimitives.copyWithin(i, i + 1);\n            shapePrimitives.length--;\n            i--;\n          } else {\n            mainShape = shapePrimitive;\n          }\n        }\n      }\n    }\n    return this;\n  }\n  /**\n   * Finalizes the drawing of the current path. Optionally, it can close the path.\n   * @param closePath - A boolean indicating whether to close the path after finishing. False by default.\n   */\n  finish(closePath = false) {\n    this.endPoly(closePath);\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h, transform) {\n    this.drawShape(new Rectangle(x, y, w, h), transform);\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius, transform) {\n    this.drawShape(new Circle(x, y, radius), transform);\n    return this;\n  }\n  /**\n   * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.\n   * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n   * representing the x and y coordinates of the polygon's vertices, in sequence.\n   * @param close - A boolean indicating whether to close the polygon path. True by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  poly(points, close, transform) {\n    const polygon = new Polygon(points);\n    polygon.closePath = close;\n    this.drawShape(polygon, transform);\n    return this;\n  }\n  /**\n   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  regularPoly(x, y, radius, sides, rotation = 0, transform) {\n    sides = Math.max(sides | 0, 3);\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const delta = Math.PI * 2 / sides;\n    const polygon = [];\n    for (let i = 0; i < sides; i++) {\n      const angle = startAngle - i * delta;\n      polygon.push(x + radius * Math.cos(angle), y + radius * Math.sin(angle));\n    }\n    this.poly(polygon, true, transform);\n    return this;\n  }\n  /**\n   * Draws a polygon with rounded corners.\n   * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param corner - The radius of the rounding of the corners.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param smoothness - Optional parameter to adjust the smoothness of the rounding.\n   * @returns The instance of the current object for chaining.\n   */\n  roundPoly(x, y, radius, sides, corner, rotation = 0, smoothness) {\n    sides = Math.max(sides | 0, 3);\n    if (corner <= 0) {\n      return this.regularPoly(x, y, radius, sides, rotation);\n    }\n    const sideLength = radius * Math.sin(Math.PI / sides) - 1e-3;\n    corner = Math.min(corner, sideLength);\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const delta = Math.PI * 2 / sides;\n    const internalAngle = (sides - 2) * Math.PI / sides / 2;\n    for (let i = 0; i < sides; i++) {\n      const angle = i * delta + startAngle;\n      const x0 = x + radius * Math.cos(angle);\n      const y0 = y + radius * Math.sin(angle);\n      const a1 = angle + Math.PI + internalAngle;\n      const a2 = angle - Math.PI - internalAngle;\n      const x1 = x0 + corner * Math.cos(a1);\n      const y1 = y0 + corner * Math.sin(a1);\n      const x3 = x0 + corner * Math.cos(a2);\n      const y3 = y0 + corner * Math.sin(a2);\n      if (i === 0) {\n        this.moveTo(x1, y1);\n      } else {\n        this.lineTo(x1, y1);\n      }\n      this.quadraticCurveTo(x0, y0, x3, y3, smoothness);\n    }\n    return this.closePath();\n  }\n  /**\n   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n   * A minimum of 3 points is required.\n   * @param radius - The default radius for the corners.\n   * This radius is applied to all corners unless overridden in `points`.\n   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n   *  method instead of an arc method. Defaults to false.\n   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n   * Higher values make the curve smoother.\n   * @returns The instance of the current object for chaining.\n   */\n  roundShape(points, radius, useQuadratic = false, smoothness) {\n    if (points.length < 3) {\n      return this;\n    }\n    if (useQuadratic) {\n      roundedShapeQuadraticCurve(this, points, radius, smoothness);\n    } else {\n      roundedShapeArc(this, points, radius);\n    }\n    return this.closePath();\n  }\n  /**\n   * Draw Rectangle with fillet corners. This is much like rounded rectangle\n   * however it support negative numbers as well for the corner radius.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param fillet - accept negative or positive values\n   */\n  filletRect(x, y, width, height, fillet) {\n    if (fillet === 0) {\n      return this.rect(x, y, width, height);\n    }\n    const maxFillet = Math.min(width, height) / 2;\n    const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));\n    const right = x + width;\n    const bottom = y + height;\n    const dir = inset < 0 ? -inset : 0;\n    const size = Math.abs(inset);\n    return this.moveTo(x, y + size).arcTo(x + dir, y + dir, x + size, y, size).lineTo(right - size, y).arcTo(right - dir, y + dir, right, y + size, size).lineTo(right, bottom - size).arcTo(right - dir, bottom - dir, x + width - size, bottom, size).lineTo(x + size, bottom).arcTo(x + dir, bottom - dir, x, bottom - size, size).closePath();\n  }\n  /**\n   * Draw Rectangle with chamfer corners. These are angled corners.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param chamfer - non-zero real number, size of corner cutout\n   * @param transform\n   */\n  chamferRect(x, y, width, height, chamfer, transform) {\n    if (chamfer <= 0) {\n      return this.rect(x, y, width, height);\n    }\n    const inset = Math.min(chamfer, Math.min(width, height) / 2);\n    const right = x + width;\n    const bottom = y + height;\n    const points = [x + inset, y, right - inset, y, right, y + inset, right, bottom - inset, right - inset, bottom, x + inset, bottom, x, bottom - inset, x, y + inset];\n    for (let i = points.length - 1; i >= 2; i -= 2) {\n      if (points[i] === points[i - 2] && points[i - 1] === points[i - 3]) {\n        points.splice(i - 1, 2);\n      }\n    }\n    return this.poly(points, true, transform);\n  }\n  /**\n   * Draws an ellipse at the specified location and with the given x and y radii.\n   * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n   * @param x - The x-coordinate of the center of the ellipse.\n   * @param y - The y-coordinate of the center of the ellipse.\n   * @param radiusX - The horizontal radius of the ellipse.\n   * @param radiusY - The vertical radius of the ellipse.\n   * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n   * @returns The instance of the current object for chaining.\n   */\n  ellipse(x, y, radiusX, radiusY, transform) {\n    this.drawShape(new Ellipse(x, y, radiusX, radiusY), transform);\n    return this;\n  }\n  /**\n   * Draws a rectangle with rounded corners.\n   * The corner radius can be specified to determine how rounded the corners should be.\n   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  roundRect(x, y, w, h, radius, transform) {\n    this.drawShape(new RoundedRectangle(x, y, w, h, radius), transform);\n    return this;\n  }\n  /**\n   * Draws a given shape on the canvas.\n   * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.\n   * An optional transformation matrix can be applied to the shape, allowing for complex transformations.\n   * @param shape - The shape to draw, defined as a `ShapePrimitive` object.\n   * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,\n   * scaling, and translations.\n   * @returns The instance of the current object for chaining.\n   */\n  drawShape(shape, matrix) {\n    this.endPoly();\n    this.shapePrimitives.push({\n      shape,\n      transform: matrix\n    });\n    return this;\n  }\n  /**\n   * Starts a new polygon path from the specified starting point.\n   * This method initializes a new polygon or ends the current one if it exists.\n   * @param x - The x-coordinate of the starting point of the new polygon.\n   * @param y - The y-coordinate of the starting point of the new polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  startPoly(x, y) {\n    let currentPoly = this._currentPoly;\n    if (currentPoly) {\n      this.endPoly();\n    }\n    currentPoly = new Polygon();\n    currentPoly.points.push(x, y);\n    this._currentPoly = currentPoly;\n    return this;\n  }\n  /**\n   * Ends the current polygon path. If `closePath` is set to true,\n   * the path is closed by connecting the last point to the first one.\n   * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.\n   * @param closePath - A boolean indicating whether to close the polygon by connecting the last point\n   *  back to the starting point. False by default.\n   * @returns The instance of the current object for chaining.\n   */\n  endPoly(closePath = false) {\n    const shape = this._currentPoly;\n    if (shape && shape.points.length > 2) {\n      shape.closePath = closePath;\n      this.shapePrimitives.push({\n        shape\n      });\n    }\n    this._currentPoly = null;\n    return this;\n  }\n  _ensurePoly(start = true) {\n    if (this._currentPoly) return;\n    this._currentPoly = new Polygon();\n    if (start) {\n      const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];\n      if (lastShape) {\n        let lx = lastShape.shape.x;\n        let ly = lastShape.shape.y;\n        if (lastShape.transform && !lastShape.transform.isIdentity()) {\n          const t = lastShape.transform;\n          const tempX = lx;\n          lx = t.a * lx + t.c * ly + t.tx;\n          ly = t.b * tempX + t.d * ly + t.ty;\n        }\n        this._currentPoly.points.push(lx, ly);\n      } else {\n        this._currentPoly.points.push(0, 0);\n      }\n    }\n  }\n  /** Builds the path. */\n  buildPath() {\n    const path = this._graphicsPath2D;\n    this.shapePrimitives.length = 0;\n    this._currentPoly = null;\n    for (let i = 0; i < path.instructions.length; i++) {\n      const instruction = path.instructions[i];\n      this[instruction.action](...instruction.data);\n    }\n    this.finish();\n  }\n  /** Gets the bounds of the path. */\n  get bounds() {\n    const bounds = this._bounds;\n    bounds.clear();\n    const shapePrimitives = this.shapePrimitives;\n    for (let i = 0; i < shapePrimitives.length; i++) {\n      const shapePrimitive = shapePrimitives[i];\n      const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);\n      if (shapePrimitive.transform) {\n        bounds.addRect(boundsRect, shapePrimitive.transform);\n      } else {\n        bounds.addRect(boundsRect);\n      }\n    }\n    return bounds;\n  }\n}\nexport { ShapePath };","map":{"version":3,"names":["tempRectangle","Rectangle","ShapePath","constructor","graphicsPath2D","shapePrimitives","_currentPoly","_bounds","Bounds","_graphicsPath2D","signed","checkForHoles","moveTo","x","y","startPoly","lineTo","_ensurePoly","points","fromX","length","fromY","push","arc","radius","startAngle","endAngle","counterclockwise","buildArc","arcTo","x1","y1","x2","y2","buildArcTo","arcToSvg","rx","ry","xAxisRotation","largeArcFlag","sweepFlag","buildArcToSvg","lastX","lastY","bezierCurveTo","cp1x","cp1y","cp2x","cp2y","smoothness","currentPoly","buildAdaptiveBezier","quadraticCurveTo","smoothing","buildAdaptiveQuadratic","closePath","endPoly","addPath","path","transform","isIdentity","clone","start","i","instructions","instruction","action","data","mainShape","shapePrimitive","shape","type","polygon","mainPolygon","containsPolygon","holes","copyWithin","finish","rect","w","h","drawShape","circle","Circle","poly","close","Polygon","regularPoly","sides","rotation","Math","max","PI","delta","angle","cos","sin","roundPoly","corner","sideLength","min","internalAngle","x0","y0","a1","a2","x3","y3","roundShape","useQuadratic","roundedShapeQuadraticCurve","roundedShapeArc","filletRect","width","height","fillet","maxFillet","inset","right","bottom","dir","size","abs","chamferRect","chamfer","splice","ellipse","radiusX","radiusY","Ellipse","roundRect","RoundedRectangle","matrix","lastShape","lx","ly","t","tempX","a","c","tx","b","d","ty","buildPath","bounds","clear","boundsRect","getBounds","addRect"],"sources":["C:\\Users\\emalv\\OneDrive\\Desktop\\Portafolio\\cv-ciudad\\node_modules\\pixi.js\\src\\scene\\graphics\\shared\\path\\ShapePath.ts"],"sourcesContent":["// a shape lets you build out a shape with lines and curves and primitives..\n\nimport { Circle } from '../../../../maths/shapes/Circle';\nimport { Ellipse } from '../../../../maths/shapes/Ellipse';\nimport { Polygon } from '../../../../maths/shapes/Polygon';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { RoundedRectangle } from '../../../../maths/shapes/RoundedRectangle';\nimport { Bounds } from '../../../container/bounds/Bounds';\nimport { buildAdaptiveBezier } from '../buildCommands/buildAdaptiveBezier';\nimport { buildAdaptiveQuadratic } from '../buildCommands/buildAdaptiveQuadratic';\nimport { buildArc } from '../buildCommands/buildArc';\nimport { buildArcTo } from '../buildCommands/buildArcTo';\nimport { buildArcToSvg } from '../buildCommands/buildArcToSvg';\nimport { roundedShapeArc, roundedShapeQuadraticCurve } from './roundShape';\n\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { ShapePrimitive } from '../../../../maths/shapes/ShapePrimitive';\nimport type { GraphicsPath } from './GraphicsPath';\nimport type { RoundedPoint } from './roundShape';\n\nconst tempRectangle = new Rectangle();\n\nexport type ShapePrimitiveWithHoles = {\n    shape: ShapePrimitive,\n    transform?: Matrix,\n    holes?: ShapePrimitiveWithHoles[]\n};\n\n/**\n * The `ShapePath` class acts as a bridge between high-level drawing commands\n * and the lower-level `GraphicsContext` rendering engine.\n * It translates drawing commands, such as those for creating lines, arcs, ellipses, rectangles, and complex polygons, into a\n * format that can be efficiently processed by a `GraphicsContext`. This includes handling path starts,\n * ends, and transformations for shapes.\n *\n * It is used internally by `GraphicsPath` to build up the path.\n * @memberof scene\n */\nexport class ShapePath\n{\n    /** The list of shape primitives that make up the path. */\n    public shapePrimitives: ShapePrimitiveWithHoles[] = [];\n    private _currentPoly: Polygon | null = null;\n    private readonly _graphicsPath2D: GraphicsPath;\n    private readonly _bounds = new Bounds();\n    public readonly signed: boolean;\n\n    constructor(graphicsPath2D: GraphicsPath)\n    {\n        this._graphicsPath2D = graphicsPath2D;\n        this.signed = graphicsPath2D.checkForHoles;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this\n    {\n        this.startPoly(x, y);\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this\n    {\n        this._ensurePoly();\n\n        const points = this._currentPoly.points;\n\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        if (fromX !== x || fromY !== y)\n        {\n            points.push(x, y);\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path. The arc is centered at (x, y)\n     *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The radius of the arc.\n     * @param startAngle - The starting angle of the arc, in radians.\n     * @param endAngle - The ending angle of the arc, in radians.\n     * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise: boolean): this\n    {\n        // TODO - if its 360 degrees.. make it a circle object?\n\n        this._ensurePoly(false);\n\n        const points = this._currentPoly.points;\n\n        buildArc(points, x, y, radius, startAngle, endAngle, counterclockwise);\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path with the arc tangent to the line joining two specified points.\n     * The arc radius is specified by `radius`.\n     * @param x1 - The x-coordinate of the first point.\n     * @param y1 - The y-coordinate of the first point.\n     * @param x2 - The x-coordinate of the second point.\n     * @param y2 - The y-coordinate of the second point.\n     * @param radius - The radius of the arc.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this\n    {\n        this._ensurePoly();\n\n        const points = this._currentPoly.points;\n\n        buildArcTo(points, x1, y1, x2, y2, radius);\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcToSvg(\n        rx: number, ry: number,\n        xAxisRotation: number, largeArcFlag: number, sweepFlag: number,\n        x: number, y: number\n    ): this\n    {\n        const points = this._currentPoly.points;\n\n        // this needs to work on both canvas and GPU backends so might want to move this to the Graphics2D path..\n        buildArcToSvg(\n            points,\n            this._currentPoly.lastX,\n            this._currentPoly.lastY,\n            x,\n            y,\n            rx,\n            ry,\n            xAxisRotation,\n            largeArcFlag,\n            sweepFlag,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number,\n        x: number, y: number,\n        smoothness?: number\n    ): this\n    {\n        this._ensurePoly();\n\n        const currentPoly = this._currentPoly;\n\n        // ensure distance from last point to first control point is not too small\n\n        // TODO - make this a plugin that people can override..\n        buildAdaptiveBezier(\n            this._currentPoly.points,\n            currentPoly.lastX, currentPoly.lastY,\n            cp1x, cp1y, cp2x, cp2y, x, y,\n            smoothness,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the control point.\n     * @param cp1y - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothing - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cp1x: number, cp1y: number, x: number, y: number, smoothing?: number): this\n    {\n        this._ensurePoly();\n\n        const currentPoly = this._currentPoly;\n\n        // ensure distance from last point to first control point is not too small\n\n        // TODO - make this a plugin that people can override..\n        buildAdaptiveQuadratic(\n            this._currentPoly.points,\n            currentPoly.lastX, currentPoly.lastY,\n            cp1x, cp1y, x, y,\n            smoothing,\n        );\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this.endPoly(true);\n\n        return this;\n    }\n\n    /**\n     * Adds another path to the current path. This method allows for the combination of multiple paths into one.\n     * @param path - The `GraphicsPath` object representing the path to add.\n     * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.\n     * @returns The instance of the current object for chaining.\n     */\n    public addPath(path: GraphicsPath, transform?: Matrix): this\n    {\n        this.endPoly();\n\n        // Only clone if we need to transform\n        if (transform && !transform.isIdentity())\n        {\n            path = path.clone(true);\n            path.transform(transform);\n        }\n\n        const shapePrimitives = this.shapePrimitives;\n        const start = shapePrimitives.length;\n\n        for (let i = 0; i < path.instructions.length; i++)\n        {\n            const instruction = path.instructions[i];\n\n            this[instruction.action](...(instruction.data as [never, never, never, never, never, never, never]));\n        }\n\n        // This section processes holes in polygons by checking if any polygon is contained within another.\n        // If a polygon is found to be inside another polygon (mainShape), it's treated as a hole.\n        // The hole polygon is removed from the main shapePrimitives array and added to the holes array\n        // of the containing polygon. This allows for proper rendering of shapes with holes.\n        if (path.checkForHoles && shapePrimitives.length - start > 1)\n        {\n            let mainShape = null;\n\n            // Process in place instead of creating a removal array\n            for (let i = start; i < shapePrimitives.length; i++)\n            {\n                const shapePrimitive = shapePrimitives[i];\n\n                if (shapePrimitive.shape.type === 'polygon')\n                {\n                    const polygon = shapePrimitive.shape as Polygon;\n                    const mainPolygon = mainShape?.shape as Polygon;\n\n                    if (mainPolygon && mainPolygon.containsPolygon(polygon))\n                    {\n                        // Initialize holes array only when needed\n                        mainShape.holes ||= [];\n                        mainShape.holes.push(shapePrimitive);\n\n                        // Remove the hole by moving elements left\n                        shapePrimitives.copyWithin(i, i + 1);\n                        shapePrimitives.length--;\n                        i--;\n                    }\n                    else\n                    {\n                        mainShape = shapePrimitive;\n                    }\n                }\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Finalizes the drawing of the current path. Optionally, it can close the path.\n     * @param closePath - A boolean indicating whether to close the path after finishing. False by default.\n     */\n    public finish(closePath = false)\n    {\n        this.endPoly(closePath);\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number, transform?: Matrix): this\n    {\n        this.drawShape(new Rectangle(x, y, w, h), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number, transform?: Matrix): this\n    {\n        this.drawShape(new Circle(x, y, radius), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.\n     * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n     * representing the x and y coordinates of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public poly(points: number[] | PointData[], close?: boolean, transform?: Matrix): this\n    {\n        const polygon = new Polygon(points);\n\n        polygon.closePath = close;\n\n        this.drawShape(polygon, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation = 0, transform?: Matrix): this\n    {\n        sides = Math.max(sides | 0, 3);\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const delta = (Math.PI * 2) / sides;\n        const polygon = [];\n\n        for (let i = 0; i < sides; i++)\n        {\n            const angle = startAngle - (i * delta);\n\n            polygon.push(\n                x + (radius * Math.cos(angle)),\n                y + (radius * Math.sin(angle))\n            );\n        }\n\n        this.poly(polygon, true, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param smoothness - Optional parameter to adjust the smoothness of the rounding.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(\n        x: number, y: number,\n        radius: number,\n        sides: number, corner: number,\n        rotation = 0,\n        smoothness?: number,\n    ): this\n    {\n        sides = Math.max((sides | 0), 3);\n\n        if (corner <= 0)\n        {\n            return this.regularPoly(x, y, radius, sides, rotation);\n        }\n\n        const sideLength = (radius * Math.sin(Math.PI / sides)) - 0.001;\n\n        corner = Math.min(corner, sideLength);\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const delta = (Math.PI * 2) / sides;\n        const internalAngle = ((sides - 2) * Math.PI) / sides / 2;\n\n        for (let i = 0; i < sides; i++)\n        {\n            const angle = (i * delta) + startAngle;\n            const x0 = x + (radius * Math.cos(angle));\n            const y0 = y + (radius * Math.sin(angle));\n            const a1 = angle + (Math.PI) + internalAngle;\n            const a2 = angle - (Math.PI) - internalAngle;\n            const x1 = x0 + (corner * Math.cos(a1));\n            const y1 = y0 + (corner * Math.sin(a1));\n            const x3 = x0 + (corner * Math.cos(a2));\n            const y3 = y0 + (corner * Math.sin(a2));\n\n            if (i === 0)\n            {\n                this.moveTo(x1, y1);\n            }\n            else\n            {\n                this.lineTo(x1, y1);\n            }\n            this.quadraticCurveTo(x0, y0, x3, y3, smoothness);\n        }\n\n        return this.closePath();\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic = false, smoothness?: number): this\n    {\n        if (points.length < 3)\n        {\n            return this;\n        }\n\n        if (useQuadratic)\n        {\n            roundedShapeQuadraticCurve(this, points, radius, smoothness);\n        }\n        else\n        {\n            roundedShapeArc(this, points, radius);\n        }\n\n        return this.closePath();\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this\n    {\n        if (fillet === 0)\n        {\n            return this.rect(x, y, width, height);\n        }\n\n        const maxFillet = Math.min(width, height) / 2;\n        const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));\n        const right = x + width;\n        const bottom = y + height;\n        const dir = inset < 0 ? -inset : 0;\n        const size = Math.abs(inset);\n\n        return this\n            .moveTo(x, y + size)\n            .arcTo(x + dir, y + dir, x + size, y, size)\n            .lineTo(right - size, y)\n            .arcTo(right - dir, y + dir, right, y + size, size)\n            .lineTo(right, bottom - size)\n            .arcTo(right - dir, bottom - dir, x + width - size, bottom, size)\n            .lineTo(x + size, bottom)\n            .arcTo(x + dir, bottom - dir, x, bottom - size, size)\n            .closePath();\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this\n    {\n        if (chamfer <= 0)\n        {\n            return this.rect(x, y, width, height);\n        }\n\n        const inset = Math.min(chamfer, Math.min(width, height) / 2);\n        const right = x + width;\n        const bottom = y + height;\n        const points = [\n            x + inset, y,\n            right - inset, y,\n            right, y + inset,\n            right, bottom - inset,\n            right - inset, bottom,\n            x + inset, bottom,\n            x, bottom - inset,\n            x, y + inset,\n        ];\n\n        // Remove overlapping points\n        for (let i = points.length - 1; i >= 2; i -= 2)\n        {\n            if (points[i] === points[i - 2] && points[i - 1] === points[i - 3])\n            {\n                points.splice(i - 1, 2);\n            }\n        }\n\n        return this.poly(points, true, transform);\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number, transform?: Matrix): this\n    {\n        // TODO apply rotation to transform...\n\n        this.drawShape(new Ellipse(x, y, radiusX, radiusY), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number, transform?: Matrix): this\n    {\n        this.drawShape(new RoundedRectangle(x, y, w, h, radius), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a given shape on the canvas.\n     * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.\n     * An optional transformation matrix can be applied to the shape, allowing for complex transformations.\n     * @param shape - The shape to draw, defined as a `ShapePrimitive` object.\n     * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,\n     * scaling, and translations.\n     * @returns The instance of the current object for chaining.\n     */\n    public drawShape(shape: ShapePrimitive, matrix?: Matrix): this\n    {\n        this.endPoly();\n\n        this.shapePrimitives.push({ shape, transform: matrix });\n\n        return this;\n    }\n\n    /**\n     * Starts a new polygon path from the specified starting point.\n     * This method initializes a new polygon or ends the current one if it exists.\n     * @param x - The x-coordinate of the starting point of the new polygon.\n     * @param y - The y-coordinate of the starting point of the new polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public startPoly(x: number, y: number): this\n    {\n        let currentPoly = this._currentPoly;\n\n        if (currentPoly)\n        {\n            this.endPoly();\n        }\n\n        currentPoly = new Polygon();\n\n        currentPoly.points.push(x, y);\n\n        this._currentPoly = currentPoly;\n\n        return this;\n    }\n\n    /**\n     * Ends the current polygon path. If `closePath` is set to true,\n     * the path is closed by connecting the last point to the first one.\n     * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.\n     * @param closePath - A boolean indicating whether to close the polygon by connecting the last point\n     *  back to the starting point. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public endPoly(closePath = false): this\n    {\n        const shape = this._currentPoly;\n\n        if (shape && shape.points.length > 2)\n        {\n            shape.closePath = closePath;\n\n            this.shapePrimitives.push({ shape });\n        }\n\n        this._currentPoly = null;\n\n        return this;\n    }\n\n    private _ensurePoly(start = true): void\n    {\n        if (this._currentPoly) return;\n\n        this._currentPoly = new Polygon();\n\n        if (start)\n        {\n            // get last points..\n            const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];\n\n            if (lastShape)\n            {\n                // i KNOW its a rect..\n                let lx = lastShape.shape.x;\n                let ly = lastShape.shape.y;\n\n                if (lastShape.transform && !lastShape.transform.isIdentity())\n                {\n                    const t = lastShape.transform;\n\n                    const tempX = lx;\n\n                    lx = (t.a * lx) + (t.c * ly) + t.tx;\n                    ly = (t.b * tempX) + (t.d * ly) + t.ty;\n                }\n\n                this._currentPoly.points.push(lx, ly);\n            }\n            else\n            {\n                this._currentPoly.points.push(0, 0);\n            }\n        }\n    }\n\n    /** Builds the path. */\n    public buildPath()\n    {\n        const path = this._graphicsPath2D;\n\n        this.shapePrimitives.length = 0;\n        this._currentPoly = null;\n\n        for (let i = 0; i < path.instructions.length; i++)\n        {\n            const instruction = path.instructions[i];\n\n            // Sorry TS! this is the best we could do...\n            this[instruction.action](...(instruction.data as [never, never, never, never, never, never, never]));\n        }\n\n        this.finish();\n    }\n\n    /** Gets the bounds of the path. */\n    get bounds(): Bounds\n    {\n        const bounds = this._bounds;\n\n        bounds.clear();\n\n        const shapePrimitives = this.shapePrimitives;\n\n        for (let i = 0; i < shapePrimitives.length; i++)\n        {\n            const shapePrimitive = shapePrimitives[i];\n\n            const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);\n\n            if (shapePrimitive.transform)\n            {\n                bounds.addRect(boundsRect, shapePrimitive.transform);\n            }\n            else\n            {\n                bounds.addRect(boundsRect);\n            }\n        }\n\n        return bounds;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}